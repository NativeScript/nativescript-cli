/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(1);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(console) {'use strict';

	var _kinvey = __webpack_require__(9);

	var _expect = __webpack_require__(456);

	var _expect2 = _interopRequireDefault(_expect);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	_kinvey.Kinvey.init({
	  appKey: 'kid_HkTD2CJc',
	  appSecret: 'cd7f658ed0a548dd8dfadf5a1787568b'
	});

	_kinvey.Kinvey.ping().then(function (response) {
	  console.log(response);
	});

	describe('Compare Numbers', function () {
	  it('1 should equal 1', function () {
	    (0, _expect2.default)(1).toEqual(1);
	  });

	  // it('2 should be greater than 1', function() {
	  //   expect(2).to.be.greaterThan(1);
	  // });
	});
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/*global window, global*/
	var util = __webpack_require__(3)
	var assert = __webpack_require__(7)
	var now = __webpack_require__(8)

	var slice = Array.prototype.slice
	var console
	var times = {}

	if (typeof global !== "undefined" && global.console) {
	    console = global.console
	} else if (typeof window !== "undefined" && window.console) {
	    console = window.console
	} else {
	    console = {}
	}

	var functions = [
	    [log, "log"],
	    [info, "info"],
	    [warn, "warn"],
	    [error, "error"],
	    [time, "time"],
	    [timeEnd, "timeEnd"],
	    [trace, "trace"],
	    [dir, "dir"],
	    [consoleAssert, "assert"]
	]

	for (var i = 0; i < functions.length; i++) {
	    var tuple = functions[i]
	    var f = tuple[0]
	    var name = tuple[1]

	    if (!console[name]) {
	        console[name] = f
	    }
	}

	module.exports = console

	function log() {}

	function info() {
	    console.log.apply(console, arguments)
	}

	function warn() {
	    console.log.apply(console, arguments)
	}

	function error() {
	    console.warn.apply(console, arguments)
	}

	function time(label) {
	    times[label] = now()
	}

	function timeEnd(label) {
	    var time = times[label]
	    if (!time) {
	        throw new Error("No such label: " + label)
	    }

	    var duration = now() - time
	    console.log(label + ": " + duration + "ms")
	}

	function trace() {
	    var err = new Error()
	    err.name = "Trace"
	    err.message = util.format.apply(null, arguments)
	    console.error(err.stack)
	}

	function dir(object) {
	    console.log(util.inspect(object) + "\n")
	}

	function consoleAssert(expression) {
	    if (!expression) {
	        var arr = slice.call(arguments, 1)
	        assert.ok(false, util.format.apply(null, arr))
	    }
	}

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process, console) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	var formatRegExp = /%[sdj%]/g;
	exports.format = function(f) {
	  if (!isString(f)) {
	    var objects = [];
	    for (var i = 0; i < arguments.length; i++) {
	      objects.push(inspect(arguments[i]));
	    }
	    return objects.join(' ');
	  }

	  var i = 1;
	  var args = arguments;
	  var len = args.length;
	  var str = String(f).replace(formatRegExp, function(x) {
	    if (x === '%%') return '%';
	    if (i >= len) return x;
	    switch (x) {
	      case '%s': return String(args[i++]);
	      case '%d': return Number(args[i++]);
	      case '%j':
	        try {
	          return JSON.stringify(args[i++]);
	        } catch (_) {
	          return '[Circular]';
	        }
	      default:
	        return x;
	    }
	  });
	  for (var x = args[i]; i < len; x = args[++i]) {
	    if (isNull(x) || !isObject(x)) {
	      str += ' ' + x;
	    } else {
	      str += ' ' + inspect(x);
	    }
	  }
	  return str;
	};


	// Mark that a method should not be used.
	// Returns a modified function which warns once by default.
	// If --no-deprecation is set, then it is a no-op.
	exports.deprecate = function(fn, msg) {
	  // Allow for deprecating things in the process of starting up.
	  if (isUndefined(global.process)) {
	    return function() {
	      return exports.deprecate(fn, msg).apply(this, arguments);
	    };
	  }

	  if (process.noDeprecation === true) {
	    return fn;
	  }

	  var warned = false;
	  function deprecated() {
	    if (!warned) {
	      if (process.throwDeprecation) {
	        throw new Error(msg);
	      } else if (process.traceDeprecation) {
	        console.trace(msg);
	      } else {
	        console.error(msg);
	      }
	      warned = true;
	    }
	    return fn.apply(this, arguments);
	  }

	  return deprecated;
	};


	var debugs = {};
	var debugEnviron;
	exports.debuglog = function(set) {
	  if (isUndefined(debugEnviron))
	    debugEnviron = process.env.NODE_DEBUG || '';
	  set = set.toUpperCase();
	  if (!debugs[set]) {
	    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
	      var pid = process.pid;
	      debugs[set] = function() {
	        var msg = exports.format.apply(exports, arguments);
	        console.error('%s %d: %s', set, pid, msg);
	      };
	    } else {
	      debugs[set] = function() {};
	    }
	  }
	  return debugs[set];
	};


	/**
	 * Echos the value of a value. Trys to print the value out
	 * in the best way possible given the different types.
	 *
	 * @param {Object} obj The object to print out.
	 * @param {Object} opts Optional options object that alters the output.
	 */
	/* legacy: obj, showHidden, depth, colors*/
	function inspect(obj, opts) {
	  // default options
	  var ctx = {
	    seen: [],
	    stylize: stylizeNoColor
	  };
	  // legacy...
	  if (arguments.length >= 3) ctx.depth = arguments[2];
	  if (arguments.length >= 4) ctx.colors = arguments[3];
	  if (isBoolean(opts)) {
	    // legacy...
	    ctx.showHidden = opts;
	  } else if (opts) {
	    // got an "options" object
	    exports._extend(ctx, opts);
	  }
	  // set default options
	  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
	  if (isUndefined(ctx.depth)) ctx.depth = 2;
	  if (isUndefined(ctx.colors)) ctx.colors = false;
	  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
	  if (ctx.colors) ctx.stylize = stylizeWithColor;
	  return formatValue(ctx, obj, ctx.depth);
	}
	exports.inspect = inspect;


	// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
	inspect.colors = {
	  'bold' : [1, 22],
	  'italic' : [3, 23],
	  'underline' : [4, 24],
	  'inverse' : [7, 27],
	  'white' : [37, 39],
	  'grey' : [90, 39],
	  'black' : [30, 39],
	  'blue' : [34, 39],
	  'cyan' : [36, 39],
	  'green' : [32, 39],
	  'magenta' : [35, 39],
	  'red' : [31, 39],
	  'yellow' : [33, 39]
	};

	// Don't use 'blue' not visible on cmd.exe
	inspect.styles = {
	  'special': 'cyan',
	  'number': 'yellow',
	  'boolean': 'yellow',
	  'undefined': 'grey',
	  'null': 'bold',
	  'string': 'green',
	  'date': 'magenta',
	  // "name": intentionally not styling
	  'regexp': 'red'
	};


	function stylizeWithColor(str, styleType) {
	  var style = inspect.styles[styleType];

	  if (style) {
	    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
	           '\u001b[' + inspect.colors[style][1] + 'm';
	  } else {
	    return str;
	  }
	}


	function stylizeNoColor(str, styleType) {
	  return str;
	}


	function arrayToHash(array) {
	  var hash = {};

	  array.forEach(function(val, idx) {
	    hash[val] = true;
	  });

	  return hash;
	}


	function formatValue(ctx, value, recurseTimes) {
	  // Provide a hook for user-specified inspect functions.
	  // Check that value is an object with an inspect function on it
	  if (ctx.customInspect &&
	      value &&
	      isFunction(value.inspect) &&
	      // Filter out the util module, it's inspect function is special
	      value.inspect !== exports.inspect &&
	      // Also filter out any prototype objects using the circular check.
	      !(value.constructor && value.constructor.prototype === value)) {
	    var ret = value.inspect(recurseTimes, ctx);
	    if (!isString(ret)) {
	      ret = formatValue(ctx, ret, recurseTimes);
	    }
	    return ret;
	  }

	  // Primitive types cannot have properties
	  var primitive = formatPrimitive(ctx, value);
	  if (primitive) {
	    return primitive;
	  }

	  // Look up the keys of the object.
	  var keys = Object.keys(value);
	  var visibleKeys = arrayToHash(keys);

	  if (ctx.showHidden) {
	    keys = Object.getOwnPropertyNames(value);
	  }

	  // IE doesn't make error fields non-enumerable
	  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
	  if (isError(value)
	      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
	    return formatError(value);
	  }

	  // Some type of object without properties can be shortcutted.
	  if (keys.length === 0) {
	    if (isFunction(value)) {
	      var name = value.name ? ': ' + value.name : '';
	      return ctx.stylize('[Function' + name + ']', 'special');
	    }
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    }
	    if (isDate(value)) {
	      return ctx.stylize(Date.prototype.toString.call(value), 'date');
	    }
	    if (isError(value)) {
	      return formatError(value);
	    }
	  }

	  var base = '', array = false, braces = ['{', '}'];

	  // Make Array say that they are Array
	  if (isArray(value)) {
	    array = true;
	    braces = ['[', ']'];
	  }

	  // Make functions say that they are functions
	  if (isFunction(value)) {
	    var n = value.name ? ': ' + value.name : '';
	    base = ' [Function' + n + ']';
	  }

	  // Make RegExps say that they are RegExps
	  if (isRegExp(value)) {
	    base = ' ' + RegExp.prototype.toString.call(value);
	  }

	  // Make dates with properties first say the date
	  if (isDate(value)) {
	    base = ' ' + Date.prototype.toUTCString.call(value);
	  }

	  // Make error with message first say the error
	  if (isError(value)) {
	    base = ' ' + formatError(value);
	  }

	  if (keys.length === 0 && (!array || value.length == 0)) {
	    return braces[0] + base + braces[1];
	  }

	  if (recurseTimes < 0) {
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    } else {
	      return ctx.stylize('[Object]', 'special');
	    }
	  }

	  ctx.seen.push(value);

	  var output;
	  if (array) {
	    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
	  } else {
	    output = keys.map(function(key) {
	      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
	    });
	  }

	  ctx.seen.pop();

	  return reduceToSingleString(output, base, braces);
	}


	function formatPrimitive(ctx, value) {
	  if (isUndefined(value))
	    return ctx.stylize('undefined', 'undefined');
	  if (isString(value)) {
	    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
	                                             .replace(/'/g, "\\'")
	                                             .replace(/\\"/g, '"') + '\'';
	    return ctx.stylize(simple, 'string');
	  }
	  if (isNumber(value))
	    return ctx.stylize('' + value, 'number');
	  if (isBoolean(value))
	    return ctx.stylize('' + value, 'boolean');
	  // For some reason typeof null is "object", so special case here.
	  if (isNull(value))
	    return ctx.stylize('null', 'null');
	}


	function formatError(value) {
	  return '[' + Error.prototype.toString.call(value) + ']';
	}


	function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
	  var output = [];
	  for (var i = 0, l = value.length; i < l; ++i) {
	    if (hasOwnProperty(value, String(i))) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          String(i), true));
	    } else {
	      output.push('');
	    }
	  }
	  keys.forEach(function(key) {
	    if (!key.match(/^\d+$/)) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          key, true));
	    }
	  });
	  return output;
	}


	function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
	  var name, str, desc;
	  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
	  if (desc.get) {
	    if (desc.set) {
	      str = ctx.stylize('[Getter/Setter]', 'special');
	    } else {
	      str = ctx.stylize('[Getter]', 'special');
	    }
	  } else {
	    if (desc.set) {
	      str = ctx.stylize('[Setter]', 'special');
	    }
	  }
	  if (!hasOwnProperty(visibleKeys, key)) {
	    name = '[' + key + ']';
	  }
	  if (!str) {
	    if (ctx.seen.indexOf(desc.value) < 0) {
	      if (isNull(recurseTimes)) {
	        str = formatValue(ctx, desc.value, null);
	      } else {
	        str = formatValue(ctx, desc.value, recurseTimes - 1);
	      }
	      if (str.indexOf('\n') > -1) {
	        if (array) {
	          str = str.split('\n').map(function(line) {
	            return '  ' + line;
	          }).join('\n').substr(2);
	        } else {
	          str = '\n' + str.split('\n').map(function(line) {
	            return '   ' + line;
	          }).join('\n');
	        }
	      }
	    } else {
	      str = ctx.stylize('[Circular]', 'special');
	    }
	  }
	  if (isUndefined(name)) {
	    if (array && key.match(/^\d+$/)) {
	      return str;
	    }
	    name = JSON.stringify('' + key);
	    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
	      name = name.substr(1, name.length - 2);
	      name = ctx.stylize(name, 'name');
	    } else {
	      name = name.replace(/'/g, "\\'")
	                 .replace(/\\"/g, '"')
	                 .replace(/(^"|"$)/g, "'");
	      name = ctx.stylize(name, 'string');
	    }
	  }

	  return name + ': ' + str;
	}


	function reduceToSingleString(output, base, braces) {
	  var numLinesEst = 0;
	  var length = output.reduce(function(prev, cur) {
	    numLinesEst++;
	    if (cur.indexOf('\n') >= 0) numLinesEst++;
	    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
	  }, 0);

	  if (length > 60) {
	    return braces[0] +
	           (base === '' ? '' : base + '\n ') +
	           ' ' +
	           output.join(',\n  ') +
	           ' ' +
	           braces[1];
	  }

	  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
	}


	// NOTE: These type checking functions intentionally don't use `instanceof`
	// because it is fragile and can be easily faked with `Object.create()`.
	function isArray(ar) {
	  return Array.isArray(ar);
	}
	exports.isArray = isArray;

	function isBoolean(arg) {
	  return typeof arg === 'boolean';
	}
	exports.isBoolean = isBoolean;

	function isNull(arg) {
	  return arg === null;
	}
	exports.isNull = isNull;

	function isNullOrUndefined(arg) {
	  return arg == null;
	}
	exports.isNullOrUndefined = isNullOrUndefined;

	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	exports.isNumber = isNumber;

	function isString(arg) {
	  return typeof arg === 'string';
	}
	exports.isString = isString;

	function isSymbol(arg) {
	  return typeof arg === 'symbol';
	}
	exports.isSymbol = isSymbol;

	function isUndefined(arg) {
	  return arg === void 0;
	}
	exports.isUndefined = isUndefined;

	function isRegExp(re) {
	  return isObject(re) && objectToString(re) === '[object RegExp]';
	}
	exports.isRegExp = isRegExp;

	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	exports.isObject = isObject;

	function isDate(d) {
	  return isObject(d) && objectToString(d) === '[object Date]';
	}
	exports.isDate = isDate;

	function isError(e) {
	  return isObject(e) &&
	      (objectToString(e) === '[object Error]' || e instanceof Error);
	}
	exports.isError = isError;

	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	exports.isFunction = isFunction;

	function isPrimitive(arg) {
	  return arg === null ||
	         typeof arg === 'boolean' ||
	         typeof arg === 'number' ||
	         typeof arg === 'string' ||
	         typeof arg === 'symbol' ||  // ES6 symbol
	         typeof arg === 'undefined';
	}
	exports.isPrimitive = isPrimitive;

	exports.isBuffer = __webpack_require__(5);

	function objectToString(o) {
	  return Object.prototype.toString.call(o);
	}


	function pad(n) {
	  return n < 10 ? '0' + n.toString(10) : n.toString(10);
	}


	var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
	              'Oct', 'Nov', 'Dec'];

	// 26 Feb 16:19:34
	function timestamp() {
	  var d = new Date();
	  var time = [pad(d.getHours()),
	              pad(d.getMinutes()),
	              pad(d.getSeconds())].join(':');
	  return [d.getDate(), months[d.getMonth()], time].join(' ');
	}


	// log is just a thin wrapper to console.log that prepends a timestamp
	exports.log = function() {
	  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
	};


	/**
	 * Inherit the prototype methods from one constructor into another.
	 *
	 * The Function.prototype.inherits from lang.js rewritten as a standalone
	 * function (not on Function.prototype). NOTE: If this file is to be loaded
	 * during bootstrapping this function needs to be rewritten using some native
	 * functions as prototype setup using normal JavaScript does not work as
	 * expected during bootstrapping (see mirror.js in r114903).
	 *
	 * @param {function} ctor Constructor function which needs to inherit the
	 *     prototype.
	 * @param {function} superCtor Constructor function to inherit prototype from.
	 */
	exports.inherits = __webpack_require__(6);

	exports._extend = function(origin, add) {
	  // Don't do anything if add isn't an object
	  if (!add || !isObject(add)) return origin;

	  var keys = Object.keys(add);
	  var i = keys.length;
	  while (i--) {
	    origin[keys[i]] = add[keys[i]];
	  }
	  return origin;
	};

	function hasOwnProperty(obj, prop) {
	  return Object.prototype.hasOwnProperty.call(obj, prop);
	}

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(4), __webpack_require__(2)))

/***/ },
/* 4 */
/***/ function(module, exports) {

	// shim for using process in browser
	var process = module.exports = {};

	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.

	var cachedSetTimeout;
	var cachedClearTimeout;

	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout () {
	    throw new Error('clearTimeout has not been defined');
	}
	(function () {
	    try {
	        if (typeof setTimeout === 'function') {
	            cachedSetTimeout = setTimeout;
	        } else {
	            cachedSetTimeout = defaultSetTimout;
	        }
	    } catch (e) {
	        cachedSetTimeout = defaultSetTimout;
	    }
	    try {
	        if (typeof clearTimeout === 'function') {
	            cachedClearTimeout = clearTimeout;
	        } else {
	            cachedClearTimeout = defaultClearTimeout;
	        }
	    } catch (e) {
	        cachedClearTimeout = defaultClearTimeout;
	    }
	} ())
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }


	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }



	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;

	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}

	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;

	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}

	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};

	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};

	function noop() {}

	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;

	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};

	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 5 */
/***/ function(module, exports) {

	module.exports = function isBuffer(arg) {
	  return arg && typeof arg === 'object'
	    && typeof arg.copy === 'function'
	    && typeof arg.fill === 'function'
	    && typeof arg.readUInt8 === 'function';
	}

/***/ },
/* 6 */
/***/ function(module, exports) {

	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  // old school shim for old browsers
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    var TempCtor = function () {}
	    TempCtor.prototype = superCtor.prototype
	    ctor.prototype = new TempCtor()
	    ctor.prototype.constructor = ctor
	  }
	}


/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';

	// compare and isBuffer taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js
	// original notice:

	/*!
	 * The buffer module from node.js, for the browser.
	 *
	 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
	 * @license  MIT
	 */
	function compare(a, b) {
	  if (a === b) {
	    return 0;
	  }

	  var x = a.length;
	  var y = b.length;

	  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
	    if (a[i] !== b[i]) {
	      x = a[i];
	      y = b[i];
	      break;
	    }
	  }

	  if (x < y) {
	    return -1;
	  }
	  if (y < x) {
	    return 1;
	  }
	  return 0;
	}
	function isBuffer(b) {
	  if (global.Buffer && typeof global.Buffer.isBuffer === 'function') {
	    return global.Buffer.isBuffer(b);
	  }
	  return !!(b != null && b._isBuffer);
	}

	// based on node assert, original notice:

	// http://wiki.commonjs.org/wiki/Unit_Testing/1.0
	//
	// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
	//
	// Originally from narwhal.js (http://narwhaljs.org)
	// Copyright (c) 2009 Thomas Robinson <280north.com>
	//
	// Permission is hereby granted, free of charge, to any person obtaining a copy
	// of this software and associated documentation files (the 'Software'), to
	// deal in the Software without restriction, including without limitation the
	// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
	// sell copies of the Software, and to permit persons to whom the Software is
	// furnished to do so, subject to the following conditions:
	//
	// The above copyright notice and this permission notice shall be included in
	// all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
	// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
	// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

	var util = __webpack_require__(3);
	var hasOwn = Object.prototype.hasOwnProperty;
	var pSlice = Array.prototype.slice;
	var functionsHaveNames = (function () {
	  return function foo() {}.name === 'foo';
	}());
	function pToString (obj) {
	  return Object.prototype.toString.call(obj);
	}
	function isView(arrbuf) {
	  if (isBuffer(arrbuf)) {
	    return false;
	  }
	  if (typeof global.ArrayBuffer !== 'function') {
	    return false;
	  }
	  if (typeof ArrayBuffer.isView === 'function') {
	    return ArrayBuffer.isView(arrbuf);
	  }
	  if (!arrbuf) {
	    return false;
	  }
	  if (arrbuf instanceof DataView) {
	    return true;
	  }
	  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
	    return true;
	  }
	  return false;
	}
	// 1. The assert module provides functions that throw
	// AssertionError's when particular conditions are not met. The
	// assert module must conform to the following interface.

	var assert = module.exports = ok;

	// 2. The AssertionError is defined in assert.
	// new assert.AssertionError({ message: message,
	//                             actual: actual,
	//                             expected: expected })

	var regex = /\s*function\s+([^\(\s]*)\s*/;
	// based on https://github.com/ljharb/function.prototype.name/blob/adeeeec8bfcc6068b187d7d9fb3d5bb1d3a30899/implementation.js
	function getName(func) {
	  if (!util.isFunction(func)) {
	    return;
	  }
	  if (functionsHaveNames) {
	    return func.name;
	  }
	  var str = func.toString();
	  var match = str.match(regex);
	  return match && match[1];
	}
	assert.AssertionError = function AssertionError(options) {
	  this.name = 'AssertionError';
	  this.actual = options.actual;
	  this.expected = options.expected;
	  this.operator = options.operator;
	  if (options.message) {
	    this.message = options.message;
	    this.generatedMessage = false;
	  } else {
	    this.message = getMessage(this);
	    this.generatedMessage = true;
	  }
	  var stackStartFunction = options.stackStartFunction || fail;
	  if (Error.captureStackTrace) {
	    Error.captureStackTrace(this, stackStartFunction);
	  } else {
	    // non v8 browsers so we can have a stacktrace
	    var err = new Error();
	    if (err.stack) {
	      var out = err.stack;

	      // try to strip useless frames
	      var fn_name = getName(stackStartFunction);
	      var idx = out.indexOf('\n' + fn_name);
	      if (idx >= 0) {
	        // once we have located the function frame
	        // we need to strip out everything before it (and its line)
	        var next_line = out.indexOf('\n', idx + 1);
	        out = out.substring(next_line + 1);
	      }

	      this.stack = out;
	    }
	  }
	};

	// assert.AssertionError instanceof Error
	util.inherits(assert.AssertionError, Error);

	function truncate(s, n) {
	  if (typeof s === 'string') {
	    return s.length < n ? s : s.slice(0, n);
	  } else {
	    return s;
	  }
	}
	function inspect(something) {
	  if (functionsHaveNames || !util.isFunction(something)) {
	    return util.inspect(something);
	  }
	  var rawname = getName(something);
	  var name = rawname ? ': ' + rawname : '';
	  return '[Function' +  name + ']';
	}
	function getMessage(self) {
	  return truncate(inspect(self.actual), 128) + ' ' +
	         self.operator + ' ' +
	         truncate(inspect(self.expected), 128);
	}

	// At present only the three keys mentioned above are used and
	// understood by the spec. Implementations or sub modules can pass
	// other keys to the AssertionError's constructor - they will be
	// ignored.

	// 3. All of the following functions must throw an AssertionError
	// when a corresponding condition is not met, with a message that
	// may be undefined if not provided.  All assertion methods provide
	// both the actual and expected values to the assertion error for
	// display purposes.

	function fail(actual, expected, message, operator, stackStartFunction) {
	  throw new assert.AssertionError({
	    message: message,
	    actual: actual,
	    expected: expected,
	    operator: operator,
	    stackStartFunction: stackStartFunction
	  });
	}

	// EXTENSION! allows for well behaved errors defined elsewhere.
	assert.fail = fail;

	// 4. Pure assertion tests whether a value is truthy, as determined
	// by !!guard.
	// assert.ok(guard, message_opt);
	// This statement is equivalent to assert.equal(true, !!guard,
	// message_opt);. To test strictly for the value true, use
	// assert.strictEqual(true, guard, message_opt);.

	function ok(value, message) {
	  if (!value) fail(value, true, message, '==', assert.ok);
	}
	assert.ok = ok;

	// 5. The equality assertion tests shallow, coercive equality with
	// ==.
	// assert.equal(actual, expected, message_opt);

	assert.equal = function equal(actual, expected, message) {
	  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
	};

	// 6. The non-equality assertion tests for whether two objects are not equal
	// with != assert.notEqual(actual, expected, message_opt);

	assert.notEqual = function notEqual(actual, expected, message) {
	  if (actual == expected) {
	    fail(actual, expected, message, '!=', assert.notEqual);
	  }
	};

	// 7. The equivalence assertion tests a deep equality relation.
	// assert.deepEqual(actual, expected, message_opt);

	assert.deepEqual = function deepEqual(actual, expected, message) {
	  if (!_deepEqual(actual, expected, false)) {
	    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
	  }
	};

	assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
	  if (!_deepEqual(actual, expected, true)) {
	    fail(actual, expected, message, 'deepStrictEqual', assert.deepStrictEqual);
	  }
	};

	function _deepEqual(actual, expected, strict, memos) {
	  // 7.1. All identical values are equivalent, as determined by ===.
	  if (actual === expected) {
	    return true;
	  } else if (isBuffer(actual) && isBuffer(expected)) {
	    return compare(actual, expected) === 0;

	  // 7.2. If the expected value is a Date object, the actual value is
	  // equivalent if it is also a Date object that refers to the same time.
	  } else if (util.isDate(actual) && util.isDate(expected)) {
	    return actual.getTime() === expected.getTime();

	  // 7.3 If the expected value is a RegExp object, the actual value is
	  // equivalent if it is also a RegExp object with the same source and
	  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
	  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
	    return actual.source === expected.source &&
	           actual.global === expected.global &&
	           actual.multiline === expected.multiline &&
	           actual.lastIndex === expected.lastIndex &&
	           actual.ignoreCase === expected.ignoreCase;

	  // 7.4. Other pairs that do not both pass typeof value == 'object',
	  // equivalence is determined by ==.
	  } else if ((actual === null || typeof actual !== 'object') &&
	             (expected === null || typeof expected !== 'object')) {
	    return strict ? actual === expected : actual == expected;

	  // If both values are instances of typed arrays, wrap their underlying
	  // ArrayBuffers in a Buffer each to increase performance
	  // This optimization requires the arrays to have the same type as checked by
	  // Object.prototype.toString (aka pToString). Never perform binary
	  // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their
	  // bit patterns are not identical.
	  } else if (isView(actual) && isView(expected) &&
	             pToString(actual) === pToString(expected) &&
	             !(actual instanceof Float32Array ||
	               actual instanceof Float64Array)) {
	    return compare(new Uint8Array(actual.buffer),
	                   new Uint8Array(expected.buffer)) === 0;

	  // 7.5 For all other Object pairs, including Array objects, equivalence is
	  // determined by having the same number of owned properties (as verified
	  // with Object.prototype.hasOwnProperty.call), the same set of keys
	  // (although not necessarily the same order), equivalent values for every
	  // corresponding key, and an identical 'prototype' property. Note: this
	  // accounts for both named and indexed properties on Arrays.
	  } else if (isBuffer(actual) !== isBuffer(expected)) {
	    return false;
	  } else {
	    memos = memos || {actual: [], expected: []};

	    var actualIndex = memos.actual.indexOf(actual);
	    if (actualIndex !== -1) {
	      if (actualIndex === memos.expected.indexOf(expected)) {
	        return true;
	      }
	    }

	    memos.actual.push(actual);
	    memos.expected.push(expected);

	    return objEquiv(actual, expected, strict, memos);
	  }
	}

	function isArguments(object) {
	  return Object.prototype.toString.call(object) == '[object Arguments]';
	}

	function objEquiv(a, b, strict, actualVisitedObjects) {
	  if (a === null || a === undefined || b === null || b === undefined)
	    return false;
	  // if one is a primitive, the other must be same
	  if (util.isPrimitive(a) || util.isPrimitive(b))
	    return a === b;
	  if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))
	    return false;
	  var aIsArgs = isArguments(a);
	  var bIsArgs = isArguments(b);
	  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))
	    return false;
	  if (aIsArgs) {
	    a = pSlice.call(a);
	    b = pSlice.call(b);
	    return _deepEqual(a, b, strict);
	  }
	  var ka = objectKeys(a);
	  var kb = objectKeys(b);
	  var key, i;
	  // having the same number of owned properties (keys incorporates
	  // hasOwnProperty)
	  if (ka.length !== kb.length)
	    return false;
	  //the same set of keys (although not necessarily the same order),
	  ka.sort();
	  kb.sort();
	  //~~~cheap key test
	  for (i = ka.length - 1; i >= 0; i--) {
	    if (ka[i] !== kb[i])
	      return false;
	  }
	  //equivalent values for every corresponding key, and
	  //~~~possibly expensive deep test
	  for (i = ka.length - 1; i >= 0; i--) {
	    key = ka[i];
	    if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects))
	      return false;
	  }
	  return true;
	}

	// 8. The non-equivalence assertion tests for any deep inequality.
	// assert.notDeepEqual(actual, expected, message_opt);

	assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
	  if (_deepEqual(actual, expected, false)) {
	    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
	  }
	};

	assert.notDeepStrictEqual = notDeepStrictEqual;
	function notDeepStrictEqual(actual, expected, message) {
	  if (_deepEqual(actual, expected, true)) {
	    fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);
	  }
	}


	// 9. The strict equality assertion tests strict equality, as determined by ===.
	// assert.strictEqual(actual, expected, message_opt);

	assert.strictEqual = function strictEqual(actual, expected, message) {
	  if (actual !== expected) {
	    fail(actual, expected, message, '===', assert.strictEqual);
	  }
	};

	// 10. The strict non-equality assertion tests for strict inequality, as
	// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

	assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
	  if (actual === expected) {
	    fail(actual, expected, message, '!==', assert.notStrictEqual);
	  }
	};

	function expectedException(actual, expected) {
	  if (!actual || !expected) {
	    return false;
	  }

	  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
	    return expected.test(actual);
	  }

	  try {
	    if (actual instanceof expected) {
	      return true;
	    }
	  } catch (e) {
	    // Ignore.  The instanceof check doesn't work for arrow functions.
	  }

	  if (Error.isPrototypeOf(expected)) {
	    return false;
	  }

	  return expected.call({}, actual) === true;
	}

	function _tryBlock(block) {
	  var error;
	  try {
	    block();
	  } catch (e) {
	    error = e;
	  }
	  return error;
	}

	function _throws(shouldThrow, block, expected, message) {
	  var actual;

	  if (typeof block !== 'function') {
	    throw new TypeError('"block" argument must be a function');
	  }

	  if (typeof expected === 'string') {
	    message = expected;
	    expected = null;
	  }

	  actual = _tryBlock(block);

	  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
	            (message ? ' ' + message : '.');

	  if (shouldThrow && !actual) {
	    fail(actual, expected, 'Missing expected exception' + message);
	  }

	  var userProvidedMessage = typeof message === 'string';
	  var isUnwantedException = !shouldThrow && util.isError(actual);
	  var isUnexpectedException = !shouldThrow && actual && !expected;

	  if ((isUnwantedException &&
	      userProvidedMessage &&
	      expectedException(actual, expected)) ||
	      isUnexpectedException) {
	    fail(actual, expected, 'Got unwanted exception' + message);
	  }

	  if ((shouldThrow && actual && expected &&
	      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
	    throw actual;
	  }
	}

	// 11. Expected to throw an error:
	// assert.throws(block, Error_opt, message_opt);

	assert.throws = function(block, /*optional*/error, /*optional*/message) {
	  _throws(true, block, error, message);
	};

	// EXTENSION! This is annoying to write outside this module.
	assert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) {
	  _throws(false, block, error, message);
	};

	assert.ifError = function(err) { if (err) throw err; };

	var objectKeys = Object.keys || function (obj) {
	  var keys = [];
	  for (var key in obj) {
	    if (hasOwn.call(obj, key)) keys.push(key);
	  }
	  return keys;
	};

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 8 */
/***/ function(module, exports) {

	module.exports = now

	function now() {
	    return new Date().getTime()
	}


/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Kinvey = undefined;

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // eslint-disable-line no-unused-vars


	var _client = __webpack_require__(10);

	var _endpoint = __webpack_require__(218);

	var _utils = __webpack_require__(13);

	var _query = __webpack_require__(422);

	var _aggregation = __webpack_require__(429);

	var _datastore = __webpack_require__(430);

	var _entity = __webpack_require__(434);

	var _social = __webpack_require__(411);

	var _request = __webpack_require__(219);

	var _errors = __webpack_require__(11);

	var _regeneratorRuntime = __webpack_require__(148);

	var _regeneratorRuntime2 = _interopRequireDefault(_regeneratorRuntime);

	var _url = __webpack_require__(206);

	var _url2 = _interopRequireDefault(_url);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { return step("next", value); }, function (err) { return step("throw", err); }); } } return step("next"); }); }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var appdataNamespace = process && process.env && process.env.KINVEY_DATASTORE_NAMESPACE || 'appdata' || 'appdata';

	/**
	 * The Kinvey class is used as the entry point for the Kinvey JavaScript SDK.
	 */

	var Kinvey = function () {
	  function Kinvey() {
	    _classCallCheck(this, Kinvey);
	  }

	  _createClass(Kinvey, null, [{
	    key: 'init',


	    /**
	     * Initializes the library with your app's information.
	     *
	     * @param {Object}    options                                            Options
	     * @param {string}    [options.apiHostname='https://baas.kinvey.com']    Host name used for Kinvey API requests
	     * @param {string}    [options.micHostname='https://auth.kinvey.com']    Host name used for Kinvey MIC requests
	     * @param {string}    [options.appKey]                                   App Key
	     * @param {string}    [options.appSecret]                                App Secret
	     * @param {string}    [options.masterSecret]                             App Master Secret
	     * @param {string}    [options.encryptionKey]                            App Encryption Key
	     * @param {string}    [options.appVersion]                               App Version
	     * @return {Client}                                                      A client instance.
	     *
	     * @throws  {KinveyError}  If an `options.appKey` is not provided.
	     * @throws  {KinveyError}  If neither an `options.appSecret` or `options.masterSecret` is provided.
	     *
	     * @example
	     * var client = Kinvey.init({
	     *   appKey: 'appKey',
	     *   appSecret: 'appSecret'
	     * });
	     */
	    value: function init(options) {
	      // Check that an appKey or appId was provided
	      if (!options.appKey) {
	        throw new _errors.KinveyError('No App Key was provided. ' + 'Unable to create a new Client without an App Key.');
	      }

	      // Check that an appSecret or masterSecret was provided
	      if (!options.appSecret && !options.masterSecret) {
	        throw new _errors.KinveyError('No App Secret or Master Secret was provided. ' + 'Unable to create a new Client without an App Key.');
	      }

	      // Initialize the client
	      var client = _client.Client.init(options);

	      // Add modules that require initialization
	      this.CustomEndpoint = _endpoint.CustomEndpoint;
	      this.DataStore = _datastore.DataStore;
	      this.Files = new _datastore.FileStore();
	      this.User = _entity.User;
	      this.UserStore = _entity.UserStore;

	      // Return the client
	      return client;
	    }

	    /**
	     * Pings the Kinvey API service.
	     *
	     * @returns {Promise<Object>} The response from the ping request.
	     *
	     * @example
	     * var promise = Kinvey.ping().then(function(response) {
	     *   console.log('Kinvey Ping Success. Kinvey Service is alive, version: ' + response.version + ', response: ' + response.kinvey);
	     * }).catch(function(error) {
	     *   console.log('Kinvey Ping Failed. Response: ' + error.description);
	     * });
	     */

	  }, {
	    key: 'ping',
	    value: function () {
	      var _ref = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee() {
	        var client = arguments.length <= 0 || arguments[0] === undefined ? _client.Client.sharedInstance() : arguments[0];
	        var request, response;
	        return _regeneratorRuntime2.default.wrap(function _callee$(_context) {
	          while (1) {
	            switch (_context.prev = _context.next) {
	              case 0:
	                request = new _request.KinveyRequest({
	                  method: _request.RequestMethod.GET,
	                  authType: _request.AuthType.All,
	                  url: _url2.default.format({
	                    protocol: client.protocol,
	                    host: client.host,
	                    pathname: appdataNamespace + '/' + client.appKey
	                  })
	                });
	                _context.next = 3;
	                return request.execute();

	              case 3:
	                response = _context.sent;
	                return _context.abrupt('return', response.data);

	              case 5:
	              case 'end':
	                return _context.stop();
	            }
	          }
	        }, _callee, this);
	      }));

	      function ping(_x) {
	        return _ref.apply(this, arguments);
	      }

	      return ping;
	    }()
	  }, {
	    key: 'client',

	    /**
	     * Returns the shared instance of the Client class used by the SDK.
	     *
	     * @throws {KinveyError} If a shared instance does not exist.
	     *
	     * @return {Client} The shared instance.
	     *
	     * @example
	     * var client = Kinvey.client;
	     */
	    get: function get() {
	      return _client.Client.sharedInstance();
	    }

	    /**
	     * The version of your app. It will sent with Kinvey API requests
	     * using the X-Kinvey-Api-Version header.
	     *
	     * @return {String} The version of your app.
	     *
	     * @example
	     * var appVersion = Kinvey.appVersion;
	     */

	  }, {
	    key: 'appVersion',
	    get: function get() {
	      return this.client.appVersion;
	    }

	    /**
	     * Set the version of your app. It will sent with Kinvey API requests
	     * using the X-Kinvey-Api-Version header.
	     *
	     * @param  {String} appVersion  App version.
	     *
	     * @example
	     * Kinvey.appVersion = '1.0.0';
	     * // or
	     * Kinvey.appVersion = 'v1';
	     */
	    ,
	    set: function set(appVersion) {
	      this.client.appVersion = appVersion;
	    }
	  }]);

	  return Kinvey;
	}();

	// Add modules


	Kinvey.Acl = _entity.Acl;
	Kinvey.Aggregation = _aggregation.Aggregation;
	Kinvey.AuthorizationGrant = _social.AuthorizationGrant;
	Kinvey.DataStoreType = _datastore.DataStoreType;
	Kinvey.Log = _utils.Log;
	Kinvey.Metadata = _entity.Metadata;
	Kinvey.Query = _query.Query;
	Kinvey.SocialIdentity = _social.SocialIdentity;

	// Export
	exports.Kinvey = Kinvey;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Client = undefined;

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _errors = __webpack_require__(11);

	var _utils = __webpack_require__(13);

	var _url = __webpack_require__(206);

	var _url2 = _interopRequireDefault(_url);

	var _assign = __webpack_require__(211);

	var _assign2 = _interopRequireDefault(_assign);

	var _isString = __webpack_require__(217);

	var _isString2 = _interopRequireDefault(_isString);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var _sharedInstance = null;

	/**
	 * The Client class stores information about your application on the Kinvey platform. You can create mutiple clients
	 * to send requests to different environments on the Kinvey platform.
	 */

	var Client = exports.Client = function () {
	  /**
	   * Creates a new instance of the Client class.
	   *
	   * @param {Object}    options                                            Options
	   * @param {string}    [options.apiHostname='https://baas.kinvey.com']    Host name used for Kinvey API requests
	   * @param {string}    [options.micHostname='https://auth.kinvey.com']    Host name used for Kinvey MIC requests
	   * @param {string}    [options.appKey]                                   App Key
	   * @param {string}    [options.appSecret]                                App Secret
	   * @param {string}    [options.masterSecret]                             App Master Secret
	   * @param {string}    [options.encryptionKey]                            App Encryption Key
	   * @param {string}    [options.appVersion]                               App Version
	   * @return {Client}                                                      An instance of the Client class.
	   *
	   * @example
	   * var client = new Kinvey.Client({
	   *   appKey: '<appKey>',
	   *   appSecret: '<appSecret>'
	   * });
	   */
	  function Client() {
	    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

	    _classCallCheck(this, Client);

	    options = (0, _assign2.default)({
	      apiHostname: 'https://baas.kinvey.com',
	      micHostname: 'https://auth.kinvey.com',
	      liveServiceHostname: 'https://kls.kinvey.com'
	    }, options);

	    if (options.apiHostname && (0, _isString2.default)(options.apiHostname)) {
	      var apiHostnameParsed = _url2.default.parse(options.apiHostname);
	      options.apiProtocol = apiHostnameParsed.protocol;
	      options.apiHost = apiHostnameParsed.host;
	    }

	    if (options.micHostname && (0, _isString2.default)(options.micHostname)) {
	      var micHostnameParsed = _url2.default.parse(options.micHostname);
	      options.micProtocol = micHostnameParsed.protocol;
	      options.micHost = micHostnameParsed.host;
	    }

	    if (options.liveServiceHostname && (0, _isString2.default)(options.liveServiceHostname)) {
	      var liveServiceHostnameParsed = _url2.default.parse(options.liveServiceHostname);
	      options.liveServiceProtocol = liveServiceHostnameParsed.protocol;
	      options.liveServiceHost = liveServiceHostnameParsed.host;
	    }

	    /**
	     * @type {string}
	     */
	    this.apiProtocol = options.apiProtocol;

	    /**
	     * @type {string}
	     */
	    this.apiHost = options.apiHost;

	    /**
	     * @type {string}
	     */
	    this.micProtocol = options.micProtocol;

	    /**
	     * @type {string}
	     */
	    this.micHost = options.micHost;

	    /**
	     * @type {string}
	     */
	    this.liveServiceProtocol = options.liveServiceProtocol;

	    /**
	     * @type {string}
	     */
	    this.liveServiceHost = options.liveServiceHost;

	    /**
	     * @type {?string}
	     */
	    this.appKey = options.appKey;

	    /**
	     * @type {?string}
	     */
	    this.appSecret = options.appSecret;

	    /**
	     * @type {?string}
	     */
	    this.masterSecret = options.masterSecret;

	    /**
	     * @type {?string}
	     */
	    this.encryptionKey = options.encryptionKey;

	    /**
	     * @type {?string}
	     */
	    this.appVersion = options.appVersion;
	  }

	  /**
	   * API host name used for Kinvey API requests.
	   */


	  _createClass(Client, [{
	    key: 'toPlainObject',


	    /**
	     * Returns an object containing all the information for this Client.
	     *
	     * @return {Object} Object
	     */
	    value: function toPlainObject() {
	      return {
	        apiHostname: this.apiHostname,
	        apiProtocol: this.apiProtocol,
	        apiHost: this.apiHost,
	        micHostname: this.micHostname,
	        micProtocol: this.micProtocol,
	        micHost: this.micHost,
	        liveServiceHostname: this.liveServiceHostname,
	        liveServiceHost: this.liveServiceHost,
	        liveServiceProtocol: this.liveServiceProtocol,
	        appKey: this.appKey,
	        appSecret: this.appSecret,
	        masterSecret: this.masterSecret,
	        encryptionKey: this.encryptionKey,
	        appVersion: this.appVersion
	      };
	    }

	    /**
	     * Initializes the Client class by creating a new instance of the
	     * Client class and storing it as a shared instance.
	     *
	     * @param {Object}    options                                            Options
	     * @param {string}    [options.apiHostname='https://baas.kinvey.com']    Host name used for Kinvey API requests
	     * @param {string}    [options.micHostname='https://auth.kinvey.com']    Host name used for Kinvey MIC requests
	     * @param {string}    [options.appKey]                                   App Key
	     * @param {string}    [options.appSecret]                                App Secret
	     * @param {string}    [options.masterSecret]                             App Master Secret
	     * @param {string}    [options.encryptionKey]                            App Encryption Key
	     * @param {string}    [options.appVersion]                               App Version
	     * @return {Client}                                                      An instance of Client.
	     *
	     * @example
	     * var client = Kinvey.Client.init({
	     *   appKey: '<appKey>',
	     *   appSecret: '<appSecret>'
	     * });
	     * Kinvey.Client.sharedInstance() === client; // true
	     */

	  }, {
	    key: 'apiHostname',
	    get: function get() {
	      return _url2.default.format({
	        protocol: this.apiProtocol,
	        host: this.apiHost
	      });
	    }

	    /**
	     * @deprecated Use apiHostname instead of this.
	     */

	  }, {
	    key: 'baseUrl',
	    get: function get() {
	      return this.apiHostname;
	    }

	    /**
	     * @deprecated Use apiProtocol instead of this.
	     */

	  }, {
	    key: 'protocol',
	    get: function get() {
	      return this.apiProtocol;
	    }

	    /**
	     * @deprecated Use apiHost instead of this.
	     */

	  }, {
	    key: 'host',
	    get: function get() {
	      return this.apiHost;
	    }

	    /**
	     * Mobile Identity Connect host name used for MIC requests.
	     */

	  }, {
	    key: 'micHostname',
	    get: function get() {
	      return _url2.default.format({
	        protocol: this.micProtocol,
	        host: this.micHost
	      });
	    }

	    /**
	     * Live Service host name used for streaming data.
	     */

	  }, {
	    key: 'liveServiceHostname',
	    get: function get() {
	      return _url2.default.format({
	        protocol: this.liveServiceProtocol,
	        host: this.liveServiceHost
	      });
	    }

	    /**
	     * Active user for your app.
	     */

	  }, {
	    key: 'activeUser',
	    get: function get() {
	      return (0, _utils.getActiveUser)(this);
	    }

	    /**
	     * The version of your app. It will sent with Kinvey API requests
	     * using the X-Kinvey-Api-Version header.
	     */

	  }, {
	    key: 'appVersion',
	    get: function get() {
	      return this._appVersion;
	    }

	    /**
	     * Set the version of your app. It will sent with Kinvey API requests
	     * using the X-Kinvey-Api-Version header.
	     *
	     * @param  {String} appVersion  App version.
	     */
	    ,
	    set: function set(appVersion) {
	      if (appVersion && !(0, _isString2.default)(appVersion)) {
	        appVersion = String(appVersion);
	      }

	      this._appVersion = appVersion;
	    }
	  }], [{
	    key: 'init',
	    value: function init(options) {
	      var client = new Client(options);
	      _sharedInstance = client;
	      return client;
	    }

	    /**
	     * Returns the shared instance of the Client class used by the SDK.
	     *
	     * @throws {KinveyError} If a shared instance does not exist.
	     *
	     * @return {Client} The shared instance.
	     *
	     * @example
	     * var client = Kinvey.Client.sharedInstance();
	     */

	  }, {
	    key: 'sharedInstance',
	    value: function sharedInstance() {
	      if (!_sharedInstance) {
	        throw new _errors.KinveyError('You have not initialized the library. ' + 'Please call Kinvey.init() to initialize the library.');
	      }

	      return _sharedInstance;
	    }
	  }]);

	  return Client;
	}();

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.SyncError = exports.ServerError = exports.QueryError = exports.ParameterValueOutOfRangeError = exports.NoResponseError = exports.NotFoundError = exports.NoActiveUserError = exports.NoNetworkConnectionError = exports.MissingRequestParameterError = exports.MissingRequestHeaderError = exports.MissingQueryError = exports.JSONParseError = exports.InvalidQuerySyntaxError = exports.InvalidIdentifierError = exports.InvalidCredentialsError = exports.InsufficientCredentialsError = exports.IncompleteRequestBodyError = exports.FeatureUnavailableError = exports.ActiveUserError = exports.KinveyError = undefined;

	var _es6Error = __webpack_require__(12);

	var _es6Error2 = _interopRequireDefault(_es6Error);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * @private
	 */
	var KinveyError = exports.KinveyError = function (_ExtendableError) {
	  _inherits(KinveyError, _ExtendableError);

	  function KinveyError() {
	    var message = arguments.length <= 0 || arguments[0] === undefined ? 'An error has occurred.' : arguments[0];
	    var debug = arguments.length <= 1 || arguments[1] === undefined ? '' : arguments[1];
	    var code = arguments.length <= 2 || arguments[2] === undefined ? -1 : arguments[2];

	    _classCallCheck(this, KinveyError);

	    var _this = _possibleConstructorReturn(this, (KinveyError.__proto__ || Object.getPrototypeOf(KinveyError)).call(this, message));

	    _this.debug = debug;
	    _this.code = code;
	    return _this;
	  }

	  return KinveyError;
	}(_es6Error2.default);

	/**
	 * @private
	 */


	var ActiveUserError = exports.ActiveUserError = function (_KinveyError) {
	  _inherits(ActiveUserError, _KinveyError);

	  function ActiveUserError() {
	    var message = arguments.length <= 0 || arguments[0] === undefined ? 'An active user already exists.' : arguments[0];
	    var debug = arguments[1];

	    _classCallCheck(this, ActiveUserError);

	    return _possibleConstructorReturn(this, (ActiveUserError.__proto__ || Object.getPrototypeOf(ActiveUserError)).call(this, message, debug));
	  }

	  return ActiveUserError;
	}(KinveyError);

	/**
	 * @private
	 */


	var FeatureUnavailableError = exports.FeatureUnavailableError = function (_KinveyError2) {
	  _inherits(FeatureUnavailableError, _KinveyError2);

	  function FeatureUnavailableError() {
	    var message = arguments.length <= 0 || arguments[0] === undefined ? 'Requested functionality is unavailable in this API version.' : arguments[0];
	    var debug = arguments[1];

	    _classCallCheck(this, FeatureUnavailableError);

	    return _possibleConstructorReturn(this, (FeatureUnavailableError.__proto__ || Object.getPrototypeOf(FeatureUnavailableError)).call(this, message, debug));
	  }

	  return FeatureUnavailableError;
	}(KinveyError);

	/**
	 * @private
	 */


	var IncompleteRequestBodyError = exports.IncompleteRequestBodyError = function (_KinveyError3) {
	  _inherits(IncompleteRequestBodyError, _KinveyError3);

	  function IncompleteRequestBodyError() {
	    var message = arguments.length <= 0 || arguments[0] === undefined ? ' The request body is either missing or incomplete.' : arguments[0];
	    var debug = arguments[1];

	    _classCallCheck(this, IncompleteRequestBodyError);

	    return _possibleConstructorReturn(this, (IncompleteRequestBodyError.__proto__ || Object.getPrototypeOf(IncompleteRequestBodyError)).call(this, message, debug));
	  }

	  return IncompleteRequestBodyError;
	}(KinveyError);

	/**
	 * @private
	 */


	var InsufficientCredentialsError = exports.InsufficientCredentialsError = function (_KinveyError4) {
	  _inherits(InsufficientCredentialsError, _KinveyError4);

	  function InsufficientCredentialsError() {
	    var message = arguments.length <= 0 || arguments[0] === undefined ? 'The credentials used to authenticate this request are not authorized to run ' + 'this operation. Please retry your request with appropriate credentials.' : arguments[0];
	    var debug = arguments[1];

	    _classCallCheck(this, InsufficientCredentialsError);

	    return _possibleConstructorReturn(this, (InsufficientCredentialsError.__proto__ || Object.getPrototypeOf(InsufficientCredentialsError)).call(this, message, debug));
	  }

	  return InsufficientCredentialsError;
	}(KinveyError);

	/**
	 * @private
	 */


	var InvalidCredentialsError = exports.InvalidCredentialsError = function (_KinveyError5) {
	  _inherits(InvalidCredentialsError, _KinveyError5);

	  function InvalidCredentialsError() {
	    var message = arguments.length <= 0 || arguments[0] === undefined ? ' Invalid credentials. Please retry your request with correct credentials.' : arguments[0];
	    var debug = arguments[1];

	    _classCallCheck(this, InvalidCredentialsError);

	    return _possibleConstructorReturn(this, (InvalidCredentialsError.__proto__ || Object.getPrototypeOf(InvalidCredentialsError)).call(this, message, debug));
	  }

	  return InvalidCredentialsError;
	}(KinveyError);

	/**
	 * @private
	 */


	var InvalidIdentifierError = exports.InvalidIdentifierError = function (_KinveyError6) {
	  _inherits(InvalidIdentifierError, _KinveyError6);

	  function InvalidIdentifierError() {
	    var message = arguments.length <= 0 || arguments[0] === undefined ? 'One of more identifier names in the request has an invalid format.' : arguments[0];
	    var debug = arguments[1];

	    _classCallCheck(this, InvalidIdentifierError);

	    return _possibleConstructorReturn(this, (InvalidIdentifierError.__proto__ || Object.getPrototypeOf(InvalidIdentifierError)).call(this, message, debug));
	  }

	  return InvalidIdentifierError;
	}(KinveyError);

	/**
	 * @private
	 */


	var InvalidQuerySyntaxError = exports.InvalidQuerySyntaxError = function (_KinveyError7) {
	  _inherits(InvalidQuerySyntaxError, _KinveyError7);

	  function InvalidQuerySyntaxError() {
	    var message = arguments.length <= 0 || arguments[0] === undefined ? 'The query string in the request has an invalid syntax.' : arguments[0];
	    var debug = arguments[1];

	    _classCallCheck(this, InvalidQuerySyntaxError);

	    return _possibleConstructorReturn(this, (InvalidQuerySyntaxError.__proto__ || Object.getPrototypeOf(InvalidQuerySyntaxError)).call(this, message, debug));
	  }

	  return InvalidQuerySyntaxError;
	}(KinveyError);

	/**
	 * @private
	 */


	var JSONParseError = exports.JSONParseError = function (_KinveyError8) {
	  _inherits(JSONParseError, _KinveyError8);

	  function JSONParseError() {
	    var message = arguments.length <= 0 || arguments[0] === undefined ? 'Unable to parse the JSON in the request.' : arguments[0];
	    var debug = arguments[1];

	    _classCallCheck(this, JSONParseError);

	    return _possibleConstructorReturn(this, (JSONParseError.__proto__ || Object.getPrototypeOf(JSONParseError)).call(this, message, debug));
	  }

	  return JSONParseError;
	}(KinveyError);

	/**
	 * @private
	 */


	var MissingQueryError = exports.MissingQueryError = function (_KinveyError9) {
	  _inherits(MissingQueryError, _KinveyError9);

	  function MissingQueryError() {
	    var message = arguments.length <= 0 || arguments[0] === undefined ? 'The request is missing a query string.' : arguments[0];
	    var debug = arguments[1];

	    _classCallCheck(this, MissingQueryError);

	    return _possibleConstructorReturn(this, (MissingQueryError.__proto__ || Object.getPrototypeOf(MissingQueryError)).call(this, message, debug));
	  }

	  return MissingQueryError;
	}(KinveyError);

	/**
	 * @private
	 */


	var MissingRequestHeaderError = exports.MissingRequestHeaderError = function (_KinveyError10) {
	  _inherits(MissingRequestHeaderError, _KinveyError10);

	  function MissingRequestHeaderError() {
	    var message = arguments.length <= 0 || arguments[0] === undefined ? 'The request is missing a required header.' : arguments[0];
	    var debug = arguments[1];

	    _classCallCheck(this, MissingRequestHeaderError);

	    return _possibleConstructorReturn(this, (MissingRequestHeaderError.__proto__ || Object.getPrototypeOf(MissingRequestHeaderError)).call(this, message, debug));
	  }

	  return MissingRequestHeaderError;
	}(KinveyError);

	/**
	 * @private
	 */


	var MissingRequestParameterError = exports.MissingRequestParameterError = function (_KinveyError11) {
	  _inherits(MissingRequestParameterError, _KinveyError11);

	  function MissingRequestParameterError() {
	    var message = arguments.length <= 0 || arguments[0] === undefined ? 'A required parameter is missing from the request.' : arguments[0];
	    var debug = arguments[1];

	    _classCallCheck(this, MissingRequestParameterError);

	    return _possibleConstructorReturn(this, (MissingRequestParameterError.__proto__ || Object.getPrototypeOf(MissingRequestParameterError)).call(this, message, debug));
	  }

	  return MissingRequestParameterError;
	}(KinveyError);

	/**
	 * @private
	 */


	var NoNetworkConnectionError = exports.NoNetworkConnectionError = function (_KinveyError12) {
	  _inherits(NoNetworkConnectionError, _KinveyError12);

	  function NoNetworkConnectionError() {
	    var message = arguments.length <= 0 || arguments[0] === undefined ? 'You do not have a network connect.' : arguments[0];
	    var debug = arguments[1];

	    _classCallCheck(this, NoNetworkConnectionError);

	    return _possibleConstructorReturn(this, (NoNetworkConnectionError.__proto__ || Object.getPrototypeOf(NoNetworkConnectionError)).call(this, message, debug));
	  }

	  return NoNetworkConnectionError;
	}(KinveyError);

	/**
	 * @private
	 */


	var NoActiveUserError = exports.NoActiveUserError = function (_KinveyError13) {
	  _inherits(NoActiveUserError, _KinveyError13);

	  function NoActiveUserError() {
	    var message = arguments.length <= 0 || arguments[0] === undefined ? 'There is not an active user.' : arguments[0];
	    var debug = arguments[1];

	    _classCallCheck(this, NoActiveUserError);

	    return _possibleConstructorReturn(this, (NoActiveUserError.__proto__ || Object.getPrototypeOf(NoActiveUserError)).call(this, message, debug));
	  }

	  return NoActiveUserError;
	}(KinveyError);

	/**
	 * @private
	 */


	var NotFoundError = exports.NotFoundError = function (_KinveyError14) {
	  _inherits(NotFoundError, _KinveyError14);

	  function NotFoundError() {
	    var message = arguments.length <= 0 || arguments[0] === undefined ? 'The item was not found.' : arguments[0];
	    var debug = arguments[1];

	    _classCallCheck(this, NotFoundError);

	    return _possibleConstructorReturn(this, (NotFoundError.__proto__ || Object.getPrototypeOf(NotFoundError)).call(this, message, debug));
	  }

	  return NotFoundError;
	}(KinveyError);

	/**
	 * @private
	 */


	var NoResponseError = exports.NoResponseError = function (_KinveyError15) {
	  _inherits(NoResponseError, _KinveyError15);

	  function NoResponseError() {
	    var message = arguments.length <= 0 || arguments[0] === undefined ? 'No response was provided.' : arguments[0];
	    var debug = arguments[1];

	    _classCallCheck(this, NoResponseError);

	    return _possibleConstructorReturn(this, (NoResponseError.__proto__ || Object.getPrototypeOf(NoResponseError)).call(this, message, debug));
	  }

	  return NoResponseError;
	}(KinveyError);

	/**
	 * @private
	 */


	var ParameterValueOutOfRangeError = exports.ParameterValueOutOfRangeError = function (_KinveyError16) {
	  _inherits(ParameterValueOutOfRangeError, _KinveyError16);

	  function ParameterValueOutOfRangeError() {
	    var message = arguments.length <= 0 || arguments[0] === undefined ? 'The value specified for one of the request parameters is out of range.' : arguments[0];
	    var debug = arguments[1];

	    _classCallCheck(this, ParameterValueOutOfRangeError);

	    return _possibleConstructorReturn(this, (ParameterValueOutOfRangeError.__proto__ || Object.getPrototypeOf(ParameterValueOutOfRangeError)).call(this, message, debug));
	  }

	  return ParameterValueOutOfRangeError;
	}(KinveyError);

	/**
	 * @private
	 */


	var QueryError = exports.QueryError = function (_KinveyError17) {
	  _inherits(QueryError, _KinveyError17);

	  function QueryError() {
	    var message = arguments.length <= 0 || arguments[0] === undefined ? 'An error occurred on the query.' : arguments[0];
	    var debug = arguments[1];

	    _classCallCheck(this, QueryError);

	    return _possibleConstructorReturn(this, (QueryError.__proto__ || Object.getPrototypeOf(QueryError)).call(this, message, debug));
	  }

	  return QueryError;
	}(KinveyError);

	/**
	 * @private
	 */


	var ServerError = exports.ServerError = function (_KinveyError18) {
	  _inherits(ServerError, _KinveyError18);

	  function ServerError() {
	    var message = arguments.length <= 0 || arguments[0] === undefined ? 'An error occurred on the server' : arguments[0];
	    var debug = arguments[1];

	    _classCallCheck(this, ServerError);

	    return _possibleConstructorReturn(this, (ServerError.__proto__ || Object.getPrototypeOf(ServerError)).call(this, message, debug));
	  }

	  return ServerError;
	}(KinveyError);

	/**
	 * @private
	 */


	var SyncError = exports.SyncError = function (_KinveyError19) {
	  _inherits(SyncError, _KinveyError19);

	  function SyncError() {
	    var message = arguments.length <= 0 || arguments[0] === undefined ? 'An error occurred during sync' : arguments[0];
	    var debug = arguments[1];

	    _classCallCheck(this, SyncError);

	    return _possibleConstructorReturn(this, (SyncError.__proto__ || Object.getPrototypeOf(SyncError)).call(this, message, debug));
	  }

	  return SyncError;
	}(KinveyError);

/***/ },
/* 12 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _extendableBuiltin(cls) {
	  function ExtendableBuiltin() {
	    cls.apply(this, arguments);
	  }

	  ExtendableBuiltin.prototype = Object.create(cls.prototype, {
	    constructor: {
	      value: cls,
	      enumerable: false,
	      writable: true,
	      configurable: true
	    }
	  });

	  if (Object.setPrototypeOf) {
	    Object.setPrototypeOf(ExtendableBuiltin, cls);
	  } else {
	    ExtendableBuiltin.__proto__ = cls;
	  }

	  return ExtendableBuiltin;
	}

	var ExtendableError = function (_extendableBuiltin2) {
	  _inherits(ExtendableError, _extendableBuiltin2);

	  function ExtendableError() {
	    var message = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];

	    _classCallCheck(this, ExtendableError);

	    // extending Error is weird and does not propagate `message`

	    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(ExtendableError).call(this, message));

	    Object.defineProperty(_this, 'message', {
	      configurable: true,
	      enumerable: false,
	      value: message,
	      writable: true
	    });

	    Object.defineProperty(_this, 'name', {
	      configurable: true,
	      enumerable: false,
	      value: _this.constructor.name,
	      writable: true
	    });

	    if (Error.hasOwnProperty('captureStackTrace')) {
	      Error.captureStackTrace(_this, _this.constructor);
	      return _possibleConstructorReturn(_this);
	    }

	    Object.defineProperty(_this, 'stack', {
	      configurable: true,
	      enumerable: false,
	      value: new Error(message).stack,
	      writable: true
	    });
	    return _this;
	  }

	  return ExtendableError;
	}(_extendableBuiltin(Error));

	exports.default = ExtendableError;
	module.exports = exports['default'];

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _device = __webpack_require__(14);

	Object.keys(_device).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function get() {
	      return _device[key];
	    }
	  });
	});

	var _log = __webpack_require__(16);

	Object.keys(_log).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function get() {
	      return _log[key];
	    }
	  });
	});

	var _object = __webpack_require__(18);

	Object.keys(_object).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function get() {
	      return _object[key];
	    }
	  });
	});

	var _observable = __webpack_require__(130);

	Object.keys(_observable).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function get() {
	      return _observable[key];
	    }
	  });
	});

	var _popup = __webpack_require__(146);

	Object.defineProperty(exports, 'Popup', {
	  enumerable: true,
	  get: function get() {
	    return _popup.Popup;
	  }
	});

	var _storage = __webpack_require__(200);

	Object.keys(_storage).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function get() {
	      return _storage[key];
	    }
	  });
	});

	var _string = __webpack_require__(204);

	Object.keys(_string).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function get() {
	      return _string[key];
	    }
	  });
	});

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process) {'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Device = undefined;

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _package = __webpack_require__(15);

	var _package2 = _interopRequireDefault(_package);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var deviceReady = void 0;

	// Helper function to detect the browser name and version.
	function browserDetect(ua) {
	  // Cast arguments.
	  ua = ua.toLowerCase();

	  // User-Agent patterns.
	  var rChrome = /(chrome)\/([\w]+)/;
	  var rFirefox = /(firefox)\/([\w.]+)/;
	  var rIE = /(msie) ([\w.]+)/i;
	  var rOpera = /(opera)(?:.*version)?[ \/]([\w.]+)/;
	  var rSafari = /(safari)\/([\w.]+)/;

	  return rChrome.exec(ua) || rFirefox.exec(ua) || rIE.exec(ua) || rOpera.exec(ua) || rSafari.exec(ua) || [];
	}

	function deviceInformation() {
	  var browser = void 0;
	  var platform = void 0;
	  var version = void 0;
	  var manufacturer = void 0;
	  var id = void 0;
	  var libraries = [];

	  // Platforms.
	  if (global.cordova !== undefined && global.device !== undefined) {
	    // PhoneGap
	    var device = global.device;
	    libraries.push('phonegap/' + device.cordova);
	    platform = device.platform;
	    version = device.version;
	    manufacturer = device.model;
	    id = device.uuid;
	  } else if (global.Titanium !== undefined) {
	    // Titanium.
	    libraries.push('titanium/' + global.Titanium.getVersion());

	    // If mobileweb, extract browser information.
	    if (global.Titanium.Platform.getName() === 'mobileweb') {
	      browser = browserDetect(global.Titanium.Platform.getModel());
	      platform = browser[1];
	      version = browser[2];
	      manufacturer = global.Titanium.Platform.getOstype();
	    } else {
	      platform = global.Titanium.Platform.getOsname();
	      version = global.Titanium.Platform.getVersion();
	      manufacturer = global.Titanium.Platform.getManufacturer();
	    }

	    id = global.Titanium.Platform.getId();
	  } else if (global.forge !== undefined) {
	    // Trigger.io
	    libraries.push('triggerio/' + (global.forge.config.platform_version || ''));
	    id = global.forge.config.uuid;
	  } else if (process !== undefined) {
	    // Node.js
	    platform = process.title;
	    version = process.version;
	    manufacturer = process.platform;
	  }

	  // Libraries.
	  if (global.angular !== undefined) {
	    // AngularJS.
	    libraries.push('angularjs/' + global.angular.version.full);
	  }
	  if (global.Backbone !== undefined) {
	    // Backbone.js.
	    libraries.push('backbonejs/' + global.Backbone.VERSION);
	  }
	  if (global.Ember !== undefined) {
	    // Ember.js.
	    libraries.push('emberjs/' + global.Ember.VERSION);
	  }
	  if (global.jQuery !== undefined) {
	    // jQuery.
	    libraries.push('jquery/' + global.jQuery.fn.jquery);
	  }
	  if (global.ko !== undefined) {
	    // Knockout.
	    libraries.push('knockout/' + global.ko.version);
	  }
	  if (global.Zepto !== undefined) {
	    // Zepto.js.
	    libraries.push('zeptojs');
	  }

	  // Default platform, most likely this is just a plain web app.
	  if ((platform === null || platform === undefined) && global.navigator) {
	    browser = browserDetect(global.navigator.userAgent);
	    platform = browser[1];
	    version = browser[2];
	    manufacturer = global.navigator.platform;
	  }

	  // Return the device information string.
	  var parts = ['js-' + _package2.default.name + '/' + _package2.default.version];

	  if (libraries.length !== 0) {
	    // Add external library information.
	    parts.push('(' + libraries.sort().join(', ') + ')');
	  }

	  return parts.concat([platform, version, manufacturer, id]).map(function (part) {
	    if (part) {
	      return part.toString().replace(/\s/g, '_').toLowerCase();
	    }

	    return 'unknown';
	  }).join(' ');
	}

	var Device = exports.Device = function () {
	  function Device() {
	    _classCallCheck(this, Device);
	  }

	  _createClass(Device, null, [{
	    key: 'isPhoneGap',
	    value: function isPhoneGap() {
	      if (typeof document !== 'undefined') {
	        return document.URL.indexOf('http://') === -1 && document.URL.indexOf('https://') === -1;
	      }

	      return false;
	    }
	  }, {
	    key: 'ready',
	    value: function ready() {
	      if (!deviceReady) {
	        if (this.isPhoneGap()) {
	          deviceReady = new Promise(function (resolve) {
	            var onDeviceReady = function onDeviceReady() {
	              document.removeEventListener('deviceready', onDeviceReady);
	              resolve();
	            };

	            document.addEventListener('deviceready', onDeviceReady, false);
	          });
	        } else {
	          deviceReady = Promise.resolve();
	        }
	      }

	      return deviceReady;
	    }
	  }, {
	    key: 'toString',
	    value: function toString() {
	      return deviceInformation();
	    }
	  }]);

	  return Device;
	}();
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(4)))

/***/ },
/* 15 */
/***/ function(module, exports) {

	module.exports = {
		"name": "kinvey-javascript-sdk-core",
		"version": "3.1.2",
		"description": "Kinvey JavaScript SDK Core",
		"main": "./dist/export.js",
		"scripts": {
			"build": "npm run clean && babel src --out-dir dist",
			"clean": "del dist coverage",
			"cover": "istanbul cover _mocha -- --compilers js:babel-core/register -r babel-polyfill -s 100 --recursive test/unit/setup test/unit",
			"docs": "esdoc -c esdoc.json",
			"lint": "npm run lint:src",
			"lint:src": "eslint src/**",
			"lint:test": "eslint test/unit/**",
			"test": "mocha --compilers js:babel-core/register -r babel-polyfill -s 100 --recursive test/unit/setup test/unit",
			"test:watch": "mocha -w --compilers js:babel-core/register -r babel-polyfill -s 100 --recursive test/unit/setup test/unit",
			"preversion": "npm test",
			"version": "npm run build && git add -A dist",
			"postversion": "git push && git push --tags"
		},
		"repository": {
			"type": "git",
			"url": "https://github.com/Kinvey/javascript-sdk-core.git"
		},
		"author": "Kinvey, Inc.",
		"license": "Apache-2.0",
		"bugs": {
			"url": "https://github.com/Kinvey/javascript-sdk-core/issues"
		},
		"dependencies": {
			"append-query": "^1.1.0",
			"babel-cli": "^6.14.0",
			"babel-core": "^6.14.0",
			"babel-eslint": "^6.1.0",
			"babel-loader": "^6.2.5",
			"babel-plugin-inline-dotenv": "^1.1.1",
			"babel-polyfill": "^6.9.1",
			"babel-preset-es2015": "^6.14.0",
			"babel-preset-stage-2": "^6.5.0",
			"core-js": "^2.4.1",
			"del-cli": "^0.2.0",
			"es6-error": "^3.0.0",
			"esdoc": "^0.4.7",
			"esdoc-es7-plugin": "0.0.3",
			"eslint": "^3.5.0",
			"eslint-config-airbnb-base": "^7.1.0",
			"eslint-plugin-import": "^1.15.0",
			"expect": "^1.20.2",
			"hellojs": "^1.13.1",
			"istanbul": "^1.0.0-alpha.2",
			"json-loader": "^0.5.4",
			"kinvey-javascript-rack": "../../Rack",
			"local-storage": "^1.4.2",
			"lodash": "^4.16.0",
			"loglevel": "^1.4.1",
			"mocha": "^3.0.0",
			"nock": "^8.0.0",
			"qs": "^6.2.0",
			"regenerator-runtime": "^0.9.5",
			"rxjs": "^5.0.0-beta.7",
			"sift": "^3.0.0",
			"uid": "0.0.2",
			"url-pattern": "^1.0.0",
			"webpack": "^1.13.2"
		}
	};

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Log = undefined;

	var _loglevel = __webpack_require__(17);

	var _loglevel2 = _interopRequireDefault(_loglevel);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var originalFactory = _loglevel2.default.methodFactory;

	/**
	 * @private
	 */
	_loglevel2.default.methodFactory = function methodFactory(methodName, logLevel, loggerName) {
	  var rawMethod = originalFactory(methodName, logLevel, loggerName);

	  return function log(message) {
	    message = 'Kinvey: ' + message;

	    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	      args[_key - 1] = arguments[_key];
	    }

	    if (args.length > 0) {
	      rawMethod(message, args);
	    } else {
	      rawMethod(message);
	    }
	  };
	};

	/**
	 * @private
	 */
	_loglevel2.default.setDefaultLevel(_loglevel2.default.levels.SILENT);

	/**
	 * @private
	 */
	exports.Log = _loglevel2.default;

/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(console) {/*
	* loglevel - https://github.com/pimterry/loglevel
	*
	* Copyright (c) 2013 Tim Perry
	* Licensed under the MIT license.
	*/
	(function (root, definition) {
	    "use strict";
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_FACTORY__ = (definition), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else if (typeof module === 'object' && module.exports) {
	        module.exports = definition();
	    } else {
	        root.log = definition();
	    }
	}(this, function () {
	    "use strict";
	    var noop = function() {};
	    var undefinedType = "undefined";

	    function realMethod(methodName) {
	        if (typeof console === undefinedType) {
	            return false; // We can't build a real method without a console to log to
	        } else if (console[methodName] !== undefined) {
	            return bindMethod(console, methodName);
	        } else if (console.log !== undefined) {
	            return bindMethod(console, 'log');
	        } else {
	            return noop;
	        }
	    }

	    function bindMethod(obj, methodName) {
	        var method = obj[methodName];
	        if (typeof method.bind === 'function') {
	            return method.bind(obj);
	        } else {
	            try {
	                return Function.prototype.bind.call(method, obj);
	            } catch (e) {
	                // Missing bind shim or IE8 + Modernizr, fallback to wrapping
	                return function() {
	                    return Function.prototype.apply.apply(method, [obj, arguments]);
	                };
	            }
	        }
	    }

	    // these private functions always need `this` to be set properly

	    function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {
	        return function () {
	            if (typeof console !== undefinedType) {
	                replaceLoggingMethods.call(this, level, loggerName);
	                this[methodName].apply(this, arguments);
	            }
	        };
	    }

	    function replaceLoggingMethods(level, loggerName) {
	        /*jshint validthis:true */
	        for (var i = 0; i < logMethods.length; i++) {
	            var methodName = logMethods[i];
	            this[methodName] = (i < level) ?
	                noop :
	                this.methodFactory(methodName, level, loggerName);
	        }
	    }

	    function defaultMethodFactory(methodName, level, loggerName) {
	        /*jshint validthis:true */
	        return realMethod(methodName) ||
	               enableLoggingWhenConsoleArrives.apply(this, arguments);
	    }

	    var logMethods = [
	        "trace",
	        "debug",
	        "info",
	        "warn",
	        "error"
	    ];

	    function Logger(name, defaultLevel, factory) {
	      var self = this;
	      var currentLevel;
	      var storageKey = "loglevel";
	      if (name) {
	        storageKey += ":" + name;
	      }

	      function persistLevelIfPossible(levelNum) {
	          var levelName = (logMethods[levelNum] || 'silent').toUpperCase();

	          // Use localStorage if available
	          try {
	              window.localStorage[storageKey] = levelName;
	              return;
	          } catch (ignore) {}

	          // Use session cookie as fallback
	          try {
	              window.document.cookie =
	                encodeURIComponent(storageKey) + "=" + levelName + ";";
	          } catch (ignore) {}
	      }

	      function getPersistedLevel() {
	          var storedLevel;

	          try {
	              storedLevel = window.localStorage[storageKey];
	          } catch (ignore) {}

	          if (typeof storedLevel === undefinedType) {
	              try {
	                  var cookie = window.document.cookie;
	                  var location = cookie.indexOf(
	                      encodeURIComponent(storageKey) + "=");
	                  if (location) {
	                      storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];
	                  }
	              } catch (ignore) {}
	          }

	          // If the stored level is not valid, treat it as if nothing was stored.
	          if (self.levels[storedLevel] === undefined) {
	              storedLevel = undefined;
	          }

	          return storedLevel;
	      }

	      /*
	       *
	       * Public API
	       *
	       */

	      self.levels = { "TRACE": 0, "DEBUG": 1, "INFO": 2, "WARN": 3,
	          "ERROR": 4, "SILENT": 5};

	      self.methodFactory = factory || defaultMethodFactory;

	      self.getLevel = function () {
	          return currentLevel;
	      };

	      self.setLevel = function (level, persist) {
	          if (typeof level === "string" && self.levels[level.toUpperCase()] !== undefined) {
	              level = self.levels[level.toUpperCase()];
	          }
	          if (typeof level === "number" && level >= 0 && level <= self.levels.SILENT) {
	              currentLevel = level;
	              if (persist !== false) {  // defaults to true
	                  persistLevelIfPossible(level);
	              }
	              replaceLoggingMethods.call(self, level, name);
	              if (typeof console === undefinedType && level < self.levels.SILENT) {
	                  return "No console available for logging";
	              }
	          } else {
	              throw "log.setLevel() called with invalid level: " + level;
	          }
	      };

	      self.setDefaultLevel = function (level) {
	          if (!getPersistedLevel()) {
	              self.setLevel(level, false);
	          }
	      };

	      self.enableAll = function(persist) {
	          self.setLevel(self.levels.TRACE, persist);
	      };

	      self.disableAll = function(persist) {
	          self.setLevel(self.levels.SILENT, persist);
	      };

	      // Initialize with the right level
	      var initialLevel = getPersistedLevel();
	      if (initialLevel == null) {
	          initialLevel = defaultLevel == null ? "WARN" : defaultLevel;
	      }
	      self.setLevel(initialLevel, false);
	    }

	    /*
	     *
	     * Package-level API
	     *
	     */

	    var defaultLogger = new Logger();

	    var _loggersByName = {};
	    defaultLogger.getLogger = function getLogger(name) {
	        if (typeof name !== "string" || name === "") {
	          throw new TypeError("You must supply a name when creating a logger.");
	        }

	        var logger = _loggersByName[name];
	        if (!logger) {
	          logger = _loggersByName[name] = new Logger(
	            name, defaultLogger.getLevel(), defaultLogger.methodFactory);
	        }
	        return logger;
	    };

	    // Grab the current global log variable in case of overwrite
	    var _log = (typeof window !== undefinedType) ? window.log : undefined;
	    defaultLogger.noConflict = function() {
	        if (typeof window !== undefinedType &&
	               window.log === defaultLogger) {
	            window.log = _log;
	        }

	        return defaultLogger;
	    };

	    return defaultLogger;
	}));

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.nested = nested;
	exports.isDefined = isDefined;
	exports.use = use;

	var _forEach = __webpack_require__(19);

	var _forEach2 = _interopRequireDefault(_forEach);

	var _isFunction = __webpack_require__(31);

	var _isFunction2 = _interopRequireDefault(_isFunction);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * @private
	 */
	function nested(obj, dotProperty, value) {
	  if (!dotProperty) {
	    obj = value || obj;
	    return obj;
	  }

	  var parts = dotProperty.split('.');
	  var current = parts.shift();
	  while (current && obj) {
	    obj = obj[current];
	    current = parts.shift();
	  }

	  return value || obj;
	}

	/**
	 * @private
	 */
	function isDefined(obj) {
	  return obj !== undefined && obj !== null;
	}

	/**
	 * @private
	 */
	function use(nsInterface) {
	  return function () {
	    var _this = this;

	    var adapter = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

	    (0, _forEach2.default)(nsInterface, function (methodName) {
	      if ((0, _isFunction2.default)(adapter[methodName])) {
	        _this.prototype[methodName] = function () {
	          for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	            args[_key] = arguments[_key];
	          }

	          return adapter[methodName].apply(this, args);
	        };
	      }
	    });
	  };
	}

/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	var arrayEach = __webpack_require__(20),
	    baseEach = __webpack_require__(21),
	    baseIteratee = __webpack_require__(42),
	    isArray = __webpack_require__(35);

	/**
	 * Iterates over elements of `collection` and invokes `iteratee` for each element.
	 * The iteratee is invoked with three arguments: (value, index|key, collection).
	 * Iteratee functions may exit iteration early by explicitly returning `false`.
	 *
	 * **Note:** As with other "Collections" methods, objects with a "length"
	 * property are iterated like arrays. To avoid this behavior use `_.forIn`
	 * or `_.forOwn` for object iteration.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @alias each
	 * @category Collection
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	 * @returns {Array|Object} Returns `collection`.
	 * @see _.forEachRight
	 * @example
	 *
	 * _.forEach([1, 2], function(value) {
	 *   console.log(value);
	 * });
	 * // => Logs `1` then `2`.
	 *
	 * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
	 *   console.log(key);
	 * });
	 * // => Logs 'a' then 'b' (iteration order is not guaranteed).
	 */
	function forEach(collection, iteratee) {
	  var func = isArray(collection) ? arrayEach : baseEach;
	  return func(collection, baseIteratee(iteratee, 3));
	}

	module.exports = forEach;


/***/ },
/* 20 */
/***/ function(module, exports) {

	/**
	 * A specialized version of `_.forEach` for arrays without support for
	 * iteratee shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns `array`.
	 */
	function arrayEach(array, iteratee) {
	  var index = -1,
	      length = array ? array.length : 0;

	  while (++index < length) {
	    if (iteratee(array[index], index, array) === false) {
	      break;
	    }
	  }
	  return array;
	}

	module.exports = arrayEach;


/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	var baseForOwn = __webpack_require__(22),
	    createBaseEach = __webpack_require__(41);

	/**
	 * The base implementation of `_.forEach` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array|Object} Returns `collection`.
	 */
	var baseEach = createBaseEach(baseForOwn);

	module.exports = baseEach;


/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	var baseFor = __webpack_require__(23),
	    keys = __webpack_require__(25);

	/**
	 * The base implementation of `_.forOwn` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Object} object The object to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Object} Returns `object`.
	 */
	function baseForOwn(object, iteratee) {
	  return object && baseFor(object, iteratee, keys);
	}

	module.exports = baseForOwn;


/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	var createBaseFor = __webpack_require__(24);

	/**
	 * The base implementation of `baseForOwn` which iterates over `object`
	 * properties returned by `keysFunc` and invokes `iteratee` for each property.
	 * Iteratee functions may exit iteration early by explicitly returning `false`.
	 *
	 * @private
	 * @param {Object} object The object to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @param {Function} keysFunc The function to get the keys of `object`.
	 * @returns {Object} Returns `object`.
	 */
	var baseFor = createBaseFor();

	module.exports = baseFor;


/***/ },
/* 24 */
/***/ function(module, exports) {

	/**
	 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
	 *
	 * @private
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {Function} Returns the new base function.
	 */
	function createBaseFor(fromRight) {
	  return function(object, iteratee, keysFunc) {
	    var index = -1,
	        iterable = Object(object),
	        props = keysFunc(object),
	        length = props.length;

	    while (length--) {
	      var key = props[fromRight ? length : ++index];
	      if (iteratee(iterable[key], key, iterable) === false) {
	        break;
	      }
	    }
	    return object;
	  };
	}

	module.exports = createBaseFor;


/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	var arrayLikeKeys = __webpack_require__(26),
	    baseKeys = __webpack_require__(37),
	    isArrayLike = __webpack_require__(30);

	/**
	 * Creates an array of the own enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects. See the
	 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	 * for more details.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keys(new Foo);
	 * // => ['a', 'b'] (iteration order is not guaranteed)
	 *
	 * _.keys('hi');
	 * // => ['0', '1']
	 */
	function keys(object) {
	  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
	}

	module.exports = keys;


/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	var baseTimes = __webpack_require__(27),
	    isArguments = __webpack_require__(28),
	    isArray = __webpack_require__(35),
	    isIndex = __webpack_require__(36);

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Creates an array of the enumerable property names of the array-like `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @param {boolean} inherited Specify returning inherited property names.
	 * @returns {Array} Returns the array of property names.
	 */
	function arrayLikeKeys(value, inherited) {
	  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
	  // Safari 9 makes `arguments.length` enumerable in strict mode.
	  var result = (isArray(value) || isArguments(value))
	    ? baseTimes(value.length, String)
	    : [];

	  var length = result.length,
	      skipIndexes = !!length;

	  for (var key in value) {
	    if ((inherited || hasOwnProperty.call(value, key)) &&
	        !(skipIndexes && (key == 'length' || isIndex(key, length)))) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	module.exports = arrayLikeKeys;


/***/ },
/* 27 */
/***/ function(module, exports) {

	/**
	 * The base implementation of `_.times` without support for iteratee shorthands
	 * or max array length checks.
	 *
	 * @private
	 * @param {number} n The number of times to invoke `iteratee`.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the array of results.
	 */
	function baseTimes(n, iteratee) {
	  var index = -1,
	      result = Array(n);

	  while (++index < n) {
	    result[index] = iteratee(index);
	  }
	  return result;
	}

	module.exports = baseTimes;


/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	var isArrayLikeObject = __webpack_require__(29);

	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]';

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objectToString = objectProto.toString;

	/** Built-in value references. */
	var propertyIsEnumerable = objectProto.propertyIsEnumerable;

	/**
	 * Checks if `value` is likely an `arguments` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArguments(function() { return arguments; }());
	 * // => true
	 *
	 * _.isArguments([1, 2, 3]);
	 * // => false
	 */
	function isArguments(value) {
	  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
	  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&
	    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
	}

	module.exports = isArguments;


/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	var isArrayLike = __webpack_require__(30),
	    isObjectLike = __webpack_require__(34);

	/**
	 * This method is like `_.isArrayLike` except that it also checks if `value`
	 * is an object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array-like object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArrayLikeObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLikeObject(document.body.children);
	 * // => true
	 *
	 * _.isArrayLikeObject('abc');
	 * // => false
	 *
	 * _.isArrayLikeObject(_.noop);
	 * // => false
	 */
	function isArrayLikeObject(value) {
	  return isObjectLike(value) && isArrayLike(value);
	}

	module.exports = isArrayLikeObject;


/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	var isFunction = __webpack_require__(31),
	    isLength = __webpack_require__(33);

	/**
	 * Checks if `value` is array-like. A value is considered array-like if it's
	 * not a function and has a `value.length` that's an integer greater than or
	 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	 * @example
	 *
	 * _.isArrayLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLike(document.body.children);
	 * // => true
	 *
	 * _.isArrayLike('abc');
	 * // => true
	 *
	 * _.isArrayLike(_.noop);
	 * // => false
	 */
	function isArrayLike(value) {
	  return value != null && isLength(value.length) && !isFunction(value);
	}

	module.exports = isArrayLike;


/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(32);

	/** `Object#toString` result references. */
	var funcTag = '[object Function]',
	    genTag = '[object GeneratorFunction]';

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objectToString = objectProto.toString;

	/**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => false
	 */
	function isFunction(value) {
	  // The use of `Object#toString` avoids issues with the `typeof` operator
	  // in Safari 8-9 which returns 'object' for typed array and other constructors.
	  var tag = isObject(value) ? objectToString.call(value) : '';
	  return tag == funcTag || tag == genTag;
	}

	module.exports = isFunction;


/***/ },
/* 32 */
/***/ function(module, exports) {

	/**
	 * Checks if `value` is the
	 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(_.noop);
	 * // => true
	 *
	 * _.isObject(null);
	 * // => false
	 */
	function isObject(value) {
	  var type = typeof value;
	  return value != null && (type == 'object' || type == 'function');
	}

	module.exports = isObject;


/***/ },
/* 33 */
/***/ function(module, exports) {

	/** Used as references for various `Number` constants. */
	var MAX_SAFE_INTEGER = 9007199254740991;

	/**
	 * Checks if `value` is a valid array-like length.
	 *
	 * **Note:** This method is loosely based on
	 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	 * @example
	 *
	 * _.isLength(3);
	 * // => true
	 *
	 * _.isLength(Number.MIN_VALUE);
	 * // => false
	 *
	 * _.isLength(Infinity);
	 * // => false
	 *
	 * _.isLength('3');
	 * // => false
	 */
	function isLength(value) {
	  return typeof value == 'number' &&
	    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	}

	module.exports = isLength;


/***/ },
/* 34 */
/***/ function(module, exports) {

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return value != null && typeof value == 'object';
	}

	module.exports = isObjectLike;


/***/ },
/* 35 */
/***/ function(module, exports) {

	/**
	 * Checks if `value` is classified as an `Array` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
	 * @example
	 *
	 * _.isArray([1, 2, 3]);
	 * // => true
	 *
	 * _.isArray(document.body.children);
	 * // => false
	 *
	 * _.isArray('abc');
	 * // => false
	 *
	 * _.isArray(_.noop);
	 * // => false
	 */
	var isArray = Array.isArray;

	module.exports = isArray;


/***/ },
/* 36 */
/***/ function(module, exports) {

	/** Used as references for various `Number` constants. */
	var MAX_SAFE_INTEGER = 9007199254740991;

	/** Used to detect unsigned integer values. */
	var reIsUint = /^(?:0|[1-9]\d*)$/;

	/**
	 * Checks if `value` is a valid array-like index.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	 */
	function isIndex(value, length) {
	  length = length == null ? MAX_SAFE_INTEGER : length;
	  return !!length &&
	    (typeof value == 'number' || reIsUint.test(value)) &&
	    (value > -1 && value % 1 == 0 && value < length);
	}

	module.exports = isIndex;


/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	var isPrototype = __webpack_require__(38),
	    nativeKeys = __webpack_require__(39);

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function baseKeys(object) {
	  if (!isPrototype(object)) {
	    return nativeKeys(object);
	  }
	  var result = [];
	  for (var key in Object(object)) {
	    if (hasOwnProperty.call(object, key) && key != 'constructor') {
	      result.push(key);
	    }
	  }
	  return result;
	}

	module.exports = baseKeys;


/***/ },
/* 38 */
/***/ function(module, exports) {

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/**
	 * Checks if `value` is likely a prototype object.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
	 */
	function isPrototype(value) {
	  var Ctor = value && value.constructor,
	      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

	  return value === proto;
	}

	module.exports = isPrototype;


/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	var overArg = __webpack_require__(40);

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeKeys = overArg(Object.keys, Object);

	module.exports = nativeKeys;


/***/ },
/* 40 */
/***/ function(module, exports) {

	/**
	 * Creates a unary function that invokes `func` with its argument transformed.
	 *
	 * @private
	 * @param {Function} func The function to wrap.
	 * @param {Function} transform The argument transform.
	 * @returns {Function} Returns the new function.
	 */
	function overArg(func, transform) {
	  return function(arg) {
	    return func(transform(arg));
	  };
	}

	module.exports = overArg;


/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	var isArrayLike = __webpack_require__(30);

	/**
	 * Creates a `baseEach` or `baseEachRight` function.
	 *
	 * @private
	 * @param {Function} eachFunc The function to iterate over a collection.
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {Function} Returns the new base function.
	 */
	function createBaseEach(eachFunc, fromRight) {
	  return function(collection, iteratee) {
	    if (collection == null) {
	      return collection;
	    }
	    if (!isArrayLike(collection)) {
	      return eachFunc(collection, iteratee);
	    }
	    var length = collection.length,
	        index = fromRight ? length : -1,
	        iterable = Object(collection);

	    while ((fromRight ? index-- : ++index < length)) {
	      if (iteratee(iterable[index], index, iterable) === false) {
	        break;
	      }
	    }
	    return collection;
	  };
	}

	module.exports = createBaseEach;


/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	var baseMatches = __webpack_require__(43),
	    baseMatchesProperty = __webpack_require__(111),
	    identity = __webpack_require__(126),
	    isArray = __webpack_require__(35),
	    property = __webpack_require__(127);

	/**
	 * The base implementation of `_.iteratee`.
	 *
	 * @private
	 * @param {*} [value=_.identity] The value to convert to an iteratee.
	 * @returns {Function} Returns the iteratee.
	 */
	function baseIteratee(value) {
	  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
	  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
	  if (typeof value == 'function') {
	    return value;
	  }
	  if (value == null) {
	    return identity;
	  }
	  if (typeof value == 'object') {
	    return isArray(value)
	      ? baseMatchesProperty(value[0], value[1])
	      : baseMatches(value);
	  }
	  return property(value);
	}

	module.exports = baseIteratee;


/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	var baseIsMatch = __webpack_require__(44),
	    getMatchData = __webpack_require__(108),
	    matchesStrictComparable = __webpack_require__(110);

	/**
	 * The base implementation of `_.matches` which doesn't clone `source`.
	 *
	 * @private
	 * @param {Object} source The object of property values to match.
	 * @returns {Function} Returns the new spec function.
	 */
	function baseMatches(source) {
	  var matchData = getMatchData(source);
	  if (matchData.length == 1 && matchData[0][2]) {
	    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
	  }
	  return function(object) {
	    return object === source || baseIsMatch(object, source, matchData);
	  };
	}

	module.exports = baseMatches;


/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	var Stack = __webpack_require__(45),
	    baseIsEqual = __webpack_require__(83);

	/** Used to compose bitmasks for comparison styles. */
	var UNORDERED_COMPARE_FLAG = 1,
	    PARTIAL_COMPARE_FLAG = 2;

	/**
	 * The base implementation of `_.isMatch` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Object} object The object to inspect.
	 * @param {Object} source The object of property values to match.
	 * @param {Array} matchData The property names, values, and compare flags to match.
	 * @param {Function} [customizer] The function to customize comparisons.
	 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
	 */
	function baseIsMatch(object, source, matchData, customizer) {
	  var index = matchData.length,
	      length = index,
	      noCustomizer = !customizer;

	  if (object == null) {
	    return !length;
	  }
	  object = Object(object);
	  while (index--) {
	    var data = matchData[index];
	    if ((noCustomizer && data[2])
	          ? data[1] !== object[data[0]]
	          : !(data[0] in object)
	        ) {
	      return false;
	    }
	  }
	  while (++index < length) {
	    data = matchData[index];
	    var key = data[0],
	        objValue = object[key],
	        srcValue = data[1];

	    if (noCustomizer && data[2]) {
	      if (objValue === undefined && !(key in object)) {
	        return false;
	      }
	    } else {
	      var stack = new Stack;
	      if (customizer) {
	        var result = customizer(objValue, srcValue, key, object, source, stack);
	      }
	      if (!(result === undefined
	            ? baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack)
	            : result
	          )) {
	        return false;
	      }
	    }
	  }
	  return true;
	}

	module.exports = baseIsMatch;


/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	var ListCache = __webpack_require__(46),
	    stackClear = __webpack_require__(54),
	    stackDelete = __webpack_require__(55),
	    stackGet = __webpack_require__(56),
	    stackHas = __webpack_require__(57),
	    stackSet = __webpack_require__(58);

	/**
	 * Creates a stack cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Stack(entries) {
	  var data = this.__data__ = new ListCache(entries);
	  this.size = data.size;
	}

	// Add methods to `Stack`.
	Stack.prototype.clear = stackClear;
	Stack.prototype['delete'] = stackDelete;
	Stack.prototype.get = stackGet;
	Stack.prototype.has = stackHas;
	Stack.prototype.set = stackSet;

	module.exports = Stack;


/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	var listCacheClear = __webpack_require__(47),
	    listCacheDelete = __webpack_require__(48),
	    listCacheGet = __webpack_require__(51),
	    listCacheHas = __webpack_require__(52),
	    listCacheSet = __webpack_require__(53);

	/**
	 * Creates an list cache object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function ListCache(entries) {
	  var index = -1,
	      length = entries ? entries.length : 0;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `ListCache`.
	ListCache.prototype.clear = listCacheClear;
	ListCache.prototype['delete'] = listCacheDelete;
	ListCache.prototype.get = listCacheGet;
	ListCache.prototype.has = listCacheHas;
	ListCache.prototype.set = listCacheSet;

	module.exports = ListCache;


/***/ },
/* 47 */
/***/ function(module, exports) {

	/**
	 * Removes all key-value entries from the list cache.
	 *
	 * @private
	 * @name clear
	 * @memberOf ListCache
	 */
	function listCacheClear() {
	  this.__data__ = [];
	  this.size = 0;
	}

	module.exports = listCacheClear;


/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	var assocIndexOf = __webpack_require__(49);

	/** Used for built-in method references. */
	var arrayProto = Array.prototype;

	/** Built-in value references. */
	var splice = arrayProto.splice;

	/**
	 * Removes `key` and its value from the list cache.
	 *
	 * @private
	 * @name delete
	 * @memberOf ListCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function listCacheDelete(key) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);

	  if (index < 0) {
	    return false;
	  }
	  var lastIndex = data.length - 1;
	  if (index == lastIndex) {
	    data.pop();
	  } else {
	    splice.call(data, index, 1);
	  }
	  --this.size;
	  return true;
	}

	module.exports = listCacheDelete;


/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	var eq = __webpack_require__(50);

	/**
	 * Gets the index at which the `key` is found in `array` of key-value pairs.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} key The key to search for.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function assocIndexOf(array, key) {
	  var length = array.length;
	  while (length--) {
	    if (eq(array[length][0], key)) {
	      return length;
	    }
	  }
	  return -1;
	}

	module.exports = assocIndexOf;


/***/ },
/* 50 */
/***/ function(module, exports) {

	/**
	 * Performs a
	 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * comparison between two values to determine if they are equivalent.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 * var other = { 'a': 1 };
	 *
	 * _.eq(object, object);
	 * // => true
	 *
	 * _.eq(object, other);
	 * // => false
	 *
	 * _.eq('a', 'a');
	 * // => true
	 *
	 * _.eq('a', Object('a'));
	 * // => false
	 *
	 * _.eq(NaN, NaN);
	 * // => true
	 */
	function eq(value, other) {
	  return value === other || (value !== value && other !== other);
	}

	module.exports = eq;


/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	var assocIndexOf = __webpack_require__(49);

	/**
	 * Gets the list cache value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf ListCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function listCacheGet(key) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);

	  return index < 0 ? undefined : data[index][1];
	}

	module.exports = listCacheGet;


/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	var assocIndexOf = __webpack_require__(49);

	/**
	 * Checks if a list cache value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf ListCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function listCacheHas(key) {
	  return assocIndexOf(this.__data__, key) > -1;
	}

	module.exports = listCacheHas;


/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	var assocIndexOf = __webpack_require__(49);

	/**
	 * Sets the list cache `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf ListCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the list cache instance.
	 */
	function listCacheSet(key, value) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);

	  if (index < 0) {
	    ++this.size;
	    data.push([key, value]);
	  } else {
	    data[index][1] = value;
	  }
	  return this;
	}

	module.exports = listCacheSet;


/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	var ListCache = __webpack_require__(46);

	/**
	 * Removes all key-value entries from the stack.
	 *
	 * @private
	 * @name clear
	 * @memberOf Stack
	 */
	function stackClear() {
	  this.__data__ = new ListCache;
	  this.size = 0;
	}

	module.exports = stackClear;


/***/ },
/* 55 */
/***/ function(module, exports) {

	/**
	 * Removes `key` and its value from the stack.
	 *
	 * @private
	 * @name delete
	 * @memberOf Stack
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function stackDelete(key) {
	  var data = this.__data__,
	      result = data['delete'](key);

	  this.size = data.size;
	  return result;
	}

	module.exports = stackDelete;


/***/ },
/* 56 */
/***/ function(module, exports) {

	/**
	 * Gets the stack value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Stack
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function stackGet(key) {
	  return this.__data__.get(key);
	}

	module.exports = stackGet;


/***/ },
/* 57 */
/***/ function(module, exports) {

	/**
	 * Checks if a stack value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Stack
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function stackHas(key) {
	  return this.__data__.has(key);
	}

	module.exports = stackHas;


/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	var ListCache = __webpack_require__(46),
	    Map = __webpack_require__(59),
	    MapCache = __webpack_require__(68);

	/** Used as the size to enable large array optimizations. */
	var LARGE_ARRAY_SIZE = 200;

	/**
	 * Sets the stack `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Stack
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the stack cache instance.
	 */
	function stackSet(key, value) {
	  var data = this.__data__;
	  if (data instanceof ListCache) {
	    var pairs = data.__data__;
	    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
	      pairs.push([key, value]);
	      this.size = ++data.size;
	      return this;
	    }
	    data = this.__data__ = new MapCache(pairs);
	  }
	  data.set(key, value);
	  this.size = data.size;
	  return this;
	}

	module.exports = stackSet;


/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	var getNative = __webpack_require__(60),
	    root = __webpack_require__(64);

	/* Built-in method references that are verified to be native. */
	var Map = getNative(root, 'Map');

	module.exports = Map;


/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	var baseIsNative = __webpack_require__(61),
	    getValue = __webpack_require__(67);

	/**
	 * Gets the native function at `key` of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {string} key The key of the method to get.
	 * @returns {*} Returns the function if it's native, else `undefined`.
	 */
	function getNative(object, key) {
	  var value = getValue(object, key);
	  return baseIsNative(value) ? value : undefined;
	}

	module.exports = getNative;


/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	var isFunction = __webpack_require__(31),
	    isMasked = __webpack_require__(62),
	    isObject = __webpack_require__(32),
	    toSource = __webpack_require__(66);

	/**
	 * Used to match `RegExp`
	 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
	 */
	var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

	/** Used to detect host constructors (Safari). */
	var reIsHostCtor = /^\[object .+?Constructor\]$/;

	/** Used for built-in method references. */
	var funcProto = Function.prototype,
	    objectProto = Object.prototype;

	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/** Used to detect if a method is native. */
	var reIsNative = RegExp('^' +
	  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
	  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
	);

	/**
	 * The base implementation of `_.isNative` without bad shim checks.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a native function,
	 *  else `false`.
	 */
	function baseIsNative(value) {
	  if (!isObject(value) || isMasked(value)) {
	    return false;
	  }
	  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
	  return pattern.test(toSource(value));
	}

	module.exports = baseIsNative;


/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	var coreJsData = __webpack_require__(63);

	/** Used to detect methods masquerading as native. */
	var maskSrcKey = (function() {
	  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
	  return uid ? ('Symbol(src)_1.' + uid) : '';
	}());

	/**
	 * Checks if `func` has its source masked.
	 *
	 * @private
	 * @param {Function} func The function to check.
	 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
	 */
	function isMasked(func) {
	  return !!maskSrcKey && (maskSrcKey in func);
	}

	module.exports = isMasked;


/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	var root = __webpack_require__(64);

	/** Used to detect overreaching core-js shims. */
	var coreJsData = root['__core-js_shared__'];

	module.exports = coreJsData;


/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	var freeGlobal = __webpack_require__(65);

	/** Detect free variable `self`. */
	var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

	/** Used as a reference to the global object. */
	var root = freeGlobal || freeSelf || Function('return this')();

	module.exports = root;


/***/ },
/* 65 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {/** Detect free variable `global` from Node.js. */
	var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

	module.exports = freeGlobal;

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 66 */
/***/ function(module, exports) {

	/** Used for built-in method references. */
	var funcProto = Function.prototype;

	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;

	/**
	 * Converts `func` to its source code.
	 *
	 * @private
	 * @param {Function} func The function to process.
	 * @returns {string} Returns the source code.
	 */
	function toSource(func) {
	  if (func != null) {
	    try {
	      return funcToString.call(func);
	    } catch (e) {}
	    try {
	      return (func + '');
	    } catch (e) {}
	  }
	  return '';
	}

	module.exports = toSource;


/***/ },
/* 67 */
/***/ function(module, exports) {

	/**
	 * Gets the value at `key` of `object`.
	 *
	 * @private
	 * @param {Object} [object] The object to query.
	 * @param {string} key The key of the property to get.
	 * @returns {*} Returns the property value.
	 */
	function getValue(object, key) {
	  return object == null ? undefined : object[key];
	}

	module.exports = getValue;


/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	var mapCacheClear = __webpack_require__(69),
	    mapCacheDelete = __webpack_require__(77),
	    mapCacheGet = __webpack_require__(80),
	    mapCacheHas = __webpack_require__(81),
	    mapCacheSet = __webpack_require__(82);

	/**
	 * Creates a map cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function MapCache(entries) {
	  var index = -1,
	      length = entries ? entries.length : 0;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `MapCache`.
	MapCache.prototype.clear = mapCacheClear;
	MapCache.prototype['delete'] = mapCacheDelete;
	MapCache.prototype.get = mapCacheGet;
	MapCache.prototype.has = mapCacheHas;
	MapCache.prototype.set = mapCacheSet;

	module.exports = MapCache;


/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	var Hash = __webpack_require__(70),
	    ListCache = __webpack_require__(46),
	    Map = __webpack_require__(59);

	/**
	 * Removes all key-value entries from the map.
	 *
	 * @private
	 * @name clear
	 * @memberOf MapCache
	 */
	function mapCacheClear() {
	  this.size = 0;
	  this.__data__ = {
	    'hash': new Hash,
	    'map': new (Map || ListCache),
	    'string': new Hash
	  };
	}

	module.exports = mapCacheClear;


/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	var hashClear = __webpack_require__(71),
	    hashDelete = __webpack_require__(73),
	    hashGet = __webpack_require__(74),
	    hashHas = __webpack_require__(75),
	    hashSet = __webpack_require__(76);

	/**
	 * Creates a hash object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Hash(entries) {
	  var index = -1,
	      length = entries ? entries.length : 0;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `Hash`.
	Hash.prototype.clear = hashClear;
	Hash.prototype['delete'] = hashDelete;
	Hash.prototype.get = hashGet;
	Hash.prototype.has = hashHas;
	Hash.prototype.set = hashSet;

	module.exports = Hash;


/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	var nativeCreate = __webpack_require__(72);

	/**
	 * Removes all key-value entries from the hash.
	 *
	 * @private
	 * @name clear
	 * @memberOf Hash
	 */
	function hashClear() {
	  this.__data__ = nativeCreate ? nativeCreate(null) : {};
	  this.size = 0;
	}

	module.exports = hashClear;


/***/ },
/* 72 */
/***/ function(module, exports, __webpack_require__) {

	var getNative = __webpack_require__(60);

	/* Built-in method references that are verified to be native. */
	var nativeCreate = getNative(Object, 'create');

	module.exports = nativeCreate;


/***/ },
/* 73 */
/***/ function(module, exports) {

	/**
	 * Removes `key` and its value from the hash.
	 *
	 * @private
	 * @name delete
	 * @memberOf Hash
	 * @param {Object} hash The hash to modify.
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function hashDelete(key) {
	  var result = this.has(key) && delete this.__data__[key];
	  this.size -= result ? 1 : 0;
	  return result;
	}

	module.exports = hashDelete;


/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	var nativeCreate = __webpack_require__(72);

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED = '__lodash_hash_undefined__';

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Gets the hash value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Hash
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function hashGet(key) {
	  var data = this.__data__;
	  if (nativeCreate) {
	    var result = data[key];
	    return result === HASH_UNDEFINED ? undefined : result;
	  }
	  return hasOwnProperty.call(data, key) ? data[key] : undefined;
	}

	module.exports = hashGet;


/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	var nativeCreate = __webpack_require__(72);

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Checks if a hash value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Hash
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function hashHas(key) {
	  var data = this.__data__;
	  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
	}

	module.exports = hashHas;


/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	var nativeCreate = __webpack_require__(72);

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED = '__lodash_hash_undefined__';

	/**
	 * Sets the hash `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Hash
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the hash instance.
	 */
	function hashSet(key, value) {
	  var data = this.__data__;
	  this.size += this.has(key) ? 0 : 1;
	  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
	  return this;
	}

	module.exports = hashSet;


/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	var getMapData = __webpack_require__(78);

	/**
	 * Removes `key` and its value from the map.
	 *
	 * @private
	 * @name delete
	 * @memberOf MapCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function mapCacheDelete(key) {
	  var result = getMapData(this, key)['delete'](key);
	  this.size -= result ? 1 : 0;
	  return result;
	}

	module.exports = mapCacheDelete;


/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

	var isKeyable = __webpack_require__(79);

	/**
	 * Gets the data for `map`.
	 *
	 * @private
	 * @param {Object} map The map to query.
	 * @param {string} key The reference key.
	 * @returns {*} Returns the map data.
	 */
	function getMapData(map, key) {
	  var data = map.__data__;
	  return isKeyable(key)
	    ? data[typeof key == 'string' ? 'string' : 'hash']
	    : data.map;
	}

	module.exports = getMapData;


/***/ },
/* 79 */
/***/ function(module, exports) {

	/**
	 * Checks if `value` is suitable for use as unique object key.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
	 */
	function isKeyable(value) {
	  var type = typeof value;
	  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
	    ? (value !== '__proto__')
	    : (value === null);
	}

	module.exports = isKeyable;


/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	var getMapData = __webpack_require__(78);

	/**
	 * Gets the map value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf MapCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function mapCacheGet(key) {
	  return getMapData(this, key).get(key);
	}

	module.exports = mapCacheGet;


/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	var getMapData = __webpack_require__(78);

	/**
	 * Checks if a map value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf MapCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function mapCacheHas(key) {
	  return getMapData(this, key).has(key);
	}

	module.exports = mapCacheHas;


/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

	var getMapData = __webpack_require__(78);

	/**
	 * Sets the map `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf MapCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the map cache instance.
	 */
	function mapCacheSet(key, value) {
	  var data = getMapData(this, key),
	      size = data.size;

	  data.set(key, value);
	  this.size += data.size == size ? 0 : 1;
	  return this;
	}

	module.exports = mapCacheSet;


/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

	var baseIsEqualDeep = __webpack_require__(84),
	    isObject = __webpack_require__(32),
	    isObjectLike = __webpack_require__(34);

	/**
	 * The base implementation of `_.isEqual` which supports partial comparisons
	 * and tracks traversed objects.
	 *
	 * @private
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @param {Function} [customizer] The function to customize comparisons.
	 * @param {boolean} [bitmask] The bitmask of comparison flags.
	 *  The bitmask may be composed of the following flags:
	 *     1 - Unordered comparison
	 *     2 - Partial comparison
	 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 */
	function baseIsEqual(value, other, customizer, bitmask, stack) {
	  if (value === other) {
	    return true;
	  }
	  if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {
	    return value !== value && other !== other;
	  }
	  return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);
	}

	module.exports = baseIsEqual;


/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

	var Stack = __webpack_require__(45),
	    equalArrays = __webpack_require__(85),
	    equalByTag = __webpack_require__(91),
	    equalObjects = __webpack_require__(96),
	    getTag = __webpack_require__(97),
	    isArray = __webpack_require__(35),
	    isTypedArray = __webpack_require__(103);

	/** Used to compose bitmasks for comparison styles. */
	var PARTIAL_COMPARE_FLAG = 2;

	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]',
	    arrayTag = '[object Array]',
	    objectTag = '[object Object]';

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * A specialized version of `baseIsEqual` for arrays and objects which performs
	 * deep comparisons and tracks traversed objects enabling objects with circular
	 * references to be compared.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Function} [customizer] The function to customize comparisons.
	 * @param {number} [bitmask] The bitmask of comparison flags. See `baseIsEqual`
	 *  for more details.
	 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {
	  var objIsArr = isArray(object),
	      othIsArr = isArray(other),
	      objTag = arrayTag,
	      othTag = arrayTag;

	  if (!objIsArr) {
	    objTag = getTag(object);
	    objTag = objTag == argsTag ? objectTag : objTag;
	  }
	  if (!othIsArr) {
	    othTag = getTag(other);
	    othTag = othTag == argsTag ? objectTag : othTag;
	  }
	  var objIsObj = objTag == objectTag,
	      othIsObj = othTag == objectTag,
	      isSameTag = objTag == othTag;

	  if (isSameTag && !objIsObj) {
	    stack || (stack = new Stack);
	    return (objIsArr || isTypedArray(object))
	      ? equalArrays(object, other, equalFunc, customizer, bitmask, stack)
	      : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack);
	  }
	  if (!(bitmask & PARTIAL_COMPARE_FLAG)) {
	    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
	        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

	    if (objIsWrapped || othIsWrapped) {
	      var objUnwrapped = objIsWrapped ? object.value() : object,
	          othUnwrapped = othIsWrapped ? other.value() : other;

	      stack || (stack = new Stack);
	      return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);
	    }
	  }
	  if (!isSameTag) {
	    return false;
	  }
	  stack || (stack = new Stack);
	  return equalObjects(object, other, equalFunc, customizer, bitmask, stack);
	}

	module.exports = baseIsEqualDeep;


/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	var SetCache = __webpack_require__(86),
	    arraySome = __webpack_require__(89),
	    cacheHas = __webpack_require__(90);

	/** Used to compose bitmasks for comparison styles. */
	var UNORDERED_COMPARE_FLAG = 1,
	    PARTIAL_COMPARE_FLAG = 2;

	/**
	 * A specialized version of `baseIsEqualDeep` for arrays with support for
	 * partial deep comparisons.
	 *
	 * @private
	 * @param {Array} array The array to compare.
	 * @param {Array} other The other array to compare.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
	 *  for more details.
	 * @param {Object} stack Tracks traversed `array` and `other` objects.
	 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
	 */
	function equalArrays(array, other, equalFunc, customizer, bitmask, stack) {
	  var isPartial = bitmask & PARTIAL_COMPARE_FLAG,
	      arrLength = array.length,
	      othLength = other.length;

	  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
	    return false;
	  }
	  // Assume cyclic values are equal.
	  var stacked = stack.get(array);
	  if (stacked && stack.get(other)) {
	    return stacked == other;
	  }
	  var index = -1,
	      result = true,
	      seen = (bitmask & UNORDERED_COMPARE_FLAG) ? new SetCache : undefined;

	  stack.set(array, other);
	  stack.set(other, array);

	  // Ignore non-index properties.
	  while (++index < arrLength) {
	    var arrValue = array[index],
	        othValue = other[index];

	    if (customizer) {
	      var compared = isPartial
	        ? customizer(othValue, arrValue, index, other, array, stack)
	        : customizer(arrValue, othValue, index, array, other, stack);
	    }
	    if (compared !== undefined) {
	      if (compared) {
	        continue;
	      }
	      result = false;
	      break;
	    }
	    // Recursively compare arrays (susceptible to call stack limits).
	    if (seen) {
	      if (!arraySome(other, function(othValue, othIndex) {
	            if (!cacheHas(seen, othIndex) &&
	                (arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
	              return seen.push(othIndex);
	            }
	          })) {
	        result = false;
	        break;
	      }
	    } else if (!(
	          arrValue === othValue ||
	            equalFunc(arrValue, othValue, customizer, bitmask, stack)
	        )) {
	      result = false;
	      break;
	    }
	  }
	  stack['delete'](array);
	  stack['delete'](other);
	  return result;
	}

	module.exports = equalArrays;


/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

	var MapCache = __webpack_require__(68),
	    setCacheAdd = __webpack_require__(87),
	    setCacheHas = __webpack_require__(88);

	/**
	 *
	 * Creates an array cache object to store unique values.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [values] The values to cache.
	 */
	function SetCache(values) {
	  var index = -1,
	      length = values ? values.length : 0;

	  this.__data__ = new MapCache;
	  while (++index < length) {
	    this.add(values[index]);
	  }
	}

	// Add methods to `SetCache`.
	SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
	SetCache.prototype.has = setCacheHas;

	module.exports = SetCache;


/***/ },
/* 87 */
/***/ function(module, exports) {

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED = '__lodash_hash_undefined__';

	/**
	 * Adds `value` to the array cache.
	 *
	 * @private
	 * @name add
	 * @memberOf SetCache
	 * @alias push
	 * @param {*} value The value to cache.
	 * @returns {Object} Returns the cache instance.
	 */
	function setCacheAdd(value) {
	  this.__data__.set(value, HASH_UNDEFINED);
	  return this;
	}

	module.exports = setCacheAdd;


/***/ },
/* 88 */
/***/ function(module, exports) {

	/**
	 * Checks if `value` is in the array cache.
	 *
	 * @private
	 * @name has
	 * @memberOf SetCache
	 * @param {*} value The value to search for.
	 * @returns {number} Returns `true` if `value` is found, else `false`.
	 */
	function setCacheHas(value) {
	  return this.__data__.has(value);
	}

	module.exports = setCacheHas;


/***/ },
/* 89 */
/***/ function(module, exports) {

	/**
	 * A specialized version of `_.some` for arrays without support for iteratee
	 * shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} predicate The function invoked per iteration.
	 * @returns {boolean} Returns `true` if any element passes the predicate check,
	 *  else `false`.
	 */
	function arraySome(array, predicate) {
	  var index = -1,
	      length = array ? array.length : 0;

	  while (++index < length) {
	    if (predicate(array[index], index, array)) {
	      return true;
	    }
	  }
	  return false;
	}

	module.exports = arraySome;


/***/ },
/* 90 */
/***/ function(module, exports) {

	/**
	 * Checks if a `cache` value for `key` exists.
	 *
	 * @private
	 * @param {Object} cache The cache to query.
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function cacheHas(cache, key) {
	  return cache.has(key);
	}

	module.exports = cacheHas;


/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

	var Symbol = __webpack_require__(92),
	    Uint8Array = __webpack_require__(93),
	    eq = __webpack_require__(50),
	    equalArrays = __webpack_require__(85),
	    mapToArray = __webpack_require__(94),
	    setToArray = __webpack_require__(95);

	/** Used to compose bitmasks for comparison styles. */
	var UNORDERED_COMPARE_FLAG = 1,
	    PARTIAL_COMPARE_FLAG = 2;

	/** `Object#toString` result references. */
	var boolTag = '[object Boolean]',
	    dateTag = '[object Date]',
	    errorTag = '[object Error]',
	    mapTag = '[object Map]',
	    numberTag = '[object Number]',
	    regexpTag = '[object RegExp]',
	    setTag = '[object Set]',
	    stringTag = '[object String]',
	    symbolTag = '[object Symbol]';

	var arrayBufferTag = '[object ArrayBuffer]',
	    dataViewTag = '[object DataView]';

	/** Used to convert symbols to primitives and strings. */
	var symbolProto = Symbol ? Symbol.prototype : undefined,
	    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

	/**
	 * A specialized version of `baseIsEqualDeep` for comparing objects of
	 * the same `toStringTag`.
	 *
	 * **Note:** This function only supports comparing values with tags of
	 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {string} tag The `toStringTag` of the objects to compare.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
	 *  for more details.
	 * @param {Object} stack Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {
	  switch (tag) {
	    case dataViewTag:
	      if ((object.byteLength != other.byteLength) ||
	          (object.byteOffset != other.byteOffset)) {
	        return false;
	      }
	      object = object.buffer;
	      other = other.buffer;

	    case arrayBufferTag:
	      if ((object.byteLength != other.byteLength) ||
	          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
	        return false;
	      }
	      return true;

	    case boolTag:
	    case dateTag:
	    case numberTag:
	      // Coerce booleans to `1` or `0` and dates to milliseconds.
	      // Invalid dates are coerced to `NaN`.
	      return eq(+object, +other);

	    case errorTag:
	      return object.name == other.name && object.message == other.message;

	    case regexpTag:
	    case stringTag:
	      // Coerce regexes to strings and treat strings, primitives and objects,
	      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
	      // for more details.
	      return object == (other + '');

	    case mapTag:
	      var convert = mapToArray;

	    case setTag:
	      var isPartial = bitmask & PARTIAL_COMPARE_FLAG;
	      convert || (convert = setToArray);

	      if (object.size != other.size && !isPartial) {
	        return false;
	      }
	      // Assume cyclic values are equal.
	      var stacked = stack.get(object);
	      if (stacked) {
	        return stacked == other;
	      }
	      bitmask |= UNORDERED_COMPARE_FLAG;

	      // Recursively compare objects (susceptible to call stack limits).
	      stack.set(object, other);
	      var result = equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask, stack);
	      stack['delete'](object);
	      return result;

	    case symbolTag:
	      if (symbolValueOf) {
	        return symbolValueOf.call(object) == symbolValueOf.call(other);
	      }
	  }
	  return false;
	}

	module.exports = equalByTag;


/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	var root = __webpack_require__(64);

	/** Built-in value references. */
	var Symbol = root.Symbol;

	module.exports = Symbol;


/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	var root = __webpack_require__(64);

	/** Built-in value references. */
	var Uint8Array = root.Uint8Array;

	module.exports = Uint8Array;


/***/ },
/* 94 */
/***/ function(module, exports) {

	/**
	 * Converts `map` to its key-value pairs.
	 *
	 * @private
	 * @param {Object} map The map to convert.
	 * @returns {Array} Returns the key-value pairs.
	 */
	function mapToArray(map) {
	  var index = -1,
	      result = Array(map.size);

	  map.forEach(function(value, key) {
	    result[++index] = [key, value];
	  });
	  return result;
	}

	module.exports = mapToArray;


/***/ },
/* 95 */
/***/ function(module, exports) {

	/**
	 * Converts `set` to an array of its values.
	 *
	 * @private
	 * @param {Object} set The set to convert.
	 * @returns {Array} Returns the values.
	 */
	function setToArray(set) {
	  var index = -1,
	      result = Array(set.size);

	  set.forEach(function(value) {
	    result[++index] = value;
	  });
	  return result;
	}

	module.exports = setToArray;


/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	var keys = __webpack_require__(25);

	/** Used to compose bitmasks for comparison styles. */
	var PARTIAL_COMPARE_FLAG = 2;

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * A specialized version of `baseIsEqualDeep` for objects with support for
	 * partial deep comparisons.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
	 *  for more details.
	 * @param {Object} stack Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function equalObjects(object, other, equalFunc, customizer, bitmask, stack) {
	  var isPartial = bitmask & PARTIAL_COMPARE_FLAG,
	      objProps = keys(object),
	      objLength = objProps.length,
	      othProps = keys(other),
	      othLength = othProps.length;

	  if (objLength != othLength && !isPartial) {
	    return false;
	  }
	  var index = objLength;
	  while (index--) {
	    var key = objProps[index];
	    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
	      return false;
	    }
	  }
	  // Assume cyclic values are equal.
	  var stacked = stack.get(object);
	  if (stacked && stack.get(other)) {
	    return stacked == other;
	  }
	  var result = true;
	  stack.set(object, other);
	  stack.set(other, object);

	  var skipCtor = isPartial;
	  while (++index < objLength) {
	    key = objProps[index];
	    var objValue = object[key],
	        othValue = other[key];

	    if (customizer) {
	      var compared = isPartial
	        ? customizer(othValue, objValue, key, other, object, stack)
	        : customizer(objValue, othValue, key, object, other, stack);
	    }
	    // Recursively compare objects (susceptible to call stack limits).
	    if (!(compared === undefined
	          ? (objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack))
	          : compared
	        )) {
	      result = false;
	      break;
	    }
	    skipCtor || (skipCtor = key == 'constructor');
	  }
	  if (result && !skipCtor) {
	    var objCtor = object.constructor,
	        othCtor = other.constructor;

	    // Non `Object` object instances with different constructors are not equal.
	    if (objCtor != othCtor &&
	        ('constructor' in object && 'constructor' in other) &&
	        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
	          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
	      result = false;
	    }
	  }
	  stack['delete'](object);
	  stack['delete'](other);
	  return result;
	}

	module.exports = equalObjects;


/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

	var DataView = __webpack_require__(98),
	    Map = __webpack_require__(59),
	    Promise = __webpack_require__(99),
	    Set = __webpack_require__(100),
	    WeakMap = __webpack_require__(101),
	    baseGetTag = __webpack_require__(102),
	    toSource = __webpack_require__(66);

	/** `Object#toString` result references. */
	var mapTag = '[object Map]',
	    objectTag = '[object Object]',
	    promiseTag = '[object Promise]',
	    setTag = '[object Set]',
	    weakMapTag = '[object WeakMap]';

	var dataViewTag = '[object DataView]';

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objectToString = objectProto.toString;

	/** Used to detect maps, sets, and weakmaps. */
	var dataViewCtorString = toSource(DataView),
	    mapCtorString = toSource(Map),
	    promiseCtorString = toSource(Promise),
	    setCtorString = toSource(Set),
	    weakMapCtorString = toSource(WeakMap);

	/**
	 * Gets the `toStringTag` of `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	var getTag = baseGetTag;

	// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
	if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
	    (Map && getTag(new Map) != mapTag) ||
	    (Promise && getTag(Promise.resolve()) != promiseTag) ||
	    (Set && getTag(new Set) != setTag) ||
	    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
	  getTag = function(value) {
	    var result = objectToString.call(value),
	        Ctor = result == objectTag ? value.constructor : undefined,
	        ctorString = Ctor ? toSource(Ctor) : undefined;

	    if (ctorString) {
	      switch (ctorString) {
	        case dataViewCtorString: return dataViewTag;
	        case mapCtorString: return mapTag;
	        case promiseCtorString: return promiseTag;
	        case setCtorString: return setTag;
	        case weakMapCtorString: return weakMapTag;
	      }
	    }
	    return result;
	  };
	}

	module.exports = getTag;


/***/ },
/* 98 */
/***/ function(module, exports, __webpack_require__) {

	var getNative = __webpack_require__(60),
	    root = __webpack_require__(64);

	/* Built-in method references that are verified to be native. */
	var DataView = getNative(root, 'DataView');

	module.exports = DataView;


/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	var getNative = __webpack_require__(60),
	    root = __webpack_require__(64);

	/* Built-in method references that are verified to be native. */
	var Promise = getNative(root, 'Promise');

	module.exports = Promise;


/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

	var getNative = __webpack_require__(60),
	    root = __webpack_require__(64);

	/* Built-in method references that are verified to be native. */
	var Set = getNative(root, 'Set');

	module.exports = Set;


/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

	var getNative = __webpack_require__(60),
	    root = __webpack_require__(64);

	/* Built-in method references that are verified to be native. */
	var WeakMap = getNative(root, 'WeakMap');

	module.exports = WeakMap;


/***/ },
/* 102 */
/***/ function(module, exports) {

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objectToString = objectProto.toString;

	/**
	 * The base implementation of `getTag`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	function baseGetTag(value) {
	  return objectToString.call(value);
	}

	module.exports = baseGetTag;


/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

	var baseIsTypedArray = __webpack_require__(104),
	    baseUnary = __webpack_require__(105),
	    nodeUtil = __webpack_require__(106);

	/* Node.js helper references. */
	var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

	/**
	 * Checks if `value` is classified as a typed array.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 * @example
	 *
	 * _.isTypedArray(new Uint8Array);
	 * // => true
	 *
	 * _.isTypedArray([]);
	 * // => false
	 */
	var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

	module.exports = isTypedArray;


/***/ },
/* 104 */
/***/ function(module, exports, __webpack_require__) {

	var isLength = __webpack_require__(33),
	    isObjectLike = __webpack_require__(34);

	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]',
	    arrayTag = '[object Array]',
	    boolTag = '[object Boolean]',
	    dateTag = '[object Date]',
	    errorTag = '[object Error]',
	    funcTag = '[object Function]',
	    mapTag = '[object Map]',
	    numberTag = '[object Number]',
	    objectTag = '[object Object]',
	    regexpTag = '[object RegExp]',
	    setTag = '[object Set]',
	    stringTag = '[object String]',
	    weakMapTag = '[object WeakMap]';

	var arrayBufferTag = '[object ArrayBuffer]',
	    dataViewTag = '[object DataView]',
	    float32Tag = '[object Float32Array]',
	    float64Tag = '[object Float64Array]',
	    int8Tag = '[object Int8Array]',
	    int16Tag = '[object Int16Array]',
	    int32Tag = '[object Int32Array]',
	    uint8Tag = '[object Uint8Array]',
	    uint8ClampedTag = '[object Uint8ClampedArray]',
	    uint16Tag = '[object Uint16Array]',
	    uint32Tag = '[object Uint32Array]';

	/** Used to identify `toStringTag` values of typed arrays. */
	var typedArrayTags = {};
	typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
	typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
	typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
	typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
	typedArrayTags[uint32Tag] = true;
	typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
	typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
	typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
	typedArrayTags[errorTag] = typedArrayTags[funcTag] =
	typedArrayTags[mapTag] = typedArrayTags[numberTag] =
	typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
	typedArrayTags[setTag] = typedArrayTags[stringTag] =
	typedArrayTags[weakMapTag] = false;

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objectToString = objectProto.toString;

	/**
	 * The base implementation of `_.isTypedArray` without Node.js optimizations.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 */
	function baseIsTypedArray(value) {
	  return isObjectLike(value) &&
	    isLength(value.length) && !!typedArrayTags[objectToString.call(value)];
	}

	module.exports = baseIsTypedArray;


/***/ },
/* 105 */
/***/ function(module, exports) {

	/**
	 * The base implementation of `_.unary` without support for storing metadata.
	 *
	 * @private
	 * @param {Function} func The function to cap arguments for.
	 * @returns {Function} Returns the new capped function.
	 */
	function baseUnary(func) {
	  return function(value) {
	    return func(value);
	  };
	}

	module.exports = baseUnary;


/***/ },
/* 106 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {var freeGlobal = __webpack_require__(65);

	/** Detect free variable `exports`. */
	var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

	/** Detect free variable `module`. */
	var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

	/** Detect the popular CommonJS extension `module.exports`. */
	var moduleExports = freeModule && freeModule.exports === freeExports;

	/** Detect free variable `process` from Node.js. */
	var freeProcess = moduleExports && freeGlobal.process;

	/** Used to access faster Node.js helpers. */
	var nodeUtil = (function() {
	  try {
	    return freeProcess && freeProcess.binding('util');
	  } catch (e) {}
	}());

	module.exports = nodeUtil;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(107)(module)))

/***/ },
/* 107 */
/***/ function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {

	var isStrictComparable = __webpack_require__(109),
	    keys = __webpack_require__(25);

	/**
	 * Gets the property names, values, and compare flags of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the match data of `object`.
	 */
	function getMatchData(object) {
	  var result = keys(object),
	      length = result.length;

	  while (length--) {
	    var key = result[length],
	        value = object[key];

	    result[length] = [key, value, isStrictComparable(value)];
	  }
	  return result;
	}

	module.exports = getMatchData;


/***/ },
/* 109 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(32);

	/**
	 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` if suitable for strict
	 *  equality comparisons, else `false`.
	 */
	function isStrictComparable(value) {
	  return value === value && !isObject(value);
	}

	module.exports = isStrictComparable;


/***/ },
/* 110 */
/***/ function(module, exports) {

	/**
	 * A specialized version of `matchesProperty` for source values suitable
	 * for strict equality comparisons, i.e. `===`.
	 *
	 * @private
	 * @param {string} key The key of the property to get.
	 * @param {*} srcValue The value to match.
	 * @returns {Function} Returns the new spec function.
	 */
	function matchesStrictComparable(key, srcValue) {
	  return function(object) {
	    if (object == null) {
	      return false;
	    }
	    return object[key] === srcValue &&
	      (srcValue !== undefined || (key in Object(object)));
	  };
	}

	module.exports = matchesStrictComparable;


/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

	var baseIsEqual = __webpack_require__(83),
	    get = __webpack_require__(112),
	    hasIn = __webpack_require__(123),
	    isKey = __webpack_require__(121),
	    isStrictComparable = __webpack_require__(109),
	    matchesStrictComparable = __webpack_require__(110),
	    toKey = __webpack_require__(122);

	/** Used to compose bitmasks for comparison styles. */
	var UNORDERED_COMPARE_FLAG = 1,
	    PARTIAL_COMPARE_FLAG = 2;

	/**
	 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
	 *
	 * @private
	 * @param {string} path The path of the property to get.
	 * @param {*} srcValue The value to match.
	 * @returns {Function} Returns the new spec function.
	 */
	function baseMatchesProperty(path, srcValue) {
	  if (isKey(path) && isStrictComparable(srcValue)) {
	    return matchesStrictComparable(toKey(path), srcValue);
	  }
	  return function(object) {
	    var objValue = get(object, path);
	    return (objValue === undefined && objValue === srcValue)
	      ? hasIn(object, path)
	      : baseIsEqual(srcValue, objValue, undefined, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG);
	  };
	}

	module.exports = baseMatchesProperty;


/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

	var baseGet = __webpack_require__(113);

	/**
	 * Gets the value at `path` of `object`. If the resolved value is
	 * `undefined`, the `defaultValue` is returned in its place.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.7.0
	 * @category Object
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path of the property to get.
	 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
	 * @returns {*} Returns the resolved value.
	 * @example
	 *
	 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
	 *
	 * _.get(object, 'a[0].b.c');
	 * // => 3
	 *
	 * _.get(object, ['a', '0', 'b', 'c']);
	 * // => 3
	 *
	 * _.get(object, 'a.b.c', 'default');
	 * // => 'default'
	 */
	function get(object, path, defaultValue) {
	  var result = object == null ? undefined : baseGet(object, path);
	  return result === undefined ? defaultValue : result;
	}

	module.exports = get;


/***/ },
/* 113 */
/***/ function(module, exports, __webpack_require__) {

	var castPath = __webpack_require__(114),
	    isKey = __webpack_require__(121),
	    toKey = __webpack_require__(122);

	/**
	 * The base implementation of `_.get` without support for default values.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path of the property to get.
	 * @returns {*} Returns the resolved value.
	 */
	function baseGet(object, path) {
	  path = isKey(path, object) ? [path] : castPath(path);

	  var index = 0,
	      length = path.length;

	  while (object != null && index < length) {
	    object = object[toKey(path[index++])];
	  }
	  return (index && index == length) ? object : undefined;
	}

	module.exports = baseGet;


/***/ },
/* 114 */
/***/ function(module, exports, __webpack_require__) {

	var isArray = __webpack_require__(35),
	    stringToPath = __webpack_require__(115);

	/**
	 * Casts `value` to a path array if it's not one.
	 *
	 * @private
	 * @param {*} value The value to inspect.
	 * @returns {Array} Returns the cast property path array.
	 */
	function castPath(value) {
	  return isArray(value) ? value : stringToPath(value);
	}

	module.exports = castPath;


/***/ },
/* 115 */
/***/ function(module, exports, __webpack_require__) {

	var memoizeCapped = __webpack_require__(116),
	    toString = __webpack_require__(118);

	/** Used to match property names within property paths. */
	var reLeadingDot = /^\./,
	    rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

	/** Used to match backslashes in property paths. */
	var reEscapeChar = /\\(\\)?/g;

	/**
	 * Converts `string` to a property path array.
	 *
	 * @private
	 * @param {string} string The string to convert.
	 * @returns {Array} Returns the property path array.
	 */
	var stringToPath = memoizeCapped(function(string) {
	  string = toString(string);

	  var result = [];
	  if (reLeadingDot.test(string)) {
	    result.push('');
	  }
	  string.replace(rePropName, function(match, number, quote, string) {
	    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
	  });
	  return result;
	});

	module.exports = stringToPath;


/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

	var memoize = __webpack_require__(117);

	/** Used as the maximum memoize cache size. */
	var MAX_MEMOIZE_SIZE = 500;

	/**
	 * A specialized version of `_.memoize` which clears the memoized function's
	 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
	 *
	 * @private
	 * @param {Function} func The function to have its output memoized.
	 * @returns {Function} Returns the new memoized function.
	 */
	function memoizeCapped(func) {
	  var result = memoize(func, function(key) {
	    if (cache.size === MAX_MEMOIZE_SIZE) {
	      cache.clear();
	    }
	    return key;
	  });

	  var cache = result.cache;
	  return result;
	}

	module.exports = memoizeCapped;


/***/ },
/* 117 */
/***/ function(module, exports, __webpack_require__) {

	var MapCache = __webpack_require__(68);

	/** Used as the `TypeError` message for "Functions" methods. */
	var FUNC_ERROR_TEXT = 'Expected a function';

	/**
	 * Creates a function that memoizes the result of `func`. If `resolver` is
	 * provided, it determines the cache key for storing the result based on the
	 * arguments provided to the memoized function. By default, the first argument
	 * provided to the memoized function is used as the map cache key. The `func`
	 * is invoked with the `this` binding of the memoized function.
	 *
	 * **Note:** The cache is exposed as the `cache` property on the memoized
	 * function. Its creation may be customized by replacing the `_.memoize.Cache`
	 * constructor with one whose instances implement the
	 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
	 * method interface of `delete`, `get`, `has`, and `set`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Function
	 * @param {Function} func The function to have its output memoized.
	 * @param {Function} [resolver] The function to resolve the cache key.
	 * @returns {Function} Returns the new memoized function.
	 * @example
	 *
	 * var object = { 'a': 1, 'b': 2 };
	 * var other = { 'c': 3, 'd': 4 };
	 *
	 * var values = _.memoize(_.values);
	 * values(object);
	 * // => [1, 2]
	 *
	 * values(other);
	 * // => [3, 4]
	 *
	 * object.a = 2;
	 * values(object);
	 * // => [1, 2]
	 *
	 * // Modify the result cache.
	 * values.cache.set(object, ['a', 'b']);
	 * values(object);
	 * // => ['a', 'b']
	 *
	 * // Replace `_.memoize.Cache`.
	 * _.memoize.Cache = WeakMap;
	 */
	function memoize(func, resolver) {
	  if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {
	    throw new TypeError(FUNC_ERROR_TEXT);
	  }
	  var memoized = function() {
	    var args = arguments,
	        key = resolver ? resolver.apply(this, args) : args[0],
	        cache = memoized.cache;

	    if (cache.has(key)) {
	      return cache.get(key);
	    }
	    var result = func.apply(this, args);
	    memoized.cache = cache.set(key, result) || cache;
	    return result;
	  };
	  memoized.cache = new (memoize.Cache || MapCache);
	  return memoized;
	}

	// Expose `MapCache`.
	memoize.Cache = MapCache;

	module.exports = memoize;


/***/ },
/* 118 */
/***/ function(module, exports, __webpack_require__) {

	var baseToString = __webpack_require__(119);

	/**
	 * Converts `value` to a string. An empty string is returned for `null`
	 * and `undefined` values. The sign of `-0` is preserved.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to process.
	 * @returns {string} Returns the string.
	 * @example
	 *
	 * _.toString(null);
	 * // => ''
	 *
	 * _.toString(-0);
	 * // => '-0'
	 *
	 * _.toString([1, 2, 3]);
	 * // => '1,2,3'
	 */
	function toString(value) {
	  return value == null ? '' : baseToString(value);
	}

	module.exports = toString;


/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

	var Symbol = __webpack_require__(92),
	    isSymbol = __webpack_require__(120);

	/** Used as references for various `Number` constants. */
	var INFINITY = 1 / 0;

	/** Used to convert symbols to primitives and strings. */
	var symbolProto = Symbol ? Symbol.prototype : undefined,
	    symbolToString = symbolProto ? symbolProto.toString : undefined;

	/**
	 * The base implementation of `_.toString` which doesn't convert nullish
	 * values to empty strings.
	 *
	 * @private
	 * @param {*} value The value to process.
	 * @returns {string} Returns the string.
	 */
	function baseToString(value) {
	  // Exit early for strings to avoid a performance hit in some environments.
	  if (typeof value == 'string') {
	    return value;
	  }
	  if (isSymbol(value)) {
	    return symbolToString ? symbolToString.call(value) : '';
	  }
	  var result = (value + '');
	  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
	}

	module.exports = baseToString;


/***/ },
/* 120 */
/***/ function(module, exports, __webpack_require__) {

	var isObjectLike = __webpack_require__(34);

	/** `Object#toString` result references. */
	var symbolTag = '[object Symbol]';

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objectToString = objectProto.toString;

	/**
	 * Checks if `value` is classified as a `Symbol` primitive or object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
	 * @example
	 *
	 * _.isSymbol(Symbol.iterator);
	 * // => true
	 *
	 * _.isSymbol('abc');
	 * // => false
	 */
	function isSymbol(value) {
	  return typeof value == 'symbol' ||
	    (isObjectLike(value) && objectToString.call(value) == symbolTag);
	}

	module.exports = isSymbol;


/***/ },
/* 121 */
/***/ function(module, exports, __webpack_require__) {

	var isArray = __webpack_require__(35),
	    isSymbol = __webpack_require__(120);

	/** Used to match property names within property paths. */
	var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
	    reIsPlainProp = /^\w*$/;

	/**
	 * Checks if `value` is a property name and not a property path.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {Object} [object] The object to query keys on.
	 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
	 */
	function isKey(value, object) {
	  if (isArray(value)) {
	    return false;
	  }
	  var type = typeof value;
	  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
	      value == null || isSymbol(value)) {
	    return true;
	  }
	  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
	    (object != null && value in Object(object));
	}

	module.exports = isKey;


/***/ },
/* 122 */
/***/ function(module, exports, __webpack_require__) {

	var isSymbol = __webpack_require__(120);

	/** Used as references for various `Number` constants. */
	var INFINITY = 1 / 0;

	/**
	 * Converts `value` to a string key if it's not a string or symbol.
	 *
	 * @private
	 * @param {*} value The value to inspect.
	 * @returns {string|symbol} Returns the key.
	 */
	function toKey(value) {
	  if (typeof value == 'string' || isSymbol(value)) {
	    return value;
	  }
	  var result = (value + '');
	  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
	}

	module.exports = toKey;


/***/ },
/* 123 */
/***/ function(module, exports, __webpack_require__) {

	var baseHasIn = __webpack_require__(124),
	    hasPath = __webpack_require__(125);

	/**
	 * Checks if `path` is a direct or inherited property of `object`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Object
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path to check.
	 * @returns {boolean} Returns `true` if `path` exists, else `false`.
	 * @example
	 *
	 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
	 *
	 * _.hasIn(object, 'a');
	 * // => true
	 *
	 * _.hasIn(object, 'a.b');
	 * // => true
	 *
	 * _.hasIn(object, ['a', 'b']);
	 * // => true
	 *
	 * _.hasIn(object, 'b');
	 * // => false
	 */
	function hasIn(object, path) {
	  return object != null && hasPath(object, path, baseHasIn);
	}

	module.exports = hasIn;


/***/ },
/* 124 */
/***/ function(module, exports) {

	/**
	 * The base implementation of `_.hasIn` without support for deep paths.
	 *
	 * @private
	 * @param {Object} [object] The object to query.
	 * @param {Array|string} key The key to check.
	 * @returns {boolean} Returns `true` if `key` exists, else `false`.
	 */
	function baseHasIn(object, key) {
	  return object != null && key in Object(object);
	}

	module.exports = baseHasIn;


/***/ },
/* 125 */
/***/ function(module, exports, __webpack_require__) {

	var castPath = __webpack_require__(114),
	    isArguments = __webpack_require__(28),
	    isArray = __webpack_require__(35),
	    isIndex = __webpack_require__(36),
	    isKey = __webpack_require__(121),
	    isLength = __webpack_require__(33),
	    toKey = __webpack_require__(122);

	/**
	 * Checks if `path` exists on `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path to check.
	 * @param {Function} hasFunc The function to check properties.
	 * @returns {boolean} Returns `true` if `path` exists, else `false`.
	 */
	function hasPath(object, path, hasFunc) {
	  path = isKey(path, object) ? [path] : castPath(path);

	  var index = -1,
	      length = path.length,
	      result = false;

	  while (++index < length) {
	    var key = toKey(path[index]);
	    if (!(result = object != null && hasFunc(object, key))) {
	      break;
	    }
	    object = object[key];
	  }
	  if (result || ++index != length) {
	    return result;
	  }
	  length = object ? object.length : 0;
	  return !!length && isLength(length) && isIndex(key, length) &&
	    (isArray(object) || isArguments(object));
	}

	module.exports = hasPath;


/***/ },
/* 126 */
/***/ function(module, exports) {

	/**
	 * This method returns the first argument it receives.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Util
	 * @param {*} value Any value.
	 * @returns {*} Returns `value`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 *
	 * console.log(_.identity(object) === object);
	 * // => true
	 */
	function identity(value) {
	  return value;
	}

	module.exports = identity;


/***/ },
/* 127 */
/***/ function(module, exports, __webpack_require__) {

	var baseProperty = __webpack_require__(128),
	    basePropertyDeep = __webpack_require__(129),
	    isKey = __webpack_require__(121),
	    toKey = __webpack_require__(122);

	/**
	 * Creates a function that returns the value at `path` of a given object.
	 *
	 * @static
	 * @memberOf _
	 * @since 2.4.0
	 * @category Util
	 * @param {Array|string} path The path of the property to get.
	 * @returns {Function} Returns the new accessor function.
	 * @example
	 *
	 * var objects = [
	 *   { 'a': { 'b': 2 } },
	 *   { 'a': { 'b': 1 } }
	 * ];
	 *
	 * _.map(objects, _.property('a.b'));
	 * // => [2, 1]
	 *
	 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
	 * // => [1, 2]
	 */
	function property(path) {
	  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
	}

	module.exports = property;


/***/ },
/* 128 */
/***/ function(module, exports) {

	/**
	 * The base implementation of `_.property` without support for deep paths.
	 *
	 * @private
	 * @param {string} key The key of the property to get.
	 * @returns {Function} Returns the new accessor function.
	 */
	function baseProperty(key) {
	  return function(object) {
	    return object == null ? undefined : object[key];
	  };
	}

	module.exports = baseProperty;


/***/ },
/* 129 */
/***/ function(module, exports, __webpack_require__) {

	var baseGet = __webpack_require__(113);

	/**
	 * A specialized version of `baseProperty` which supports deep paths.
	 *
	 * @private
	 * @param {Array|string} path The path of the property to get.
	 * @returns {Function} Returns the new accessor function.
	 */
	function basePropertyDeep(path) {
	  return function(object) {
	    return baseGet(object, path);
	  };
	}

	module.exports = basePropertyDeep;


/***/ },
/* 130 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.KinveyObservable = undefined;

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _Observable2 = __webpack_require__(131);

	var _toPromise2 = __webpack_require__(145);

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * @private
	 */
	var KinveyObservable = exports.KinveyObservable = function (_Observable) {
	  _inherits(KinveyObservable, _Observable);

	  function KinveyObservable() {
	    _classCallCheck(this, KinveyObservable);

	    return _possibleConstructorReturn(this, (KinveyObservable.__proto__ || Object.getPrototypeOf(KinveyObservable)).apply(this, arguments));
	  }

	  _createClass(KinveyObservable, [{
	    key: 'toPromise',
	    value: function toPromise() {
	      return _toPromise2.toPromise.call(this);
	    }
	  }], [{
	    key: 'create',
	    value: function create(subscriber) {
	      return new KinveyObservable(subscriber);
	    }
	  }]);

	  return KinveyObservable;
	}(_Observable2.Observable);

/***/ },
/* 131 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var root_1 = __webpack_require__(132);
	var toSubscriber_1 = __webpack_require__(133);
	var observable_1 = __webpack_require__(144);
	/**
	 * A representation of any set of values over any amount of time. This the most basic building block
	 * of RxJS.
	 *
	 * @class Observable<T>
	 */
	var Observable = (function () {
	    /**
	     * @constructor
	     * @param {Function} subscribe the function that is  called when the Observable is
	     * initially subscribed to. This function is given a Subscriber, to which new values
	     * can be `next`ed, or an `error` method can be called to raise an error, or
	     * `complete` can be called to notify of a successful completion.
	     */
	    function Observable(subscribe) {
	        this._isScalar = false;
	        if (subscribe) {
	            this._subscribe = subscribe;
	        }
	    }
	    /**
	     * Creates a new Observable, with this Observable as the source, and the passed
	     * operator defined as the new observable's operator.
	     * @method lift
	     * @param {Operator} operator the operator defining the operation to take on the observable
	     * @return {Observable} a new observable with the Operator applied
	     */
	    Observable.prototype.lift = function (operator) {
	        var observable = new Observable();
	        observable.source = this;
	        observable.operator = operator;
	        return observable;
	    };
	    /**
	     * Registers handlers for handling emitted values, error and completions from the observable, and
	     *  executes the observable's subscriber function, which will take action to set up the underlying data stream
	     * @method subscribe
	     * @param {PartialObserver|Function} observerOrNext (optional) either an observer defining all functions to be called,
	     *  or the first of three possible handlers, which is the handler for each value emitted from the observable.
	     * @param {Function} error (optional) a handler for a terminal event resulting from an error. If no error handler is provided,
	     *  the error will be thrown as unhandled
	     * @param {Function} complete (optional) a handler for a terminal event resulting from successful completion.
	     * @return {ISubscription} a subscription reference to the registered handlers
	     */
	    Observable.prototype.subscribe = function (observerOrNext, error, complete) {
	        var operator = this.operator;
	        var sink = toSubscriber_1.toSubscriber(observerOrNext, error, complete);
	        if (operator) {
	            operator.call(sink, this);
	        }
	        else {
	            sink.add(this._subscribe(sink));
	        }
	        if (sink.syncErrorThrowable) {
	            sink.syncErrorThrowable = false;
	            if (sink.syncErrorThrown) {
	                throw sink.syncErrorValue;
	            }
	        }
	        return sink;
	    };
	    /**
	     * @method forEach
	     * @param {Function} next a handler for each value emitted by the observable
	     * @param {PromiseConstructor} [PromiseCtor] a constructor function used to instantiate the Promise
	     * @return {Promise} a promise that either resolves on observable completion or
	     *  rejects with the handled error
	     */
	    Observable.prototype.forEach = function (next, PromiseCtor) {
	        var _this = this;
	        if (!PromiseCtor) {
	            if (root_1.root.Rx && root_1.root.Rx.config && root_1.root.Rx.config.Promise) {
	                PromiseCtor = root_1.root.Rx.config.Promise;
	            }
	            else if (root_1.root.Promise) {
	                PromiseCtor = root_1.root.Promise;
	            }
	        }
	        if (!PromiseCtor) {
	            throw new Error('no Promise impl found');
	        }
	        return new PromiseCtor(function (resolve, reject) {
	            var subscription = _this.subscribe(function (value) {
	                if (subscription) {
	                    // if there is a subscription, then we can surmise
	                    // the next handling is asynchronous. Any errors thrown
	                    // need to be rejected explicitly and unsubscribe must be
	                    // called manually
	                    try {
	                        next(value);
	                    }
	                    catch (err) {
	                        reject(err);
	                        subscription.unsubscribe();
	                    }
	                }
	                else {
	                    // if there is NO subscription, then we're getting a nexted
	                    // value synchronously during subscription. We can just call it.
	                    // If it errors, Observable's `subscribe` will ensure the
	                    // unsubscription logic is called, then synchronously rethrow the error.
	                    // After that, Promise will trap the error and send it
	                    // down the rejection path.
	                    next(value);
	                }
	            }, reject, resolve);
	        });
	    };
	    Observable.prototype._subscribe = function (subscriber) {
	        return this.source.subscribe(subscriber);
	    };
	    /**
	     * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable
	     * @method Symbol.observable
	     * @return {Observable} this instance of the observable
	     */
	    Observable.prototype[observable_1.$$observable] = function () {
	        return this;
	    };
	    // HACK: Since TypeScript inherits static properties too, we have to
	    // fight against TypeScript here so Subject can have a different static create signature
	    /**
	     * Creates a new cold Observable by calling the Observable constructor
	     * @static true
	     * @owner Observable
	     * @method create
	     * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor
	     * @return {Observable} a new cold observable
	     */
	    Observable.create = function (subscribe) {
	        return new Observable(subscribe);
	    };
	    return Observable;
	}());
	exports.Observable = Observable;
	//# sourceMappingURL=Observable.js.map

/***/ },
/* 132 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {"use strict";
	var objectTypes = {
	    'boolean': false,
	    'function': true,
	    'object': true,
	    'number': false,
	    'string': false,
	    'undefined': false
	};
	exports.root = (objectTypes[typeof self] && self) || (objectTypes[typeof window] && window);
	var freeGlobal = objectTypes[typeof global] && global;
	if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
	    exports.root = freeGlobal;
	}
	//# sourceMappingURL=root.js.map
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 133 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Subscriber_1 = __webpack_require__(134);
	var rxSubscriber_1 = __webpack_require__(143);
	function toSubscriber(nextOrObserver, error, complete) {
	    if (nextOrObserver) {
	        if (nextOrObserver instanceof Subscriber_1.Subscriber) {
	            return nextOrObserver;
	        }
	        if (nextOrObserver[rxSubscriber_1.$$rxSubscriber]) {
	            return nextOrObserver[rxSubscriber_1.$$rxSubscriber]();
	        }
	    }
	    if (!nextOrObserver && !error && !complete) {
	        return new Subscriber_1.Subscriber();
	    }
	    return new Subscriber_1.Subscriber(nextOrObserver, error, complete);
	}
	exports.toSubscriber = toSubscriber;
	//# sourceMappingURL=toSubscriber.js.map

/***/ },
/* 134 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var isFunction_1 = __webpack_require__(135);
	var Subscription_1 = __webpack_require__(136);
	var Observer_1 = __webpack_require__(142);
	var rxSubscriber_1 = __webpack_require__(143);
	/**
	 * Implements the {@link Observer} interface and extends the
	 * {@link Subscription} class. While the {@link Observer} is the public API for
	 * consuming the values of an {@link Observable}, all Observers get converted to
	 * a Subscriber, in order to provide Subscription-like capabilities such as
	 * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for
	 * implementing operators, but it is rarely used as a public API.
	 *
	 * @class Subscriber<T>
	 */
	var Subscriber = (function (_super) {
	    __extends(Subscriber, _super);
	    /**
	     * @param {Observer|function(value: T): void} [destinationOrNext] A partially
	     * defined Observer or a `next` callback function.
	     * @param {function(e: ?any): void} [error] The `error` callback of an
	     * Observer.
	     * @param {function(): void} [complete] The `complete` callback of an
	     * Observer.
	     */
	    function Subscriber(destinationOrNext, error, complete) {
	        _super.call(this);
	        this.syncErrorValue = null;
	        this.syncErrorThrown = false;
	        this.syncErrorThrowable = false;
	        this.isStopped = false;
	        switch (arguments.length) {
	            case 0:
	                this.destination = Observer_1.empty;
	                break;
	            case 1:
	                if (!destinationOrNext) {
	                    this.destination = Observer_1.empty;
	                    break;
	                }
	                if (typeof destinationOrNext === 'object') {
	                    if (destinationOrNext instanceof Subscriber) {
	                        this.destination = destinationOrNext;
	                        this.destination.add(this);
	                    }
	                    else {
	                        this.syncErrorThrowable = true;
	                        this.destination = new SafeSubscriber(this, destinationOrNext);
	                    }
	                    break;
	                }
	            default:
	                this.syncErrorThrowable = true;
	                this.destination = new SafeSubscriber(this, destinationOrNext, error, complete);
	                break;
	        }
	    }
	    Subscriber.prototype[rxSubscriber_1.$$rxSubscriber] = function () { return this; };
	    /**
	     * A static factory for a Subscriber, given a (potentially partial) definition
	     * of an Observer.
	     * @param {function(x: ?T): void} [next] The `next` callback of an Observer.
	     * @param {function(e: ?any): void} [error] The `error` callback of an
	     * Observer.
	     * @param {function(): void} [complete] The `complete` callback of an
	     * Observer.
	     * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)
	     * Observer represented by the given arguments.
	     */
	    Subscriber.create = function (next, error, complete) {
	        var subscriber = new Subscriber(next, error, complete);
	        subscriber.syncErrorThrowable = false;
	        return subscriber;
	    };
	    /**
	     * The {@link Observer} callback to receive notifications of type `next` from
	     * the Observable, with a value. The Observable may call this method 0 or more
	     * times.
	     * @param {T} [value] The `next` value.
	     * @return {void}
	     */
	    Subscriber.prototype.next = function (value) {
	        if (!this.isStopped) {
	            this._next(value);
	        }
	    };
	    /**
	     * The {@link Observer} callback to receive notifications of type `error` from
	     * the Observable, with an attached {@link Error}. Notifies the Observer that
	     * the Observable has experienced an error condition.
	     * @param {any} [err] The `error` exception.
	     * @return {void}
	     */
	    Subscriber.prototype.error = function (err) {
	        if (!this.isStopped) {
	            this.isStopped = true;
	            this._error(err);
	        }
	    };
	    /**
	     * The {@link Observer} callback to receive a valueless notification of type
	     * `complete` from the Observable. Notifies the Observer that the Observable
	     * has finished sending push-based notifications.
	     * @return {void}
	     */
	    Subscriber.prototype.complete = function () {
	        if (!this.isStopped) {
	            this.isStopped = true;
	            this._complete();
	        }
	    };
	    Subscriber.prototype.unsubscribe = function () {
	        if (this.closed) {
	            return;
	        }
	        this.isStopped = true;
	        _super.prototype.unsubscribe.call(this);
	    };
	    Subscriber.prototype._next = function (value) {
	        this.destination.next(value);
	    };
	    Subscriber.prototype._error = function (err) {
	        this.destination.error(err);
	        this.unsubscribe();
	    };
	    Subscriber.prototype._complete = function () {
	        this.destination.complete();
	        this.unsubscribe();
	    };
	    return Subscriber;
	}(Subscription_1.Subscription));
	exports.Subscriber = Subscriber;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var SafeSubscriber = (function (_super) {
	    __extends(SafeSubscriber, _super);
	    function SafeSubscriber(_parent, observerOrNext, error, complete) {
	        _super.call(this);
	        this._parent = _parent;
	        var next;
	        var context = this;
	        if (isFunction_1.isFunction(observerOrNext)) {
	            next = observerOrNext;
	        }
	        else if (observerOrNext) {
	            context = observerOrNext;
	            next = observerOrNext.next;
	            error = observerOrNext.error;
	            complete = observerOrNext.complete;
	            if (isFunction_1.isFunction(context.unsubscribe)) {
	                this.add(context.unsubscribe.bind(context));
	            }
	            context.unsubscribe = this.unsubscribe.bind(this);
	        }
	        this._context = context;
	        this._next = next;
	        this._error = error;
	        this._complete = complete;
	    }
	    SafeSubscriber.prototype.next = function (value) {
	        if (!this.isStopped && this._next) {
	            var _parent = this._parent;
	            if (!_parent.syncErrorThrowable) {
	                this.__tryOrUnsub(this._next, value);
	            }
	            else if (this.__tryOrSetError(_parent, this._next, value)) {
	                this.unsubscribe();
	            }
	        }
	    };
	    SafeSubscriber.prototype.error = function (err) {
	        if (!this.isStopped) {
	            var _parent = this._parent;
	            if (this._error) {
	                if (!_parent.syncErrorThrowable) {
	                    this.__tryOrUnsub(this._error, err);
	                    this.unsubscribe();
	                }
	                else {
	                    this.__tryOrSetError(_parent, this._error, err);
	                    this.unsubscribe();
	                }
	            }
	            else if (!_parent.syncErrorThrowable) {
	                this.unsubscribe();
	                throw err;
	            }
	            else {
	                _parent.syncErrorValue = err;
	                _parent.syncErrorThrown = true;
	                this.unsubscribe();
	            }
	        }
	    };
	    SafeSubscriber.prototype.complete = function () {
	        if (!this.isStopped) {
	            var _parent = this._parent;
	            if (this._complete) {
	                if (!_parent.syncErrorThrowable) {
	                    this.__tryOrUnsub(this._complete);
	                    this.unsubscribe();
	                }
	                else {
	                    this.__tryOrSetError(_parent, this._complete);
	                    this.unsubscribe();
	                }
	            }
	            else {
	                this.unsubscribe();
	            }
	        }
	    };
	    SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {
	        try {
	            fn.call(this._context, value);
	        }
	        catch (err) {
	            this.unsubscribe();
	            throw err;
	        }
	    };
	    SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {
	        try {
	            fn.call(this._context, value);
	        }
	        catch (err) {
	            parent.syncErrorValue = err;
	            parent.syncErrorThrown = true;
	            return true;
	        }
	        return false;
	    };
	    SafeSubscriber.prototype._unsubscribe = function () {
	        var _parent = this._parent;
	        this._context = null;
	        this._parent = null;
	        _parent.unsubscribe();
	    };
	    return SafeSubscriber;
	}(Subscriber));
	//# sourceMappingURL=Subscriber.js.map

/***/ },
/* 135 */
/***/ function(module, exports) {

	"use strict";
	function isFunction(x) {
	    return typeof x === 'function';
	}
	exports.isFunction = isFunction;
	//# sourceMappingURL=isFunction.js.map

/***/ },
/* 136 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var isArray_1 = __webpack_require__(137);
	var isObject_1 = __webpack_require__(138);
	var isFunction_1 = __webpack_require__(135);
	var tryCatch_1 = __webpack_require__(139);
	var errorObject_1 = __webpack_require__(140);
	var UnsubscriptionError_1 = __webpack_require__(141);
	/**
	 * Represents a disposable resource, such as the execution of an Observable. A
	 * Subscription has one important method, `unsubscribe`, that takes no argument
	 * and just disposes the resource held by the subscription.
	 *
	 * Additionally, subscriptions may be grouped together through the `add()`
	 * method, which will attach a child Subscription to the current Subscription.
	 * When a Subscription is unsubscribed, all its children (and its grandchildren)
	 * will be unsubscribed as well.
	 *
	 * @class Subscription
	 */
	var Subscription = (function () {
	    /**
	     * @param {function(): void} [unsubscribe] A function describing how to
	     * perform the disposal of resources when the `unsubscribe` method is called.
	     */
	    function Subscription(unsubscribe) {
	        /**
	         * A flag to indicate whether this Subscription has already been unsubscribed.
	         * @type {boolean}
	         */
	        this.closed = false;
	        if (unsubscribe) {
	            this._unsubscribe = unsubscribe;
	        }
	    }
	    /**
	     * Disposes the resources held by the subscription. May, for instance, cancel
	     * an ongoing Observable execution or cancel any other type of work that
	     * started when the Subscription was created.
	     * @return {void}
	     */
	    Subscription.prototype.unsubscribe = function () {
	        var hasErrors = false;
	        var errors;
	        if (this.closed) {
	            return;
	        }
	        this.closed = true;
	        var _a = this, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;
	        this._subscriptions = null;
	        if (isFunction_1.isFunction(_unsubscribe)) {
	            var trial = tryCatch_1.tryCatch(_unsubscribe).call(this);
	            if (trial === errorObject_1.errorObject) {
	                hasErrors = true;
	                (errors = errors || []).push(errorObject_1.errorObject.e);
	            }
	        }
	        if (isArray_1.isArray(_subscriptions)) {
	            var index = -1;
	            var len = _subscriptions.length;
	            while (++index < len) {
	                var sub = _subscriptions[index];
	                if (isObject_1.isObject(sub)) {
	                    var trial = tryCatch_1.tryCatch(sub.unsubscribe).call(sub);
	                    if (trial === errorObject_1.errorObject) {
	                        hasErrors = true;
	                        errors = errors || [];
	                        var err = errorObject_1.errorObject.e;
	                        if (err instanceof UnsubscriptionError_1.UnsubscriptionError) {
	                            errors = errors.concat(err.errors);
	                        }
	                        else {
	                            errors.push(err);
	                        }
	                    }
	                }
	            }
	        }
	        if (hasErrors) {
	            throw new UnsubscriptionError_1.UnsubscriptionError(errors);
	        }
	    };
	    /**
	     * Adds a tear down to be called during the unsubscribe() of this
	     * Subscription.
	     *
	     * If the tear down being added is a subscription that is already
	     * unsubscribed, is the same reference `add` is being called on, or is
	     * `Subscription.EMPTY`, it will not be added.
	     *
	     * If this subscription is already in an `closed` state, the passed
	     * tear down logic will be executed immediately.
	     *
	     * @param {TeardownLogic} teardown The additional logic to execute on
	     * teardown.
	     * @return {Subscription} Returns the Subscription used or created to be
	     * added to the inner subscriptions list. This Subscription can be used with
	     * `remove()` to remove the passed teardown logic from the inner subscriptions
	     * list.
	     */
	    Subscription.prototype.add = function (teardown) {
	        if (!teardown || (teardown === Subscription.EMPTY)) {
	            return Subscription.EMPTY;
	        }
	        if (teardown === this) {
	            return this;
	        }
	        var sub = teardown;
	        switch (typeof teardown) {
	            case 'function':
	                sub = new Subscription(teardown);
	            case 'object':
	                if (sub.closed || typeof sub.unsubscribe !== 'function') {
	                    break;
	                }
	                else if (this.closed) {
	                    sub.unsubscribe();
	                }
	                else {
	                    (this._subscriptions || (this._subscriptions = [])).push(sub);
	                }
	                break;
	            default:
	                throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');
	        }
	        return sub;
	    };
	    /**
	     * Removes a Subscription from the internal list of subscriptions that will
	     * unsubscribe during the unsubscribe process of this Subscription.
	     * @param {Subscription} subscription The subscription to remove.
	     * @return {void}
	     */
	    Subscription.prototype.remove = function (subscription) {
	        // HACK: This might be redundant because of the logic in `add()`
	        if (subscription == null || (subscription === this) || (subscription === Subscription.EMPTY)) {
	            return;
	        }
	        var subscriptions = this._subscriptions;
	        if (subscriptions) {
	            var subscriptionIndex = subscriptions.indexOf(subscription);
	            if (subscriptionIndex !== -1) {
	                subscriptions.splice(subscriptionIndex, 1);
	            }
	        }
	    };
	    Subscription.EMPTY = (function (empty) {
	        empty.closed = true;
	        return empty;
	    }(new Subscription()));
	    return Subscription;
	}());
	exports.Subscription = Subscription;
	//# sourceMappingURL=Subscription.js.map

/***/ },
/* 137 */
/***/ function(module, exports) {

	"use strict";
	exports.isArray = Array.isArray || (function (x) { return x && typeof x.length === 'number'; });
	//# sourceMappingURL=isArray.js.map

/***/ },
/* 138 */
/***/ function(module, exports) {

	"use strict";
	function isObject(x) {
	    return x != null && typeof x === 'object';
	}
	exports.isObject = isObject;
	//# sourceMappingURL=isObject.js.map

/***/ },
/* 139 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var errorObject_1 = __webpack_require__(140);
	var tryCatchTarget;
	function tryCatcher() {
	    try {
	        return tryCatchTarget.apply(this, arguments);
	    }
	    catch (e) {
	        errorObject_1.errorObject.e = e;
	        return errorObject_1.errorObject;
	    }
	}
	function tryCatch(fn) {
	    tryCatchTarget = fn;
	    return tryCatcher;
	}
	exports.tryCatch = tryCatch;
	;
	//# sourceMappingURL=tryCatch.js.map

/***/ },
/* 140 */
/***/ function(module, exports) {

	"use strict";
	// typeof any so that it we don't have to cast when comparing a result to the error object
	exports.errorObject = { e: {} };
	//# sourceMappingURL=errorObject.js.map

/***/ },
/* 141 */
/***/ function(module, exports) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/**
	 * An error thrown when one or more errors have occurred during the
	 * `unsubscribe` of a {@link Subscription}.
	 */
	var UnsubscriptionError = (function (_super) {
	    __extends(UnsubscriptionError, _super);
	    function UnsubscriptionError(errors) {
	        _super.call(this);
	        this.errors = errors;
	        var err = Error.call(this, errors ?
	            errors.length + " errors occurred during unsubscription:\n  " + errors.map(function (err, i) { return ((i + 1) + ") " + err.toString()); }).join('\n  ') : '');
	        this.name = err.name = 'UnsubscriptionError';
	        this.stack = err.stack;
	        this.message = err.message;
	    }
	    return UnsubscriptionError;
	}(Error));
	exports.UnsubscriptionError = UnsubscriptionError;
	//# sourceMappingURL=UnsubscriptionError.js.map

/***/ },
/* 142 */
/***/ function(module, exports) {

	"use strict";
	exports.empty = {
	    closed: true,
	    next: function (value) { },
	    error: function (err) { throw err; },
	    complete: function () { }
	};
	//# sourceMappingURL=Observer.js.map

/***/ },
/* 143 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var root_1 = __webpack_require__(132);
	var Symbol = root_1.root.Symbol;
	exports.$$rxSubscriber = (typeof Symbol === 'function' && typeof Symbol.for === 'function') ?
	    Symbol.for('rxSubscriber') : '@@rxSubscriber';
	//# sourceMappingURL=rxSubscriber.js.map

/***/ },
/* 144 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var root_1 = __webpack_require__(132);
	function getSymbolObservable(context) {
	    var $$observable;
	    var Symbol = context.Symbol;
	    if (typeof Symbol === 'function') {
	        if (Symbol.observable) {
	            $$observable = Symbol.observable;
	        }
	        else {
	            $$observable = Symbol('observable');
	            Symbol.observable = $$observable;
	        }
	    }
	    else {
	        $$observable = '@@observable';
	    }
	    return $$observable;
	}
	exports.getSymbolObservable = getSymbolObservable;
	exports.$$observable = getSymbolObservable(root_1.root);
	//# sourceMappingURL=observable.js.map

/***/ },
/* 145 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var root_1 = __webpack_require__(132);
	/**
	 * @param PromiseCtor
	 * @return {Promise<T>}
	 * @method toPromise
	 * @owner Observable
	 */
	function toPromise(PromiseCtor) {
	    var _this = this;
	    if (!PromiseCtor) {
	        if (root_1.root.Rx && root_1.root.Rx.config && root_1.root.Rx.config.Promise) {
	            PromiseCtor = root_1.root.Rx.config.Promise;
	        }
	        else if (root_1.root.Promise) {
	            PromiseCtor = root_1.root.Promise;
	        }
	    }
	    if (!PromiseCtor) {
	        throw new Error('no Promise impl found');
	    }
	    return new PromiseCtor(function (resolve, reject) {
	        var value;
	        _this.subscribe(function (x) { return value = x; }, function (err) { return reject(err); }, function () { return resolve(value); });
	    });
	}
	exports.toPromise = toPromise;
	//# sourceMappingURL=toPromise.js.map

/***/ },
/* 146 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Popup = undefined;

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _device = __webpack_require__(14);

	var _events = __webpack_require__(147);

	var _regeneratorRuntime = __webpack_require__(148);

	var _regeneratorRuntime2 = _interopRequireDefault(_regeneratorRuntime);

	var _bind = __webpack_require__(150);

	var _bind2 = _interopRequireDefault(_bind);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { return step("next", value); }, function (err) { return step("throw", err); }); } } return step("next"); }); }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // eslint-disable-line no-unused-vars


	var Popup = exports.Popup = function (_EventEmitter) {
	  _inherits(Popup, _EventEmitter);

	  function Popup() {
	    _classCallCheck(this, Popup);

	    return _possibleConstructorReturn(this, (Popup.__proto__ || Object.getPrototypeOf(Popup)).apply(this, arguments));
	  }

	  _createClass(Popup, [{
	    key: 'open',
	    value: function () {
	      var _ref = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee() {
	        var url = arguments.length <= 0 || arguments[0] === undefined ? '/' : arguments[0];
	        var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	        var interval, eventListeners, popupWindow, titaniumWebView, titaniumCloseButton, clickHandler, loadStartCallback, loadStopCallback, loadErrorCallback, exitCallback, _titaniumWebView, tiWindow;

	        return _regeneratorRuntime2.default.wrap(function _callee$(_context) {
	          while (1) {
	            switch (_context.prev = _context.next) {
	              case 0:
	                exitCallback = function exitCallback() {
	                  // Clear the interval
	                  clearInterval(interval);

	                  // Close the popup
	                  popupWindow.close();

	                  // Remove event listeners
	                  if (popupWindow) {
	                    popupWindow.removeEventListener('loadstart', eventListeners.loadStopCallback);
	                    popupWindow.removeEventListener('loadstop', eventListeners.loadStopCallback);
	                    popupWindow.removeEventListener('loaderror', eventListeners.loadErrorCallback);
	                    popupWindow.removeEventListener('close', eventListeners.exitCallback);
	                    popupWindow.removeEventListener('androidback', eventListeners.exitCallback);
	                    popupWindow.removeEventListener('exit', eventListeners.exitCallback);
	                  }

	                  if (titaniumWebView) {
	                    titaniumWebView.removeEventListener('load', eventListeners.loadHandler);
	                    titaniumWebView.removeEventListener('error', eventListeners.loadHandler);
	                  }

	                  if (titaniumCloseButton) {
	                    titaniumCloseButton.removeEventListener('click', eventListeners.clickHandler);
	                  }

	                  // Emit closed
	                  this.emit('closed');
	                };

	                loadErrorCallback = function loadErrorCallback(event) {
	                  this.emit('error', event);
	                };

	                loadStopCallback = function loadStopCallback(event) {
	                  this.emit('loadstop', event);
	                };

	                loadStartCallback = function loadStartCallback(event) {
	                  this.emit('loadstart', event);
	                };

	                clickHandler = function clickHandler() {
	                  popupWindow.close();
	                };

	                interval = void 0;
	                eventListeners = void 0;
	                popupWindow = void 0;
	                titaniumWebView = void 0;
	                titaniumCloseButton = void 0;

	                // Wait for the device to be ready if this is a Cordova environment

	                if (!global.cordova) {
	                  _context.next = 15;
	                  break;
	                }

	                _context.next = 13;
	                return _device.Device.ready();

	              case 13:
	                if (global.cordova.InAppBrowser) {
	                  _context.next = 15;
	                  break;
	                }

	                throw new Error('Cordova InAppBrowser Plugin is not installed.' + ' Please refer to https://cordova.apache.org/docs/en/latest/reference/cordova-plugin-inappbrowser/ for help with' + ' installing the InAppBrowser plugin.');

	              case 15:

	                // Bind event listeners
	                eventListeners = {
	                  clickHandler: (0, _bind2.default)(clickHandler, this),
	                  loadStartCallback: (0, _bind2.default)(loadStartCallback, this),
	                  loadStopCallback: (0, _bind2.default)(loadStopCallback, this),
	                  loadErrorCallback: (0, _bind2.default)(loadErrorCallback, this),
	                  exitCallback: (0, _bind2.default)(exitCallback, this)
	                };

	                // Create popup window for Titanium

	                if (!(global.Titanium !== 'undefined' && global.Titanium.UI !== 'undefined')) {
	                  _context.next = 27;
	                  break;
	                }

	                _titaniumWebView = global.Titanium.UI.createWebView({
	                  width: '100%',
	                  height: '100%',
	                  url: url
	                });

	                _titaniumWebView.addEventListener('load', eventListeners.loadStopCallback);
	                _titaniumWebView.addEventListener('error', eventListeners.loadErrorCallback);

	                popupWindow = global.Titanium.UI.createWindow({
	                  backgroundColor: 'white',
	                  barColor: '#000',
	                  title: options.title || 'Kinvey Mobile Identity Connect',
	                  modal: true
	                });
	                popupWindow.add(_titaniumWebView);

	                if (global.Titanium.Platform.osname === 'iphone' || global.Titanium.Platform.osname === 'ipad') {
	                  tiWindow = global.Titanium.UI.createWindow({
	                    backgroundColor: 'white',
	                    barColor: '#e3e3e3',
	                    title: options.title || 'Kinvey Mobile Identity Connect'
	                  });

	                  tiWindow.add(_titaniumWebView);

	                  titaniumCloseButton = global.Titanium.UI.createButton({
	                    title: 'Close',
	                    style: global.Titanium.UI.iPhone.SystemButtonStyle.DONE
	                  });
	                  tiWindow.setLeftNavButton(titaniumCloseButton);
	                  titaniumCloseButton.addEventListener('click', eventListeners.clickHandler);

	                  popupWindow = global.Titanium.UI.iOS.createNavigationWindow({
	                    backgroundColor: 'white',
	                    window: tiWindow,
	                    modal: true
	                  });
	                } else if (global.Titanium.Platform.osname === 'android') {
	                  popupWindow.addEventListener('androidback', eventListeners.exitCallback);
	                }

	                // Open the popup
	                popupWindow.addEventListener('close', eventListeners.exitCallback);
	                popupWindow.open();
	                _context.next = 38;
	                break;

	              case 27:
	                // Open the popup
	                popupWindow = global.open(url, '_blank', 'location=yes');

	                if (!popupWindow) {
	                  _context.next = 38;
	                  break;
	                }

	                popupWindow.addEventListener('loadstart', eventListeners.loadStartCallback);
	                popupWindow.addEventListener('loadstop', eventListeners.loadStopCallback);
	                popupWindow.addEventListener('loaderror', eventListeners.loadErrorCallback);
	                popupWindow.addEventListener('exit', eventListeners.exitCallback);

	                // Check if the popup is closed has closed every 100ms

	                if (global.cordova) {
	                  _context.next = 37;
	                  break;
	                }

	                interval = setInterval(function () {
	                  if (popupWindow.closed) {
	                    eventListeners.exitCallback();
	                  } else {
	                    try {
	                      eventListeners.loadStopCallback({
	                        url: popupWindow.location.href
	                      });
	                    } catch (error) {
	                      eventListeners.loadErrorCallback({
	                        error: error
	                      });
	                    }
	                  }
	                }, 100);
	                _context.next = 38;
	                break;

	              case 37:
	                throw new Error('The popup was blocked.');

	              case 38:
	                return _context.abrupt('return', popupWindow);

	              case 39:
	              case 'end':
	                return _context.stop();
	            }
	          }
	        }, _callee, this);
	      }));

	      function open(_x, _x2) {
	        return _ref.apply(this, arguments);
	      }

	      return open;
	    }()
	  }]);

	  return Popup;
	}(_events.EventEmitter);
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 147 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(console) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	function EventEmitter() {
	  this._events = this._events || {};
	  this._maxListeners = this._maxListeners || undefined;
	}
	module.exports = EventEmitter;

	// Backwards-compat with node 0.10.x
	EventEmitter.EventEmitter = EventEmitter;

	EventEmitter.prototype._events = undefined;
	EventEmitter.prototype._maxListeners = undefined;

	// By default EventEmitters will print a warning if more than 10 listeners are
	// added to it. This is a useful default which helps finding memory leaks.
	EventEmitter.defaultMaxListeners = 10;

	// Obviously not all Emitters should be limited to 10. This function allows
	// that to be increased. Set to zero for unlimited.
	EventEmitter.prototype.setMaxListeners = function(n) {
	  if (!isNumber(n) || n < 0 || isNaN(n))
	    throw TypeError('n must be a positive number');
	  this._maxListeners = n;
	  return this;
	};

	EventEmitter.prototype.emit = function(type) {
	  var er, handler, len, args, i, listeners;

	  if (!this._events)
	    this._events = {};

	  // If there is no 'error' event listener then throw.
	  if (type === 'error') {
	    if (!this._events.error ||
	        (isObject(this._events.error) && !this._events.error.length)) {
	      er = arguments[1];
	      if (er instanceof Error) {
	        throw er; // Unhandled 'error' event
	      } else {
	        // At least give some kind of context to the user
	        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
	        err.context = er;
	        throw err;
	      }
	    }
	  }

	  handler = this._events[type];

	  if (isUndefined(handler))
	    return false;

	  if (isFunction(handler)) {
	    switch (arguments.length) {
	      // fast cases
	      case 1:
	        handler.call(this);
	        break;
	      case 2:
	        handler.call(this, arguments[1]);
	        break;
	      case 3:
	        handler.call(this, arguments[1], arguments[2]);
	        break;
	      // slower
	      default:
	        args = Array.prototype.slice.call(arguments, 1);
	        handler.apply(this, args);
	    }
	  } else if (isObject(handler)) {
	    args = Array.prototype.slice.call(arguments, 1);
	    listeners = handler.slice();
	    len = listeners.length;
	    for (i = 0; i < len; i++)
	      listeners[i].apply(this, args);
	  }

	  return true;
	};

	EventEmitter.prototype.addListener = function(type, listener) {
	  var m;

	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');

	  if (!this._events)
	    this._events = {};

	  // To avoid recursion in the case that type === "newListener"! Before
	  // adding it to the listeners, first emit "newListener".
	  if (this._events.newListener)
	    this.emit('newListener', type,
	              isFunction(listener.listener) ?
	              listener.listener : listener);

	  if (!this._events[type])
	    // Optimize the case of one listener. Don't need the extra array object.
	    this._events[type] = listener;
	  else if (isObject(this._events[type]))
	    // If we've already got an array, just append.
	    this._events[type].push(listener);
	  else
	    // Adding the second element, need to change to array.
	    this._events[type] = [this._events[type], listener];

	  // Check for listener leak
	  if (isObject(this._events[type]) && !this._events[type].warned) {
	    if (!isUndefined(this._maxListeners)) {
	      m = this._maxListeners;
	    } else {
	      m = EventEmitter.defaultMaxListeners;
	    }

	    if (m && m > 0 && this._events[type].length > m) {
	      this._events[type].warned = true;
	      console.error('(node) warning: possible EventEmitter memory ' +
	                    'leak detected. %d listeners added. ' +
	                    'Use emitter.setMaxListeners() to increase limit.',
	                    this._events[type].length);
	      if (typeof console.trace === 'function') {
	        // not supported in IE 10
	        console.trace();
	      }
	    }
	  }

	  return this;
	};

	EventEmitter.prototype.on = EventEmitter.prototype.addListener;

	EventEmitter.prototype.once = function(type, listener) {
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');

	  var fired = false;

	  function g() {
	    this.removeListener(type, g);

	    if (!fired) {
	      fired = true;
	      listener.apply(this, arguments);
	    }
	  }

	  g.listener = listener;
	  this.on(type, g);

	  return this;
	};

	// emits a 'removeListener' event iff the listener was removed
	EventEmitter.prototype.removeListener = function(type, listener) {
	  var list, position, length, i;

	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');

	  if (!this._events || !this._events[type])
	    return this;

	  list = this._events[type];
	  length = list.length;
	  position = -1;

	  if (list === listener ||
	      (isFunction(list.listener) && list.listener === listener)) {
	    delete this._events[type];
	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);

	  } else if (isObject(list)) {
	    for (i = length; i-- > 0;) {
	      if (list[i] === listener ||
	          (list[i].listener && list[i].listener === listener)) {
	        position = i;
	        break;
	      }
	    }

	    if (position < 0)
	      return this;

	    if (list.length === 1) {
	      list.length = 0;
	      delete this._events[type];
	    } else {
	      list.splice(position, 1);
	    }

	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);
	  }

	  return this;
	};

	EventEmitter.prototype.removeAllListeners = function(type) {
	  var key, listeners;

	  if (!this._events)
	    return this;

	  // not listening for removeListener, no need to emit
	  if (!this._events.removeListener) {
	    if (arguments.length === 0)
	      this._events = {};
	    else if (this._events[type])
	      delete this._events[type];
	    return this;
	  }

	  // emit removeListener for all listeners on all events
	  if (arguments.length === 0) {
	    for (key in this._events) {
	      if (key === 'removeListener') continue;
	      this.removeAllListeners(key);
	    }
	    this.removeAllListeners('removeListener');
	    this._events = {};
	    return this;
	  }

	  listeners = this._events[type];

	  if (isFunction(listeners)) {
	    this.removeListener(type, listeners);
	  } else if (listeners) {
	    // LIFO order
	    while (listeners.length)
	      this.removeListener(type, listeners[listeners.length - 1]);
	  }
	  delete this._events[type];

	  return this;
	};

	EventEmitter.prototype.listeners = function(type) {
	  var ret;
	  if (!this._events || !this._events[type])
	    ret = [];
	  else if (isFunction(this._events[type]))
	    ret = [this._events[type]];
	  else
	    ret = this._events[type].slice();
	  return ret;
	};

	EventEmitter.prototype.listenerCount = function(type) {
	  if (this._events) {
	    var evlistener = this._events[type];

	    if (isFunction(evlistener))
	      return 1;
	    else if (evlistener)
	      return evlistener.length;
	  }
	  return 0;
	};

	EventEmitter.listenerCount = function(emitter, type) {
	  return emitter.listenerCount(type);
	};

	function isFunction(arg) {
	  return typeof arg === 'function';
	}

	function isNumber(arg) {
	  return typeof arg === 'number';
	}

	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}

	function isUndefined(arg) {
	  return arg === void 0;
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 148 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {// This method of obtaining a reference to the global object needs to be
	// kept identical to the way it is obtained in runtime.js
	var g =
	  typeof global === "object" ? global :
	  typeof window === "object" ? window :
	  typeof self === "object" ? self : this;

	// Use `getOwnPropertyNames` because not all browsers support calling
	// `hasOwnProperty` on the global `self` object in a worker. See #183.
	var hadRuntime = g.regeneratorRuntime &&
	  Object.getOwnPropertyNames(g).indexOf("regeneratorRuntime") >= 0;

	// Save the old regeneratorRuntime in case it needs to be restored later.
	var oldRuntime = hadRuntime && g.regeneratorRuntime;

	// Force reevalutation of runtime.js.
	g.regeneratorRuntime = undefined;

	module.exports = __webpack_require__(149);

	if (hadRuntime) {
	  // Restore the original runtime.
	  g.regeneratorRuntime = oldRuntime;
	} else {
	  // Remove the global property added by runtime.js.
	  try {
	    delete g.regeneratorRuntime;
	  } catch(e) {
	    g.regeneratorRuntime = undefined;
	  }
	}

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 149 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process) {/**
	 * Copyright (c) 2014, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
	 * additional grant of patent rights can be found in the PATENTS file in
	 * the same directory.
	 */

	!(function(global) {
	  "use strict";

	  var hasOwn = Object.prototype.hasOwnProperty;
	  var undefined; // More compressible than void 0.
	  var $Symbol = typeof Symbol === "function" ? Symbol : {};
	  var iteratorSymbol = $Symbol.iterator || "@@iterator";
	  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

	  var inModule = typeof module === "object";
	  var runtime = global.regeneratorRuntime;
	  if (runtime) {
	    if (inModule) {
	      // If regeneratorRuntime is defined globally and we're in a module,
	      // make the exports object identical to regeneratorRuntime.
	      module.exports = runtime;
	    }
	    // Don't bother evaluating the rest of this file if the runtime was
	    // already defined globally.
	    return;
	  }

	  // Define the runtime globally (as expected by generated code) as either
	  // module.exports (if we're in a module) or a new, empty object.
	  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

	  function wrap(innerFn, outerFn, self, tryLocsList) {
	    // If outerFn provided, then outerFn.prototype instanceof Generator.
	    var generator = Object.create((outerFn || Generator).prototype);
	    var context = new Context(tryLocsList || []);

	    // The ._invoke method unifies the implementations of the .next,
	    // .throw, and .return methods.
	    generator._invoke = makeInvokeMethod(innerFn, self, context);

	    return generator;
	  }
	  runtime.wrap = wrap;

	  // Try/catch helper to minimize deoptimizations. Returns a completion
	  // record like context.tryEntries[i].completion. This interface could
	  // have been (and was previously) designed to take a closure to be
	  // invoked without arguments, but in all the cases we care about we
	  // already have an existing method we want to call, so there's no need
	  // to create a new function object. We can even get away with assuming
	  // the method takes exactly one argument, since that happens to be true
	  // in every case, so we don't have to touch the arguments object. The
	  // only additional allocation required is the completion record, which
	  // has a stable shape and so hopefully should be cheap to allocate.
	  function tryCatch(fn, obj, arg) {
	    try {
	      return { type: "normal", arg: fn.call(obj, arg) };
	    } catch (err) {
	      return { type: "throw", arg: err };
	    }
	  }

	  var GenStateSuspendedStart = "suspendedStart";
	  var GenStateSuspendedYield = "suspendedYield";
	  var GenStateExecuting = "executing";
	  var GenStateCompleted = "completed";

	  // Returning this object from the innerFn has the same effect as
	  // breaking out of the dispatch switch statement.
	  var ContinueSentinel = {};

	  // Dummy constructor functions that we use as the .constructor and
	  // .constructor.prototype properties for functions that return Generator
	  // objects. For full spec compliance, you may wish to configure your
	  // minifier not to mangle the names of these two functions.
	  function Generator() {}
	  function GeneratorFunction() {}
	  function GeneratorFunctionPrototype() {}

	  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype;
	  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
	  GeneratorFunctionPrototype.constructor = GeneratorFunction;
	  GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = "GeneratorFunction";

	  // Helper for defining the .next, .throw, and .return methods of the
	  // Iterator interface in terms of a single ._invoke method.
	  function defineIteratorMethods(prototype) {
	    ["next", "throw", "return"].forEach(function(method) {
	      prototype[method] = function(arg) {
	        return this._invoke(method, arg);
	      };
	    });
	  }

	  runtime.isGeneratorFunction = function(genFun) {
	    var ctor = typeof genFun === "function" && genFun.constructor;
	    return ctor
	      ? ctor === GeneratorFunction ||
	        // For the native GeneratorFunction constructor, the best we can
	        // do is to check its .name property.
	        (ctor.displayName || ctor.name) === "GeneratorFunction"
	      : false;
	  };

	  runtime.mark = function(genFun) {
	    if (Object.setPrototypeOf) {
	      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
	    } else {
	      genFun.__proto__ = GeneratorFunctionPrototype;
	      if (!(toStringTagSymbol in genFun)) {
	        genFun[toStringTagSymbol] = "GeneratorFunction";
	      }
	    }
	    genFun.prototype = Object.create(Gp);
	    return genFun;
	  };

	  // Within the body of any async function, `await x` is transformed to
	  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
	  // `value instanceof AwaitArgument` to determine if the yielded value is
	  // meant to be awaited. Some may consider the name of this method too
	  // cutesy, but they are curmudgeons.
	  runtime.awrap = function(arg) {
	    return new AwaitArgument(arg);
	  };

	  function AwaitArgument(arg) {
	    this.arg = arg;
	  }

	  function AsyncIterator(generator) {
	    function invoke(method, arg, resolve, reject) {
	      var record = tryCatch(generator[method], generator, arg);
	      if (record.type === "throw") {
	        reject(record.arg);
	      } else {
	        var result = record.arg;
	        var value = result.value;
	        if (value instanceof AwaitArgument) {
	          return Promise.resolve(value.arg).then(function(value) {
	            invoke("next", value, resolve, reject);
	          }, function(err) {
	            invoke("throw", err, resolve, reject);
	          });
	        }

	        return Promise.resolve(value).then(function(unwrapped) {
	          // When a yielded Promise is resolved, its final value becomes
	          // the .value of the Promise<{value,done}> result for the
	          // current iteration. If the Promise is rejected, however, the
	          // result for this iteration will be rejected with the same
	          // reason. Note that rejections of yielded Promises are not
	          // thrown back into the generator function, as is the case
	          // when an awaited Promise is rejected. This difference in
	          // behavior between yield and await is important, because it
	          // allows the consumer to decide what to do with the yielded
	          // rejection (swallow it and continue, manually .throw it back
	          // into the generator, abandon iteration, whatever). With
	          // await, by contrast, there is no opportunity to examine the
	          // rejection reason outside the generator function, so the
	          // only option is to throw it from the await expression, and
	          // let the generator function handle the exception.
	          result.value = unwrapped;
	          resolve(result);
	        }, reject);
	      }
	    }

	    if (typeof process === "object" && process.domain) {
	      invoke = process.domain.bind(invoke);
	    }

	    var previousPromise;

	    function enqueue(method, arg) {
	      function callInvokeWithMethodAndArg() {
	        return new Promise(function(resolve, reject) {
	          invoke(method, arg, resolve, reject);
	        });
	      }

	      return previousPromise =
	        // If enqueue has been called before, then we want to wait until
	        // all previous Promises have been resolved before calling invoke,
	        // so that results are always delivered in the correct order. If
	        // enqueue has not been called before, then it is important to
	        // call invoke immediately, without waiting on a callback to fire,
	        // so that the async generator function has the opportunity to do
	        // any necessary setup in a predictable way. This predictability
	        // is why the Promise constructor synchronously invokes its
	        // executor callback, and why async functions synchronously
	        // execute code before the first await. Since we implement simple
	        // async functions in terms of async generators, it is especially
	        // important to get this right, even though it requires care.
	        previousPromise ? previousPromise.then(
	          callInvokeWithMethodAndArg,
	          // Avoid propagating failures to Promises returned by later
	          // invocations of the iterator.
	          callInvokeWithMethodAndArg
	        ) : callInvokeWithMethodAndArg();
	    }

	    // Define the unified helper method that is used to implement .next,
	    // .throw, and .return (see defineIteratorMethods).
	    this._invoke = enqueue;
	  }

	  defineIteratorMethods(AsyncIterator.prototype);

	  // Note that simple async functions are implemented on top of
	  // AsyncIterator objects; they just return a Promise for the value of
	  // the final result produced by the iterator.
	  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
	    var iter = new AsyncIterator(
	      wrap(innerFn, outerFn, self, tryLocsList)
	    );

	    return runtime.isGeneratorFunction(outerFn)
	      ? iter // If outerFn is a generator, return the full iterator.
	      : iter.next().then(function(result) {
	          return result.done ? result.value : iter.next();
	        });
	  };

	  function makeInvokeMethod(innerFn, self, context) {
	    var state = GenStateSuspendedStart;

	    return function invoke(method, arg) {
	      if (state === GenStateExecuting) {
	        throw new Error("Generator is already running");
	      }

	      if (state === GenStateCompleted) {
	        if (method === "throw") {
	          throw arg;
	        }

	        // Be forgiving, per 25.3.3.3.3 of the spec:
	        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
	        return doneResult();
	      }

	      while (true) {
	        var delegate = context.delegate;
	        if (delegate) {
	          if (method === "return" ||
	              (method === "throw" && delegate.iterator[method] === undefined)) {
	            // A return or throw (when the delegate iterator has no throw
	            // method) always terminates the yield* loop.
	            context.delegate = null;

	            // If the delegate iterator has a return method, give it a
	            // chance to clean up.
	            var returnMethod = delegate.iterator["return"];
	            if (returnMethod) {
	              var record = tryCatch(returnMethod, delegate.iterator, arg);
	              if (record.type === "throw") {
	                // If the return method threw an exception, let that
	                // exception prevail over the original return or throw.
	                method = "throw";
	                arg = record.arg;
	                continue;
	              }
	            }

	            if (method === "return") {
	              // Continue with the outer return, now that the delegate
	              // iterator has been terminated.
	              continue;
	            }
	          }

	          var record = tryCatch(
	            delegate.iterator[method],
	            delegate.iterator,
	            arg
	          );

	          if (record.type === "throw") {
	            context.delegate = null;

	            // Like returning generator.throw(uncaught), but without the
	            // overhead of an extra function call.
	            method = "throw";
	            arg = record.arg;
	            continue;
	          }

	          // Delegate generator ran and handled its own exceptions so
	          // regardless of what the method was, we continue as if it is
	          // "next" with an undefined arg.
	          method = "next";
	          arg = undefined;

	          var info = record.arg;
	          if (info.done) {
	            context[delegate.resultName] = info.value;
	            context.next = delegate.nextLoc;
	          } else {
	            state = GenStateSuspendedYield;
	            return info;
	          }

	          context.delegate = null;
	        }

	        if (method === "next") {
	          // Setting context._sent for legacy support of Babel's
	          // function.sent implementation.
	          context.sent = context._sent = arg;

	        } else if (method === "throw") {
	          if (state === GenStateSuspendedStart) {
	            state = GenStateCompleted;
	            throw arg;
	          }

	          if (context.dispatchException(arg)) {
	            // If the dispatched exception was caught by a catch block,
	            // then let that catch block handle the exception normally.
	            method = "next";
	            arg = undefined;
	          }

	        } else if (method === "return") {
	          context.abrupt("return", arg);
	        }

	        state = GenStateExecuting;

	        var record = tryCatch(innerFn, self, context);
	        if (record.type === "normal") {
	          // If an exception is thrown from innerFn, we leave state ===
	          // GenStateExecuting and loop back for another invocation.
	          state = context.done
	            ? GenStateCompleted
	            : GenStateSuspendedYield;

	          var info = {
	            value: record.arg,
	            done: context.done
	          };

	          if (record.arg === ContinueSentinel) {
	            if (context.delegate && method === "next") {
	              // Deliberately forget the last sent value so that we don't
	              // accidentally pass it on to the delegate.
	              arg = undefined;
	            }
	          } else {
	            return info;
	          }

	        } else if (record.type === "throw") {
	          state = GenStateCompleted;
	          // Dispatch the exception by looping back around to the
	          // context.dispatchException(arg) call above.
	          method = "throw";
	          arg = record.arg;
	        }
	      }
	    };
	  }

	  // Define Generator.prototype.{next,throw,return} in terms of the
	  // unified ._invoke helper method.
	  defineIteratorMethods(Gp);

	  Gp[iteratorSymbol] = function() {
	    return this;
	  };

	  Gp[toStringTagSymbol] = "Generator";

	  Gp.toString = function() {
	    return "[object Generator]";
	  };

	  function pushTryEntry(locs) {
	    var entry = { tryLoc: locs[0] };

	    if (1 in locs) {
	      entry.catchLoc = locs[1];
	    }

	    if (2 in locs) {
	      entry.finallyLoc = locs[2];
	      entry.afterLoc = locs[3];
	    }

	    this.tryEntries.push(entry);
	  }

	  function resetTryEntry(entry) {
	    var record = entry.completion || {};
	    record.type = "normal";
	    delete record.arg;
	    entry.completion = record;
	  }

	  function Context(tryLocsList) {
	    // The root entry object (effectively a try statement without a catch
	    // or a finally block) gives us a place to store values thrown from
	    // locations where there is no enclosing try statement.
	    this.tryEntries = [{ tryLoc: "root" }];
	    tryLocsList.forEach(pushTryEntry, this);
	    this.reset(true);
	  }

	  runtime.keys = function(object) {
	    var keys = [];
	    for (var key in object) {
	      keys.push(key);
	    }
	    keys.reverse();

	    // Rather than returning an object with a next method, we keep
	    // things simple and return the next function itself.
	    return function next() {
	      while (keys.length) {
	        var key = keys.pop();
	        if (key in object) {
	          next.value = key;
	          next.done = false;
	          return next;
	        }
	      }

	      // To avoid creating an additional object, we just hang the .value
	      // and .done properties off the next function object itself. This
	      // also ensures that the minifier will not anonymize the function.
	      next.done = true;
	      return next;
	    };
	  };

	  function values(iterable) {
	    if (iterable) {
	      var iteratorMethod = iterable[iteratorSymbol];
	      if (iteratorMethod) {
	        return iteratorMethod.call(iterable);
	      }

	      if (typeof iterable.next === "function") {
	        return iterable;
	      }

	      if (!isNaN(iterable.length)) {
	        var i = -1, next = function next() {
	          while (++i < iterable.length) {
	            if (hasOwn.call(iterable, i)) {
	              next.value = iterable[i];
	              next.done = false;
	              return next;
	            }
	          }

	          next.value = undefined;
	          next.done = true;

	          return next;
	        };

	        return next.next = next;
	      }
	    }

	    // Return an iterator with no values.
	    return { next: doneResult };
	  }
	  runtime.values = values;

	  function doneResult() {
	    return { value: undefined, done: true };
	  }

	  Context.prototype = {
	    constructor: Context,

	    reset: function(skipTempReset) {
	      this.prev = 0;
	      this.next = 0;
	      // Resetting context._sent for legacy support of Babel's
	      // function.sent implementation.
	      this.sent = this._sent = undefined;
	      this.done = false;
	      this.delegate = null;

	      this.tryEntries.forEach(resetTryEntry);

	      if (!skipTempReset) {
	        for (var name in this) {
	          // Not sure about the optimal order of these conditions:
	          if (name.charAt(0) === "t" &&
	              hasOwn.call(this, name) &&
	              !isNaN(+name.slice(1))) {
	            this[name] = undefined;
	          }
	        }
	      }
	    },

	    stop: function() {
	      this.done = true;

	      var rootEntry = this.tryEntries[0];
	      var rootRecord = rootEntry.completion;
	      if (rootRecord.type === "throw") {
	        throw rootRecord.arg;
	      }

	      return this.rval;
	    },

	    dispatchException: function(exception) {
	      if (this.done) {
	        throw exception;
	      }

	      var context = this;
	      function handle(loc, caught) {
	        record.type = "throw";
	        record.arg = exception;
	        context.next = loc;
	        return !!caught;
	      }

	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        var record = entry.completion;

	        if (entry.tryLoc === "root") {
	          // Exception thrown outside of any try block that could handle
	          // it, so set the completion value of the entire function to
	          // throw the exception.
	          return handle("end");
	        }

	        if (entry.tryLoc <= this.prev) {
	          var hasCatch = hasOwn.call(entry, "catchLoc");
	          var hasFinally = hasOwn.call(entry, "finallyLoc");

	          if (hasCatch && hasFinally) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            } else if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }

	          } else if (hasCatch) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            }

	          } else if (hasFinally) {
	            if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }

	          } else {
	            throw new Error("try statement without catch or finally");
	          }
	        }
	      }
	    },

	    abrupt: function(type, arg) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc <= this.prev &&
	            hasOwn.call(entry, "finallyLoc") &&
	            this.prev < entry.finallyLoc) {
	          var finallyEntry = entry;
	          break;
	        }
	      }

	      if (finallyEntry &&
	          (type === "break" ||
	           type === "continue") &&
	          finallyEntry.tryLoc <= arg &&
	          arg <= finallyEntry.finallyLoc) {
	        // Ignore the finally entry if control is not jumping to a
	        // location outside the try/catch block.
	        finallyEntry = null;
	      }

	      var record = finallyEntry ? finallyEntry.completion : {};
	      record.type = type;
	      record.arg = arg;

	      if (finallyEntry) {
	        this.next = finallyEntry.finallyLoc;
	      } else {
	        this.complete(record);
	      }

	      return ContinueSentinel;
	    },

	    complete: function(record, afterLoc) {
	      if (record.type === "throw") {
	        throw record.arg;
	      }

	      if (record.type === "break" ||
	          record.type === "continue") {
	        this.next = record.arg;
	      } else if (record.type === "return") {
	        this.rval = record.arg;
	        this.next = "end";
	      } else if (record.type === "normal" && afterLoc) {
	        this.next = afterLoc;
	      }
	    },

	    finish: function(finallyLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.finallyLoc === finallyLoc) {
	          this.complete(entry.completion, entry.afterLoc);
	          resetTryEntry(entry);
	          return ContinueSentinel;
	        }
	      }
	    },

	    "catch": function(tryLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc === tryLoc) {
	          var record = entry.completion;
	          if (record.type === "throw") {
	            var thrown = record.arg;
	            resetTryEntry(entry);
	          }
	          return thrown;
	        }
	      }

	      // The context.catch method must only be called with a location
	      // argument that corresponds to a known catch block.
	      throw new Error("illegal catch attempt");
	    },

	    delegateYield: function(iterable, resultName, nextLoc) {
	      this.delegate = {
	        iterator: values(iterable),
	        resultName: resultName,
	        nextLoc: nextLoc
	      };

	      return ContinueSentinel;
	    }
	  };
	})(
	  // Among the various tricks for obtaining a reference to the global
	  // object, this seems to be the most reliable technique that does not
	  // use indirect eval (which violates Content Security Policy).
	  typeof global === "object" ? global :
	  typeof window === "object" ? window :
	  typeof self === "object" ? self : this
	);

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(4)))

/***/ },
/* 150 */
/***/ function(module, exports, __webpack_require__) {

	var baseRest = __webpack_require__(151),
	    createWrap = __webpack_require__(159),
	    getHolder = __webpack_require__(192),
	    replaceHolders = __webpack_require__(194);

	/** Used to compose bitmasks for function metadata. */
	var BIND_FLAG = 1,
	    PARTIAL_FLAG = 32;

	/**
	 * Creates a function that invokes `func` with the `this` binding of `thisArg`
	 * and `partials` prepended to the arguments it receives.
	 *
	 * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
	 * may be used as a placeholder for partially applied arguments.
	 *
	 * **Note:** Unlike native `Function#bind`, this method doesn't set the "length"
	 * property of bound functions.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Function
	 * @param {Function} func The function to bind.
	 * @param {*} thisArg The `this` binding of `func`.
	 * @param {...*} [partials] The arguments to be partially applied.
	 * @returns {Function} Returns the new bound function.
	 * @example
	 *
	 * function greet(greeting, punctuation) {
	 *   return greeting + ' ' + this.user + punctuation;
	 * }
	 *
	 * var object = { 'user': 'fred' };
	 *
	 * var bound = _.bind(greet, object, 'hi');
	 * bound('!');
	 * // => 'hi fred!'
	 *
	 * // Bound with placeholders.
	 * var bound = _.bind(greet, object, _, '!');
	 * bound('hi');
	 * // => 'hi fred!'
	 */
	var bind = baseRest(function(func, thisArg, partials) {
	  var bitmask = BIND_FLAG;
	  if (partials.length) {
	    var holders = replaceHolders(partials, getHolder(bind));
	    bitmask |= PARTIAL_FLAG;
	  }
	  return createWrap(func, bitmask, thisArg, partials, holders);
	});

	// Assign default placeholders.
	bind.placeholder = {};

	module.exports = bind;


/***/ },
/* 151 */
/***/ function(module, exports, __webpack_require__) {

	var identity = __webpack_require__(126),
	    overRest = __webpack_require__(152),
	    setToString = __webpack_require__(154);

	/**
	 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
	 *
	 * @private
	 * @param {Function} func The function to apply a rest parameter to.
	 * @param {number} [start=func.length-1] The start position of the rest parameter.
	 * @returns {Function} Returns the new function.
	 */
	function baseRest(func, start) {
	  return setToString(overRest(func, start, identity), func + '');
	}

	module.exports = baseRest;


/***/ },
/* 152 */
/***/ function(module, exports, __webpack_require__) {

	var apply = __webpack_require__(153);

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeMax = Math.max;

	/**
	 * A specialized version of `baseRest` which transforms the rest array.
	 *
	 * @private
	 * @param {Function} func The function to apply a rest parameter to.
	 * @param {number} [start=func.length-1] The start position of the rest parameter.
	 * @param {Function} transform The rest array transform.
	 * @returns {Function} Returns the new function.
	 */
	function overRest(func, start, transform) {
	  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
	  return function() {
	    var args = arguments,
	        index = -1,
	        length = nativeMax(args.length - start, 0),
	        array = Array(length);

	    while (++index < length) {
	      array[index] = args[start + index];
	    }
	    index = -1;
	    var otherArgs = Array(start + 1);
	    while (++index < start) {
	      otherArgs[index] = args[index];
	    }
	    otherArgs[start] = transform(array);
	    return apply(func, this, otherArgs);
	  };
	}

	module.exports = overRest;


/***/ },
/* 153 */
/***/ function(module, exports) {

	/**
	 * A faster alternative to `Function#apply`, this function invokes `func`
	 * with the `this` binding of `thisArg` and the arguments of `args`.
	 *
	 * @private
	 * @param {Function} func The function to invoke.
	 * @param {*} thisArg The `this` binding of `func`.
	 * @param {Array} args The arguments to invoke `func` with.
	 * @returns {*} Returns the result of `func`.
	 */
	function apply(func, thisArg, args) {
	  switch (args.length) {
	    case 0: return func.call(thisArg);
	    case 1: return func.call(thisArg, args[0]);
	    case 2: return func.call(thisArg, args[0], args[1]);
	    case 3: return func.call(thisArg, args[0], args[1], args[2]);
	  }
	  return func.apply(thisArg, args);
	}

	module.exports = apply;


/***/ },
/* 154 */
/***/ function(module, exports, __webpack_require__) {

	var baseSetToString = __webpack_require__(155),
	    shortOut = __webpack_require__(158);

	/**
	 * Sets the `toString` method of `func` to return `string`.
	 *
	 * @private
	 * @param {Function} func The function to modify.
	 * @param {Function} string The `toString` result.
	 * @returns {Function} Returns `func`.
	 */
	var setToString = shortOut(baseSetToString);

	module.exports = setToString;


/***/ },
/* 155 */
/***/ function(module, exports, __webpack_require__) {

	var constant = __webpack_require__(156),
	    identity = __webpack_require__(126),
	    nativeDefineProperty = __webpack_require__(157);

	/**
	 * The base implementation of `setToString` without support for hot loop shorting.
	 *
	 * @private
	 * @param {Function} func The function to modify.
	 * @param {Function} string The `toString` result.
	 * @returns {Function} Returns `func`.
	 */
	var baseSetToString = !nativeDefineProperty ? identity : function(func, string) {
	  return nativeDefineProperty(func, 'toString', {
	    'configurable': true,
	    'enumerable': false,
	    'value': constant(string),
	    'writable': true
	  });
	};

	module.exports = baseSetToString;


/***/ },
/* 156 */
/***/ function(module, exports) {

	/**
	 * Creates a function that returns `value`.
	 *
	 * @static
	 * @memberOf _
	 * @since 2.4.0
	 * @category Util
	 * @param {*} value The value to return from the new function.
	 * @returns {Function} Returns the new constant function.
	 * @example
	 *
	 * var objects = _.times(2, _.constant({ 'a': 1 }));
	 *
	 * console.log(objects);
	 * // => [{ 'a': 1 }, { 'a': 1 }]
	 *
	 * console.log(objects[0] === objects[1]);
	 * // => true
	 */
	function constant(value) {
	  return function() {
	    return value;
	  };
	}

	module.exports = constant;


/***/ },
/* 157 */
/***/ function(module, exports, __webpack_require__) {

	var getNative = __webpack_require__(60);

	/* Built-in method references that are verified to be native. */
	var nativeDefineProperty = getNative(Object, 'defineProperty');

	module.exports = nativeDefineProperty;


/***/ },
/* 158 */
/***/ function(module, exports) {

	/** Used to detect hot functions by number of calls within a span of milliseconds. */
	var HOT_COUNT = 500,
	    HOT_SPAN = 16;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeNow = Date.now;

	/**
	 * Creates a function that'll short out and invoke `identity` instead
	 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
	 * milliseconds.
	 *
	 * @private
	 * @param {Function} func The function to restrict.
	 * @returns {Function} Returns the new shortable function.
	 */
	function shortOut(func) {
	  var count = 0,
	      lastCalled = 0;

	  return function() {
	    var stamp = nativeNow(),
	        remaining = HOT_SPAN - (stamp - lastCalled);

	    lastCalled = stamp;
	    if (remaining > 0) {
	      if (++count >= HOT_COUNT) {
	        return arguments[0];
	      }
	    } else {
	      count = 0;
	    }
	    return func.apply(undefined, arguments);
	  };
	}

	module.exports = shortOut;


/***/ },
/* 159 */
/***/ function(module, exports, __webpack_require__) {

	var baseSetData = __webpack_require__(160),
	    createBind = __webpack_require__(162),
	    createCurry = __webpack_require__(165),
	    createHybrid = __webpack_require__(166),
	    createPartial = __webpack_require__(195),
	    getData = __webpack_require__(174),
	    mergeData = __webpack_require__(196),
	    setData = __webpack_require__(182),
	    setWrapToString = __webpack_require__(183),
	    toInteger = __webpack_require__(197);

	/** Used as the `TypeError` message for "Functions" methods. */
	var FUNC_ERROR_TEXT = 'Expected a function';

	/** Used to compose bitmasks for function metadata. */
	var BIND_FLAG = 1,
	    BIND_KEY_FLAG = 2,
	    CURRY_FLAG = 8,
	    CURRY_RIGHT_FLAG = 16,
	    PARTIAL_FLAG = 32,
	    PARTIAL_RIGHT_FLAG = 64;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeMax = Math.max;

	/**
	 * Creates a function that either curries or invokes `func` with optional
	 * `this` binding and partially applied arguments.
	 *
	 * @private
	 * @param {Function|string} func The function or method name to wrap.
	 * @param {number} bitmask The bitmask flags.
	 *  The bitmask may be composed of the following flags:
	 *     1 - `_.bind`
	 *     2 - `_.bindKey`
	 *     4 - `_.curry` or `_.curryRight` of a bound function
	 *     8 - `_.curry`
	 *    16 - `_.curryRight`
	 *    32 - `_.partial`
	 *    64 - `_.partialRight`
	 *   128 - `_.rearg`
	 *   256 - `_.ary`
	 *   512 - `_.flip`
	 * @param {*} [thisArg] The `this` binding of `func`.
	 * @param {Array} [partials] The arguments to be partially applied.
	 * @param {Array} [holders] The `partials` placeholder indexes.
	 * @param {Array} [argPos] The argument positions of the new function.
	 * @param {number} [ary] The arity cap of `func`.
	 * @param {number} [arity] The arity of `func`.
	 * @returns {Function} Returns the new wrapped function.
	 */
	function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
	  var isBindKey = bitmask & BIND_KEY_FLAG;
	  if (!isBindKey && typeof func != 'function') {
	    throw new TypeError(FUNC_ERROR_TEXT);
	  }
	  var length = partials ? partials.length : 0;
	  if (!length) {
	    bitmask &= ~(PARTIAL_FLAG | PARTIAL_RIGHT_FLAG);
	    partials = holders = undefined;
	  }
	  ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0);
	  arity = arity === undefined ? arity : toInteger(arity);
	  length -= holders ? holders.length : 0;

	  if (bitmask & PARTIAL_RIGHT_FLAG) {
	    var partialsRight = partials,
	        holdersRight = holders;

	    partials = holders = undefined;
	  }
	  var data = isBindKey ? undefined : getData(func);

	  var newData = [
	    func, bitmask, thisArg, partials, holders, partialsRight, holdersRight,
	    argPos, ary, arity
	  ];

	  if (data) {
	    mergeData(newData, data);
	  }
	  func = newData[0];
	  bitmask = newData[1];
	  thisArg = newData[2];
	  partials = newData[3];
	  holders = newData[4];
	  arity = newData[9] = newData[9] == null
	    ? (isBindKey ? 0 : func.length)
	    : nativeMax(newData[9] - length, 0);

	  if (!arity && bitmask & (CURRY_FLAG | CURRY_RIGHT_FLAG)) {
	    bitmask &= ~(CURRY_FLAG | CURRY_RIGHT_FLAG);
	  }
	  if (!bitmask || bitmask == BIND_FLAG) {
	    var result = createBind(func, bitmask, thisArg);
	  } else if (bitmask == CURRY_FLAG || bitmask == CURRY_RIGHT_FLAG) {
	    result = createCurry(func, bitmask, arity);
	  } else if ((bitmask == PARTIAL_FLAG || bitmask == (BIND_FLAG | PARTIAL_FLAG)) && !holders.length) {
	    result = createPartial(func, bitmask, thisArg, partials);
	  } else {
	    result = createHybrid.apply(undefined, newData);
	  }
	  var setter = data ? baseSetData : setData;
	  return setWrapToString(setter(result, newData), func, bitmask);
	}

	module.exports = createWrap;


/***/ },
/* 160 */
/***/ function(module, exports, __webpack_require__) {

	var identity = __webpack_require__(126),
	    metaMap = __webpack_require__(161);

	/**
	 * The base implementation of `setData` without support for hot loop shorting.
	 *
	 * @private
	 * @param {Function} func The function to associate metadata with.
	 * @param {*} data The metadata.
	 * @returns {Function} Returns `func`.
	 */
	var baseSetData = !metaMap ? identity : function(func, data) {
	  metaMap.set(func, data);
	  return func;
	};

	module.exports = baseSetData;


/***/ },
/* 161 */
/***/ function(module, exports, __webpack_require__) {

	var WeakMap = __webpack_require__(101);

	/** Used to store function metadata. */
	var metaMap = WeakMap && new WeakMap;

	module.exports = metaMap;


/***/ },
/* 162 */
/***/ function(module, exports, __webpack_require__) {

	var createCtor = __webpack_require__(163),
	    root = __webpack_require__(64);

	/** Used to compose bitmasks for function metadata. */
	var BIND_FLAG = 1;

	/**
	 * Creates a function that wraps `func` to invoke it with the optional `this`
	 * binding of `thisArg`.
	 *
	 * @private
	 * @param {Function} func The function to wrap.
	 * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
	 * @param {*} [thisArg] The `this` binding of `func`.
	 * @returns {Function} Returns the new wrapped function.
	 */
	function createBind(func, bitmask, thisArg) {
	  var isBind = bitmask & BIND_FLAG,
	      Ctor = createCtor(func);

	  function wrapper() {
	    var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
	    return fn.apply(isBind ? thisArg : this, arguments);
	  }
	  return wrapper;
	}

	module.exports = createBind;


/***/ },
/* 163 */
/***/ function(module, exports, __webpack_require__) {

	var baseCreate = __webpack_require__(164),
	    isObject = __webpack_require__(32);

	/**
	 * Creates a function that produces an instance of `Ctor` regardless of
	 * whether it was invoked as part of a `new` expression or by `call` or `apply`.
	 *
	 * @private
	 * @param {Function} Ctor The constructor to wrap.
	 * @returns {Function} Returns the new wrapped function.
	 */
	function createCtor(Ctor) {
	  return function() {
	    // Use a `switch` statement to work with class constructors. See
	    // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
	    // for more details.
	    var args = arguments;
	    switch (args.length) {
	      case 0: return new Ctor;
	      case 1: return new Ctor(args[0]);
	      case 2: return new Ctor(args[0], args[1]);
	      case 3: return new Ctor(args[0], args[1], args[2]);
	      case 4: return new Ctor(args[0], args[1], args[2], args[3]);
	      case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);
	      case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
	      case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
	    }
	    var thisBinding = baseCreate(Ctor.prototype),
	        result = Ctor.apply(thisBinding, args);

	    // Mimic the constructor's `return` behavior.
	    // See https://es5.github.io/#x13.2.2 for more details.
	    return isObject(result) ? result : thisBinding;
	  };
	}

	module.exports = createCtor;


/***/ },
/* 164 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(32);

	/** Built-in value references. */
	var objectCreate = Object.create;

	/**
	 * The base implementation of `_.create` without support for assigning
	 * properties to the created object.
	 *
	 * @private
	 * @param {Object} prototype The object to inherit from.
	 * @returns {Object} Returns the new object.
	 */
	function baseCreate(proto) {
	  return isObject(proto) ? objectCreate(proto) : {};
	}

	module.exports = baseCreate;


/***/ },
/* 165 */
/***/ function(module, exports, __webpack_require__) {

	var apply = __webpack_require__(153),
	    createCtor = __webpack_require__(163),
	    createHybrid = __webpack_require__(166),
	    createRecurry = __webpack_require__(170),
	    getHolder = __webpack_require__(192),
	    replaceHolders = __webpack_require__(194),
	    root = __webpack_require__(64);

	/**
	 * Creates a function that wraps `func` to enable currying.
	 *
	 * @private
	 * @param {Function} func The function to wrap.
	 * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
	 * @param {number} arity The arity of `func`.
	 * @returns {Function} Returns the new wrapped function.
	 */
	function createCurry(func, bitmask, arity) {
	  var Ctor = createCtor(func);

	  function wrapper() {
	    var length = arguments.length,
	        args = Array(length),
	        index = length,
	        placeholder = getHolder(wrapper);

	    while (index--) {
	      args[index] = arguments[index];
	    }
	    var holders = (length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder)
	      ? []
	      : replaceHolders(args, placeholder);

	    length -= holders.length;
	    if (length < arity) {
	      return createRecurry(
	        func, bitmask, createHybrid, wrapper.placeholder, undefined,
	        args, holders, undefined, undefined, arity - length);
	    }
	    var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
	    return apply(fn, this, args);
	  }
	  return wrapper;
	}

	module.exports = createCurry;


/***/ },
/* 166 */
/***/ function(module, exports, __webpack_require__) {

	var composeArgs = __webpack_require__(167),
	    composeArgsRight = __webpack_require__(168),
	    countHolders = __webpack_require__(169),
	    createCtor = __webpack_require__(163),
	    createRecurry = __webpack_require__(170),
	    getHolder = __webpack_require__(192),
	    reorder = __webpack_require__(193),
	    replaceHolders = __webpack_require__(194),
	    root = __webpack_require__(64);

	/** Used to compose bitmasks for function metadata. */
	var BIND_FLAG = 1,
	    BIND_KEY_FLAG = 2,
	    CURRY_FLAG = 8,
	    CURRY_RIGHT_FLAG = 16,
	    ARY_FLAG = 128,
	    FLIP_FLAG = 512;

	/**
	 * Creates a function that wraps `func` to invoke it with optional `this`
	 * binding of `thisArg`, partial application, and currying.
	 *
	 * @private
	 * @param {Function|string} func The function or method name to wrap.
	 * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
	 * @param {*} [thisArg] The `this` binding of `func`.
	 * @param {Array} [partials] The arguments to prepend to those provided to
	 *  the new function.
	 * @param {Array} [holders] The `partials` placeholder indexes.
	 * @param {Array} [partialsRight] The arguments to append to those provided
	 *  to the new function.
	 * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
	 * @param {Array} [argPos] The argument positions of the new function.
	 * @param {number} [ary] The arity cap of `func`.
	 * @param {number} [arity] The arity of `func`.
	 * @returns {Function} Returns the new wrapped function.
	 */
	function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
	  var isAry = bitmask & ARY_FLAG,
	      isBind = bitmask & BIND_FLAG,
	      isBindKey = bitmask & BIND_KEY_FLAG,
	      isCurried = bitmask & (CURRY_FLAG | CURRY_RIGHT_FLAG),
	      isFlip = bitmask & FLIP_FLAG,
	      Ctor = isBindKey ? undefined : createCtor(func);

	  function wrapper() {
	    var length = arguments.length,
	        args = Array(length),
	        index = length;

	    while (index--) {
	      args[index] = arguments[index];
	    }
	    if (isCurried) {
	      var placeholder = getHolder(wrapper),
	          holdersCount = countHolders(args, placeholder);
	    }
	    if (partials) {
	      args = composeArgs(args, partials, holders, isCurried);
	    }
	    if (partialsRight) {
	      args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
	    }
	    length -= holdersCount;
	    if (isCurried && length < arity) {
	      var newHolders = replaceHolders(args, placeholder);
	      return createRecurry(
	        func, bitmask, createHybrid, wrapper.placeholder, thisArg,
	        args, newHolders, argPos, ary, arity - length
	      );
	    }
	    var thisBinding = isBind ? thisArg : this,
	        fn = isBindKey ? thisBinding[func] : func;

	    length = args.length;
	    if (argPos) {
	      args = reorder(args, argPos);
	    } else if (isFlip && length > 1) {
	      args.reverse();
	    }
	    if (isAry && ary < length) {
	      args.length = ary;
	    }
	    if (this && this !== root && this instanceof wrapper) {
	      fn = Ctor || createCtor(fn);
	    }
	    return fn.apply(thisBinding, args);
	  }
	  return wrapper;
	}

	module.exports = createHybrid;


/***/ },
/* 167 */
/***/ function(module, exports) {

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeMax = Math.max;

	/**
	 * Creates an array that is the composition of partially applied arguments,
	 * placeholders, and provided arguments into a single array of arguments.
	 *
	 * @private
	 * @param {Array} args The provided arguments.
	 * @param {Array} partials The arguments to prepend to those provided.
	 * @param {Array} holders The `partials` placeholder indexes.
	 * @params {boolean} [isCurried] Specify composing for a curried function.
	 * @returns {Array} Returns the new array of composed arguments.
	 */
	function composeArgs(args, partials, holders, isCurried) {
	  var argsIndex = -1,
	      argsLength = args.length,
	      holdersLength = holders.length,
	      leftIndex = -1,
	      leftLength = partials.length,
	      rangeLength = nativeMax(argsLength - holdersLength, 0),
	      result = Array(leftLength + rangeLength),
	      isUncurried = !isCurried;

	  while (++leftIndex < leftLength) {
	    result[leftIndex] = partials[leftIndex];
	  }
	  while (++argsIndex < holdersLength) {
	    if (isUncurried || argsIndex < argsLength) {
	      result[holders[argsIndex]] = args[argsIndex];
	    }
	  }
	  while (rangeLength--) {
	    result[leftIndex++] = args[argsIndex++];
	  }
	  return result;
	}

	module.exports = composeArgs;


/***/ },
/* 168 */
/***/ function(module, exports) {

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeMax = Math.max;

	/**
	 * This function is like `composeArgs` except that the arguments composition
	 * is tailored for `_.partialRight`.
	 *
	 * @private
	 * @param {Array} args The provided arguments.
	 * @param {Array} partials The arguments to append to those provided.
	 * @param {Array} holders The `partials` placeholder indexes.
	 * @params {boolean} [isCurried] Specify composing for a curried function.
	 * @returns {Array} Returns the new array of composed arguments.
	 */
	function composeArgsRight(args, partials, holders, isCurried) {
	  var argsIndex = -1,
	      argsLength = args.length,
	      holdersIndex = -1,
	      holdersLength = holders.length,
	      rightIndex = -1,
	      rightLength = partials.length,
	      rangeLength = nativeMax(argsLength - holdersLength, 0),
	      result = Array(rangeLength + rightLength),
	      isUncurried = !isCurried;

	  while (++argsIndex < rangeLength) {
	    result[argsIndex] = args[argsIndex];
	  }
	  var offset = argsIndex;
	  while (++rightIndex < rightLength) {
	    result[offset + rightIndex] = partials[rightIndex];
	  }
	  while (++holdersIndex < holdersLength) {
	    if (isUncurried || argsIndex < argsLength) {
	      result[offset + holders[holdersIndex]] = args[argsIndex++];
	    }
	  }
	  return result;
	}

	module.exports = composeArgsRight;


/***/ },
/* 169 */
/***/ function(module, exports) {

	/**
	 * Gets the number of `placeholder` occurrences in `array`.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} placeholder The placeholder to search for.
	 * @returns {number} Returns the placeholder count.
	 */
	function countHolders(array, placeholder) {
	  var length = array.length,
	      result = 0;

	  while (length--) {
	    if (array[length] === placeholder) {
	      ++result;
	    }
	  }
	  return result;
	}

	module.exports = countHolders;


/***/ },
/* 170 */
/***/ function(module, exports, __webpack_require__) {

	var isLaziable = __webpack_require__(171),
	    setData = __webpack_require__(182),
	    setWrapToString = __webpack_require__(183);

	/** Used to compose bitmasks for function metadata. */
	var BIND_FLAG = 1,
	    BIND_KEY_FLAG = 2,
	    CURRY_BOUND_FLAG = 4,
	    CURRY_FLAG = 8,
	    PARTIAL_FLAG = 32,
	    PARTIAL_RIGHT_FLAG = 64;

	/**
	 * Creates a function that wraps `func` to continue currying.
	 *
	 * @private
	 * @param {Function} func The function to wrap.
	 * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
	 * @param {Function} wrapFunc The function to create the `func` wrapper.
	 * @param {*} placeholder The placeholder value.
	 * @param {*} [thisArg] The `this` binding of `func`.
	 * @param {Array} [partials] The arguments to prepend to those provided to
	 *  the new function.
	 * @param {Array} [holders] The `partials` placeholder indexes.
	 * @param {Array} [argPos] The argument positions of the new function.
	 * @param {number} [ary] The arity cap of `func`.
	 * @param {number} [arity] The arity of `func`.
	 * @returns {Function} Returns the new wrapped function.
	 */
	function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
	  var isCurry = bitmask & CURRY_FLAG,
	      newHolders = isCurry ? holders : undefined,
	      newHoldersRight = isCurry ? undefined : holders,
	      newPartials = isCurry ? partials : undefined,
	      newPartialsRight = isCurry ? undefined : partials;

	  bitmask |= (isCurry ? PARTIAL_FLAG : PARTIAL_RIGHT_FLAG);
	  bitmask &= ~(isCurry ? PARTIAL_RIGHT_FLAG : PARTIAL_FLAG);

	  if (!(bitmask & CURRY_BOUND_FLAG)) {
	    bitmask &= ~(BIND_FLAG | BIND_KEY_FLAG);
	  }
	  var newData = [
	    func, bitmask, thisArg, newPartials, newHolders, newPartialsRight,
	    newHoldersRight, argPos, ary, arity
	  ];

	  var result = wrapFunc.apply(undefined, newData);
	  if (isLaziable(func)) {
	    setData(result, newData);
	  }
	  result.placeholder = placeholder;
	  return setWrapToString(result, func, bitmask);
	}

	module.exports = createRecurry;


/***/ },
/* 171 */
/***/ function(module, exports, __webpack_require__) {

	var LazyWrapper = __webpack_require__(172),
	    getData = __webpack_require__(174),
	    getFuncName = __webpack_require__(176),
	    lodash = __webpack_require__(178);

	/**
	 * Checks if `func` has a lazy counterpart.
	 *
	 * @private
	 * @param {Function} func The function to check.
	 * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
	 *  else `false`.
	 */
	function isLaziable(func) {
	  var funcName = getFuncName(func),
	      other = lodash[funcName];

	  if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {
	    return false;
	  }
	  if (func === other) {
	    return true;
	  }
	  var data = getData(other);
	  return !!data && func === data[0];
	}

	module.exports = isLaziable;


/***/ },
/* 172 */
/***/ function(module, exports, __webpack_require__) {

	var baseCreate = __webpack_require__(164),
	    baseLodash = __webpack_require__(173);

	/** Used as references for the maximum length and index of an array. */
	var MAX_ARRAY_LENGTH = 4294967295;

	/**
	 * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
	 *
	 * @private
	 * @constructor
	 * @param {*} value The value to wrap.
	 */
	function LazyWrapper(value) {
	  this.__wrapped__ = value;
	  this.__actions__ = [];
	  this.__dir__ = 1;
	  this.__filtered__ = false;
	  this.__iteratees__ = [];
	  this.__takeCount__ = MAX_ARRAY_LENGTH;
	  this.__views__ = [];
	}

	// Ensure `LazyWrapper` is an instance of `baseLodash`.
	LazyWrapper.prototype = baseCreate(baseLodash.prototype);
	LazyWrapper.prototype.constructor = LazyWrapper;

	module.exports = LazyWrapper;


/***/ },
/* 173 */
/***/ function(module, exports) {

	/**
	 * The function whose prototype chain sequence wrappers inherit from.
	 *
	 * @private
	 */
	function baseLodash() {
	  // No operation performed.
	}

	module.exports = baseLodash;


/***/ },
/* 174 */
/***/ function(module, exports, __webpack_require__) {

	var metaMap = __webpack_require__(161),
	    noop = __webpack_require__(175);

	/**
	 * Gets metadata for `func`.
	 *
	 * @private
	 * @param {Function} func The function to query.
	 * @returns {*} Returns the metadata for `func`.
	 */
	var getData = !metaMap ? noop : function(func) {
	  return metaMap.get(func);
	};

	module.exports = getData;


/***/ },
/* 175 */
/***/ function(module, exports) {

	/**
	 * This method returns `undefined`.
	 *
	 * @static
	 * @memberOf _
	 * @since 2.3.0
	 * @category Util
	 * @example
	 *
	 * _.times(2, _.noop);
	 * // => [undefined, undefined]
	 */
	function noop() {
	  // No operation performed.
	}

	module.exports = noop;


/***/ },
/* 176 */
/***/ function(module, exports, __webpack_require__) {

	var realNames = __webpack_require__(177);

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Gets the name of `func`.
	 *
	 * @private
	 * @param {Function} func The function to query.
	 * @returns {string} Returns the function name.
	 */
	function getFuncName(func) {
	  var result = (func.name + ''),
	      array = realNames[result],
	      length = hasOwnProperty.call(realNames, result) ? array.length : 0;

	  while (length--) {
	    var data = array[length],
	        otherFunc = data.func;
	    if (otherFunc == null || otherFunc == func) {
	      return data.name;
	    }
	  }
	  return result;
	}

	module.exports = getFuncName;


/***/ },
/* 177 */
/***/ function(module, exports) {

	/** Used to lookup unminified function names. */
	var realNames = {};

	module.exports = realNames;


/***/ },
/* 178 */
/***/ function(module, exports, __webpack_require__) {

	var LazyWrapper = __webpack_require__(172),
	    LodashWrapper = __webpack_require__(179),
	    baseLodash = __webpack_require__(173),
	    isArray = __webpack_require__(35),
	    isObjectLike = __webpack_require__(34),
	    wrapperClone = __webpack_require__(180);

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Creates a `lodash` object which wraps `value` to enable implicit method
	 * chain sequences. Methods that operate on and return arrays, collections,
	 * and functions can be chained together. Methods that retrieve a single value
	 * or may return a primitive value will automatically end the chain sequence
	 * and return the unwrapped value. Otherwise, the value must be unwrapped
	 * with `_#value`.
	 *
	 * Explicit chain sequences, which must be unwrapped with `_#value`, may be
	 * enabled using `_.chain`.
	 *
	 * The execution of chained methods is lazy, that is, it's deferred until
	 * `_#value` is implicitly or explicitly called.
	 *
	 * Lazy evaluation allows several methods to support shortcut fusion.
	 * Shortcut fusion is an optimization to merge iteratee calls; this avoids
	 * the creation of intermediate arrays and can greatly reduce the number of
	 * iteratee executions. Sections of a chain sequence qualify for shortcut
	 * fusion if the section is applied to an array of at least `200` elements
	 * and any iteratees accept only one argument. The heuristic for whether a
	 * section qualifies for shortcut fusion is subject to change.
	 *
	 * Chaining is supported in custom builds as long as the `_#value` method is
	 * directly or indirectly included in the build.
	 *
	 * In addition to lodash methods, wrappers have `Array` and `String` methods.
	 *
	 * The wrapper `Array` methods are:
	 * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
	 *
	 * The wrapper `String` methods are:
	 * `replace` and `split`
	 *
	 * The wrapper methods that support shortcut fusion are:
	 * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
	 * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
	 * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
	 *
	 * The chainable wrapper methods are:
	 * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
	 * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
	 * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
	 * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
	 * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
	 * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
	 * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
	 * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
	 * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
	 * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
	 * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
	 * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
	 * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
	 * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
	 * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
	 * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
	 * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
	 * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
	 * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
	 * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
	 * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
	 * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
	 * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
	 * `zipObject`, `zipObjectDeep`, and `zipWith`
	 *
	 * The wrapper methods that are **not** chainable by default are:
	 * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
	 * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
	 * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
	 * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
	 * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
	 * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
	 * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
	 * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
	 * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
	 * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
	 * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
	 * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
	 * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
	 * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
	 * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
	 * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
	 * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
	 * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
	 * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
	 * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
	 * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
	 * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
	 * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
	 * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
	 * `upperFirst`, `value`, and `words`
	 *
	 * @name _
	 * @constructor
	 * @category Seq
	 * @param {*} value The value to wrap in a `lodash` instance.
	 * @returns {Object} Returns the new `lodash` wrapper instance.
	 * @example
	 *
	 * function square(n) {
	 *   return n * n;
	 * }
	 *
	 * var wrapped = _([1, 2, 3]);
	 *
	 * // Returns an unwrapped value.
	 * wrapped.reduce(_.add);
	 * // => 6
	 *
	 * // Returns a wrapped value.
	 * var squares = wrapped.map(square);
	 *
	 * _.isArray(squares);
	 * // => false
	 *
	 * _.isArray(squares.value());
	 * // => true
	 */
	function lodash(value) {
	  if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
	    if (value instanceof LodashWrapper) {
	      return value;
	    }
	    if (hasOwnProperty.call(value, '__wrapped__')) {
	      return wrapperClone(value);
	    }
	  }
	  return new LodashWrapper(value);
	}

	// Ensure wrappers are instances of `baseLodash`.
	lodash.prototype = baseLodash.prototype;
	lodash.prototype.constructor = lodash;

	module.exports = lodash;


/***/ },
/* 179 */
/***/ function(module, exports, __webpack_require__) {

	var baseCreate = __webpack_require__(164),
	    baseLodash = __webpack_require__(173);

	/**
	 * The base constructor for creating `lodash` wrapper objects.
	 *
	 * @private
	 * @param {*} value The value to wrap.
	 * @param {boolean} [chainAll] Enable explicit method chain sequences.
	 */
	function LodashWrapper(value, chainAll) {
	  this.__wrapped__ = value;
	  this.__actions__ = [];
	  this.__chain__ = !!chainAll;
	  this.__index__ = 0;
	  this.__values__ = undefined;
	}

	LodashWrapper.prototype = baseCreate(baseLodash.prototype);
	LodashWrapper.prototype.constructor = LodashWrapper;

	module.exports = LodashWrapper;


/***/ },
/* 180 */
/***/ function(module, exports, __webpack_require__) {

	var LazyWrapper = __webpack_require__(172),
	    LodashWrapper = __webpack_require__(179),
	    copyArray = __webpack_require__(181);

	/**
	 * Creates a clone of `wrapper`.
	 *
	 * @private
	 * @param {Object} wrapper The wrapper to clone.
	 * @returns {Object} Returns the cloned wrapper.
	 */
	function wrapperClone(wrapper) {
	  if (wrapper instanceof LazyWrapper) {
	    return wrapper.clone();
	  }
	  var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
	  result.__actions__ = copyArray(wrapper.__actions__);
	  result.__index__  = wrapper.__index__;
	  result.__values__ = wrapper.__values__;
	  return result;
	}

	module.exports = wrapperClone;


/***/ },
/* 181 */
/***/ function(module, exports) {

	/**
	 * Copies the values of `source` to `array`.
	 *
	 * @private
	 * @param {Array} source The array to copy values from.
	 * @param {Array} [array=[]] The array to copy values to.
	 * @returns {Array} Returns `array`.
	 */
	function copyArray(source, array) {
	  var index = -1,
	      length = source.length;

	  array || (array = Array(length));
	  while (++index < length) {
	    array[index] = source[index];
	  }
	  return array;
	}

	module.exports = copyArray;


/***/ },
/* 182 */
/***/ function(module, exports, __webpack_require__) {

	var baseSetData = __webpack_require__(160),
	    shortOut = __webpack_require__(158);

	/**
	 * Sets metadata for `func`.
	 *
	 * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
	 * period of time, it will trip its breaker and transition to an identity
	 * function to avoid garbage collection pauses in V8. See
	 * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)
	 * for more details.
	 *
	 * @private
	 * @param {Function} func The function to associate metadata with.
	 * @param {*} data The metadata.
	 * @returns {Function} Returns `func`.
	 */
	var setData = shortOut(baseSetData);

	module.exports = setData;


/***/ },
/* 183 */
/***/ function(module, exports, __webpack_require__) {

	var getWrapDetails = __webpack_require__(184),
	    insertWrapDetails = __webpack_require__(185),
	    setToString = __webpack_require__(154),
	    updateWrapDetails = __webpack_require__(186);

	/**
	 * Sets the `toString` method of `wrapper` to mimic the source of `reference`
	 * with wrapper details in a comment at the top of the source body.
	 *
	 * @private
	 * @param {Function} wrapper The function to modify.
	 * @param {Function} reference The reference function.
	 * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
	 * @returns {Function} Returns `wrapper`.
	 */
	function setWrapToString(wrapper, reference, bitmask) {
	  var source = (reference + '');
	  return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
	}

	module.exports = setWrapToString;


/***/ },
/* 184 */
/***/ function(module, exports) {

	/** Used to match wrap detail comments. */
	var reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/,
	    reSplitDetails = /,? & /;

	/**
	 * Extracts wrapper details from the `source` body comment.
	 *
	 * @private
	 * @param {string} source The source to inspect.
	 * @returns {Array} Returns the wrapper details.
	 */
	function getWrapDetails(source) {
	  var match = source.match(reWrapDetails);
	  return match ? match[1].split(reSplitDetails) : [];
	}

	module.exports = getWrapDetails;


/***/ },
/* 185 */
/***/ function(module, exports) {

	/** Used to match wrap detail comments. */
	var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/;

	/**
	 * Inserts wrapper `details` in a comment at the top of the `source` body.
	 *
	 * @private
	 * @param {string} source The source to modify.
	 * @returns {Array} details The details to insert.
	 * @returns {string} Returns the modified source.
	 */
	function insertWrapDetails(source, details) {
	  var length = details.length;
	  if (!length) {
	    return source;
	  }
	  var lastIndex = length - 1;
	  details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex];
	  details = details.join(length > 2 ? ', ' : ' ');
	  return source.replace(reWrapComment, '{\n/* [wrapped with ' + details + '] */\n');
	}

	module.exports = insertWrapDetails;


/***/ },
/* 186 */
/***/ function(module, exports, __webpack_require__) {

	var arrayEach = __webpack_require__(20),
	    arrayIncludes = __webpack_require__(187);

	/** Used to compose bitmasks for function metadata. */
	var BIND_FLAG = 1,
	    BIND_KEY_FLAG = 2,
	    CURRY_FLAG = 8,
	    CURRY_RIGHT_FLAG = 16,
	    PARTIAL_FLAG = 32,
	    PARTIAL_RIGHT_FLAG = 64,
	    ARY_FLAG = 128,
	    REARG_FLAG = 256,
	    FLIP_FLAG = 512;

	/** Used to associate wrap methods with their bit flags. */
	var wrapFlags = [
	  ['ary', ARY_FLAG],
	  ['bind', BIND_FLAG],
	  ['bindKey', BIND_KEY_FLAG],
	  ['curry', CURRY_FLAG],
	  ['curryRight', CURRY_RIGHT_FLAG],
	  ['flip', FLIP_FLAG],
	  ['partial', PARTIAL_FLAG],
	  ['partialRight', PARTIAL_RIGHT_FLAG],
	  ['rearg', REARG_FLAG]
	];

	/**
	 * Updates wrapper `details` based on `bitmask` flags.
	 *
	 * @private
	 * @returns {Array} details The details to modify.
	 * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
	 * @returns {Array} Returns `details`.
	 */
	function updateWrapDetails(details, bitmask) {
	  arrayEach(wrapFlags, function(pair) {
	    var value = '_.' + pair[0];
	    if ((bitmask & pair[1]) && !arrayIncludes(details, value)) {
	      details.push(value);
	    }
	  });
	  return details.sort();
	}

	module.exports = updateWrapDetails;


/***/ },
/* 187 */
/***/ function(module, exports, __webpack_require__) {

	var baseIndexOf = __webpack_require__(188);

	/**
	 * A specialized version of `_.includes` for arrays without support for
	 * specifying an index to search from.
	 *
	 * @private
	 * @param {Array} [array] The array to inspect.
	 * @param {*} target The value to search for.
	 * @returns {boolean} Returns `true` if `target` is found, else `false`.
	 */
	function arrayIncludes(array, value) {
	  var length = array ? array.length : 0;
	  return !!length && baseIndexOf(array, value, 0) > -1;
	}

	module.exports = arrayIncludes;


/***/ },
/* 188 */
/***/ function(module, exports, __webpack_require__) {

	var baseFindIndex = __webpack_require__(189),
	    baseIsNaN = __webpack_require__(190),
	    strictIndexOf = __webpack_require__(191);

	/**
	 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} value The value to search for.
	 * @param {number} fromIndex The index to search from.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function baseIndexOf(array, value, fromIndex) {
	  return value === value
	    ? strictIndexOf(array, value, fromIndex)
	    : baseFindIndex(array, baseIsNaN, fromIndex);
	}

	module.exports = baseIndexOf;


/***/ },
/* 189 */
/***/ function(module, exports) {

	/**
	 * The base implementation of `_.findIndex` and `_.findLastIndex` without
	 * support for iteratee shorthands.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {Function} predicate The function invoked per iteration.
	 * @param {number} fromIndex The index to search from.
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function baseFindIndex(array, predicate, fromIndex, fromRight) {
	  var length = array.length,
	      index = fromIndex + (fromRight ? 1 : -1);

	  while ((fromRight ? index-- : ++index < length)) {
	    if (predicate(array[index], index, array)) {
	      return index;
	    }
	  }
	  return -1;
	}

	module.exports = baseFindIndex;


/***/ },
/* 190 */
/***/ function(module, exports) {

	/**
	 * The base implementation of `_.isNaN` without support for number objects.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
	 */
	function baseIsNaN(value) {
	  return value !== value;
	}

	module.exports = baseIsNaN;


/***/ },
/* 191 */
/***/ function(module, exports) {

	/**
	 * A specialized version of `_.indexOf` which performs strict equality
	 * comparisons of values, i.e. `===`.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} value The value to search for.
	 * @param {number} fromIndex The index to search from.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function strictIndexOf(array, value, fromIndex) {
	  var index = fromIndex - 1,
	      length = array.length;

	  while (++index < length) {
	    if (array[index] === value) {
	      return index;
	    }
	  }
	  return -1;
	}

	module.exports = strictIndexOf;


/***/ },
/* 192 */
/***/ function(module, exports) {

	/**
	 * Gets the argument placeholder value for `func`.
	 *
	 * @private
	 * @param {Function} func The function to inspect.
	 * @returns {*} Returns the placeholder value.
	 */
	function getHolder(func) {
	  var object = func;
	  return object.placeholder;
	}

	module.exports = getHolder;


/***/ },
/* 193 */
/***/ function(module, exports, __webpack_require__) {

	var copyArray = __webpack_require__(181),
	    isIndex = __webpack_require__(36);

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeMin = Math.min;

	/**
	 * Reorder `array` according to the specified indexes where the element at
	 * the first index is assigned as the first element, the element at
	 * the second index is assigned as the second element, and so on.
	 *
	 * @private
	 * @param {Array} array The array to reorder.
	 * @param {Array} indexes The arranged array indexes.
	 * @returns {Array} Returns `array`.
	 */
	function reorder(array, indexes) {
	  var arrLength = array.length,
	      length = nativeMin(indexes.length, arrLength),
	      oldArray = copyArray(array);

	  while (length--) {
	    var index = indexes[length];
	    array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
	  }
	  return array;
	}

	module.exports = reorder;


/***/ },
/* 194 */
/***/ function(module, exports) {

	/** Used as the internal argument placeholder. */
	var PLACEHOLDER = '__lodash_placeholder__';

	/**
	 * Replaces all `placeholder` elements in `array` with an internal placeholder
	 * and returns an array of their indexes.
	 *
	 * @private
	 * @param {Array} array The array to modify.
	 * @param {*} placeholder The placeholder to replace.
	 * @returns {Array} Returns the new array of placeholder indexes.
	 */
	function replaceHolders(array, placeholder) {
	  var index = -1,
	      length = array.length,
	      resIndex = 0,
	      result = [];

	  while (++index < length) {
	    var value = array[index];
	    if (value === placeholder || value === PLACEHOLDER) {
	      array[index] = PLACEHOLDER;
	      result[resIndex++] = index;
	    }
	  }
	  return result;
	}

	module.exports = replaceHolders;


/***/ },
/* 195 */
/***/ function(module, exports, __webpack_require__) {

	var apply = __webpack_require__(153),
	    createCtor = __webpack_require__(163),
	    root = __webpack_require__(64);

	/** Used to compose bitmasks for function metadata. */
	var BIND_FLAG = 1;

	/**
	 * Creates a function that wraps `func` to invoke it with the `this` binding
	 * of `thisArg` and `partials` prepended to the arguments it receives.
	 *
	 * @private
	 * @param {Function} func The function to wrap.
	 * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
	 * @param {*} thisArg The `this` binding of `func`.
	 * @param {Array} partials The arguments to prepend to those provided to
	 *  the new function.
	 * @returns {Function} Returns the new wrapped function.
	 */
	function createPartial(func, bitmask, thisArg, partials) {
	  var isBind = bitmask & BIND_FLAG,
	      Ctor = createCtor(func);

	  function wrapper() {
	    var argsIndex = -1,
	        argsLength = arguments.length,
	        leftIndex = -1,
	        leftLength = partials.length,
	        args = Array(leftLength + argsLength),
	        fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;

	    while (++leftIndex < leftLength) {
	      args[leftIndex] = partials[leftIndex];
	    }
	    while (argsLength--) {
	      args[leftIndex++] = arguments[++argsIndex];
	    }
	    return apply(fn, isBind ? thisArg : this, args);
	  }
	  return wrapper;
	}

	module.exports = createPartial;


/***/ },
/* 196 */
/***/ function(module, exports, __webpack_require__) {

	var composeArgs = __webpack_require__(167),
	    composeArgsRight = __webpack_require__(168),
	    replaceHolders = __webpack_require__(194);

	/** Used as the internal argument placeholder. */
	var PLACEHOLDER = '__lodash_placeholder__';

	/** Used to compose bitmasks for function metadata. */
	var BIND_FLAG = 1,
	    BIND_KEY_FLAG = 2,
	    CURRY_BOUND_FLAG = 4,
	    CURRY_FLAG = 8,
	    ARY_FLAG = 128,
	    REARG_FLAG = 256;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeMin = Math.min;

	/**
	 * Merges the function metadata of `source` into `data`.
	 *
	 * Merging metadata reduces the number of wrappers used to invoke a function.
	 * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
	 * may be applied regardless of execution order. Methods like `_.ary` and
	 * `_.rearg` modify function arguments, making the order in which they are
	 * executed important, preventing the merging of metadata. However, we make
	 * an exception for a safe combined case where curried functions have `_.ary`
	 * and or `_.rearg` applied.
	 *
	 * @private
	 * @param {Array} data The destination metadata.
	 * @param {Array} source The source metadata.
	 * @returns {Array} Returns `data`.
	 */
	function mergeData(data, source) {
	  var bitmask = data[1],
	      srcBitmask = source[1],
	      newBitmask = bitmask | srcBitmask,
	      isCommon = newBitmask < (BIND_FLAG | BIND_KEY_FLAG | ARY_FLAG);

	  var isCombo =
	    ((srcBitmask == ARY_FLAG) && (bitmask == CURRY_FLAG)) ||
	    ((srcBitmask == ARY_FLAG) && (bitmask == REARG_FLAG) && (data[7].length <= source[8])) ||
	    ((srcBitmask == (ARY_FLAG | REARG_FLAG)) && (source[7].length <= source[8]) && (bitmask == CURRY_FLAG));

	  // Exit early if metadata can't be merged.
	  if (!(isCommon || isCombo)) {
	    return data;
	  }
	  // Use source `thisArg` if available.
	  if (srcBitmask & BIND_FLAG) {
	    data[2] = source[2];
	    // Set when currying a bound function.
	    newBitmask |= bitmask & BIND_FLAG ? 0 : CURRY_BOUND_FLAG;
	  }
	  // Compose partial arguments.
	  var value = source[3];
	  if (value) {
	    var partials = data[3];
	    data[3] = partials ? composeArgs(partials, value, source[4]) : value;
	    data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
	  }
	  // Compose partial right arguments.
	  value = source[5];
	  if (value) {
	    partials = data[5];
	    data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
	    data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
	  }
	  // Use source `argPos` if available.
	  value = source[7];
	  if (value) {
	    data[7] = value;
	  }
	  // Use source `ary` if it's smaller.
	  if (srcBitmask & ARY_FLAG) {
	    data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
	  }
	  // Use source `arity` if one is not provided.
	  if (data[9] == null) {
	    data[9] = source[9];
	  }
	  // Use source `func` and merge bitmasks.
	  data[0] = source[0];
	  data[1] = newBitmask;

	  return data;
	}

	module.exports = mergeData;


/***/ },
/* 197 */
/***/ function(module, exports, __webpack_require__) {

	var toFinite = __webpack_require__(198);

	/**
	 * Converts `value` to an integer.
	 *
	 * **Note:** This method is loosely based on
	 * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to convert.
	 * @returns {number} Returns the converted integer.
	 * @example
	 *
	 * _.toInteger(3.2);
	 * // => 3
	 *
	 * _.toInteger(Number.MIN_VALUE);
	 * // => 0
	 *
	 * _.toInteger(Infinity);
	 * // => 1.7976931348623157e+308
	 *
	 * _.toInteger('3.2');
	 * // => 3
	 */
	function toInteger(value) {
	  var result = toFinite(value),
	      remainder = result % 1;

	  return result === result ? (remainder ? result - remainder : result) : 0;
	}

	module.exports = toInteger;


/***/ },
/* 198 */
/***/ function(module, exports, __webpack_require__) {

	var toNumber = __webpack_require__(199);

	/** Used as references for various `Number` constants. */
	var INFINITY = 1 / 0,
	    MAX_INTEGER = 1.7976931348623157e+308;

	/**
	 * Converts `value` to a finite number.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.12.0
	 * @category Lang
	 * @param {*} value The value to convert.
	 * @returns {number} Returns the converted number.
	 * @example
	 *
	 * _.toFinite(3.2);
	 * // => 3.2
	 *
	 * _.toFinite(Number.MIN_VALUE);
	 * // => 5e-324
	 *
	 * _.toFinite(Infinity);
	 * // => 1.7976931348623157e+308
	 *
	 * _.toFinite('3.2');
	 * // => 3.2
	 */
	function toFinite(value) {
	  if (!value) {
	    return value === 0 ? value : 0;
	  }
	  value = toNumber(value);
	  if (value === INFINITY || value === -INFINITY) {
	    var sign = (value < 0 ? -1 : 1);
	    return sign * MAX_INTEGER;
	  }
	  return value === value ? value : 0;
	}

	module.exports = toFinite;


/***/ },
/* 199 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(32),
	    isSymbol = __webpack_require__(120);

	/** Used as references for various `Number` constants. */
	var NAN = 0 / 0;

	/** Used to match leading and trailing whitespace. */
	var reTrim = /^\s+|\s+$/g;

	/** Used to detect bad signed hexadecimal string values. */
	var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

	/** Used to detect binary string values. */
	var reIsBinary = /^0b[01]+$/i;

	/** Used to detect octal string values. */
	var reIsOctal = /^0o[0-7]+$/i;

	/** Built-in method references without a dependency on `root`. */
	var freeParseInt = parseInt;

	/**
	 * Converts `value` to a number.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to process.
	 * @returns {number} Returns the number.
	 * @example
	 *
	 * _.toNumber(3.2);
	 * // => 3.2
	 *
	 * _.toNumber(Number.MIN_VALUE);
	 * // => 5e-324
	 *
	 * _.toNumber(Infinity);
	 * // => Infinity
	 *
	 * _.toNumber('3.2');
	 * // => 3.2
	 */
	function toNumber(value) {
	  if (typeof value == 'number') {
	    return value;
	  }
	  if (isSymbol(value)) {
	    return NAN;
	  }
	  if (isObject(value)) {
	    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
	    value = isObject(other) ? (other + '') : other;
	  }
	  if (typeof value != 'string') {
	    return value === 0 ? value : +value;
	  }
	  value = value.replace(reTrim, '');
	  var isBinary = reIsBinary.test(value);
	  return (isBinary || reIsOctal.test(value))
	    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
	    : (reIsBadHex.test(value) ? NAN : +value);
	}

	module.exports = toNumber;


/***/ },
/* 200 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.getActiveUser = getActiveUser;
	exports.setActiveUser = setActiveUser;
	exports.getIdentitySession = getIdentitySession;
	exports.setIdentitySession = setIdentitySession;

	var _localStorage = __webpack_require__(201);

	var _localStorage2 = _interopRequireDefault(_localStorage);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var userCollectionName = process && process.env && process.env.KINVEY_USER_COLLECTION_NAME || 'kinvey_user' || 'kinvey_user';

	/**
	 * @private
	 */
	function getActiveUser(client) {
	  return _localStorage2.default.get('' + client.appKey + userCollectionName);
	}

	/**
	 * @private
	 */
	function setActiveUser(client, data) {
	  if (data) {
	    try {
	      return _localStorage2.default.set('' + client.appKey + userCollectionName, data);
	    } catch (error) {
	      return false;
	    }
	  }

	  return _localStorage2.default.remove('' + client.appKey + userCollectionName);
	}

	/**
	 * @private
	 */
	function getIdentitySession(client, identity) {
	  return _localStorage2.default.get('' + client.appKey + identity);
	}

	/**
	 * @private
	 */
	function setIdentitySession(client, identity, session) {
	  if (session) {
	    try {
	      return _localStorage2.default.set('' + client.appKey + identity, session);
	    } catch (error) {
	      return false;
	    }
	  }

	  return _localStorage2.default.remove('' + client.appKey + identity);
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 201 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';

	var stub = __webpack_require__(202);
	var tracking = __webpack_require__(203);
	var ls = 'localStorage' in global && global.localStorage ? global.localStorage : stub;

	function accessor (key, value) {
	  if (arguments.length === 1) {
	    return get(key);
	  }
	  return set(key, value);
	}

	function get (key) {
	  return JSON.parse(ls.getItem(key));
	}

	function set (key, value) {
	  try {
	    ls.setItem(key, JSON.stringify(value));
	    return true;
	  } catch (e) {
	    return false;
	  }
	}

	function remove (key) {
	  return ls.removeItem(key);
	}

	function clear () {
	  return ls.clear();
	}

	accessor.set = set;
	accessor.get = get;
	accessor.remove = remove;
	accessor.clear = clear;
	accessor.on = tracking.on;
	accessor.off = tracking.off;

	module.exports = accessor;

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 202 */
/***/ function(module, exports) {

	'use strict';

	var ms = {};

	function getItem (key) {
	  return key in ms ? ms[key] : null;
	}

	function setItem (key, value) {
	  ms[key] = value;
	  return true;
	}

	function removeItem (key) {
	  var found = key in ms;
	  if (found) {
	    return delete ms[key];
	  }
	  return false;
	}

	function clear () {
	  ms = {};
	  return true;
	}

	module.exports = {
	  getItem: getItem,
	  setItem: setItem,
	  removeItem: removeItem,
	  clear: clear
	};


/***/ },
/* 203 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';

	var listeners = {};
	var listening = false;

	function listen () {
	  if (global.addEventListener) {
	    global.addEventListener('storage', change, false);
	  } else if (global.attachEvent) {
	    global.attachEvent('onstorage', change);
	  } else {
	    global.onstorage = change;
	  }
	}

	function change (e) {
	  if (!e) {
	    e = global.event;
	  }
	  var all = listeners[e.key];
	  if (all) {
	    all.forEach(fire);
	  }

	  function fire (listener) {
	    listener(JSON.parse(e.newValue), JSON.parse(e.oldValue), e.url || e.uri);
	  }
	}

	function on (key, fn) {
	  if (listeners[key]) {
	    listeners[key].push(fn);
	  } else {
	    listeners[key] = [fn];
	  }
	  if (listening === false) {
	    listen();
	  }
	}

	function off (key, fn) {
	  var ns = listeners[key];
	  if (ns.length > 1) {
	    ns.splice(ns.indexOf(fn), 1);
	  } else {
	    listeners[key] = [];
	  }
	}

	module.exports = {
	  on: on,
	  off: off
	};

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 204 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.randomString = randomString;

	var _uid = __webpack_require__(205);

	var _uid2 = _interopRequireDefault(_uid);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * @private
	 */
	function randomString(size) {
	  var prefix = arguments.length <= 1 || arguments[1] === undefined ? '' : arguments[1];

	  return '' + prefix + (0, _uid2.default)(size);
	}

/***/ },
/* 205 */
/***/ function(module, exports) {

	/**
	 * Export `uid`
	 */

	module.exports = uid;

	/**
	 * Create a `uid`
	 *
	 * @param {String} len
	 * @return {String} uid
	 */

	function uid(len) {
	  len = len || 7;
	  return Math.random().toString(35).substr(2, len);
	}


/***/ },
/* 206 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	var punycode = __webpack_require__(207);

	exports.parse = urlParse;
	exports.resolve = urlResolve;
	exports.resolveObject = urlResolveObject;
	exports.format = urlFormat;

	exports.Url = Url;

	function Url() {
	  this.protocol = null;
	  this.slashes = null;
	  this.auth = null;
	  this.host = null;
	  this.port = null;
	  this.hostname = null;
	  this.hash = null;
	  this.search = null;
	  this.query = null;
	  this.pathname = null;
	  this.path = null;
	  this.href = null;
	}

	// Reference: RFC 3986, RFC 1808, RFC 2396

	// define these here so at least they only have to be
	// compiled once on the first module load.
	var protocolPattern = /^([a-z0-9.+-]+:)/i,
	    portPattern = /:[0-9]*$/,

	    // RFC 2396: characters reserved for delimiting URLs.
	    // We actually just auto-escape these.
	    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

	    // RFC 2396: characters not allowed for various reasons.
	    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

	    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
	    autoEscape = ['\''].concat(unwise),
	    // Characters that are never ever allowed in a hostname.
	    // Note that any invalid chars are also handled, but these
	    // are the ones that are *expected* to be seen, so we fast-path
	    // them.
	    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
	    hostEndingChars = ['/', '?', '#'],
	    hostnameMaxLen = 255,
	    hostnamePartPattern = /^[a-z0-9A-Z_-]{0,63}$/,
	    hostnamePartStart = /^([a-z0-9A-Z_-]{0,63})(.*)$/,
	    // protocols that can allow "unsafe" and "unwise" chars.
	    unsafeProtocol = {
	      'javascript': true,
	      'javascript:': true
	    },
	    // protocols that never have a hostname.
	    hostlessProtocol = {
	      'javascript': true,
	      'javascript:': true
	    },
	    // protocols that always contain a // bit.
	    slashedProtocol = {
	      'http': true,
	      'https': true,
	      'ftp': true,
	      'gopher': true,
	      'file': true,
	      'http:': true,
	      'https:': true,
	      'ftp:': true,
	      'gopher:': true,
	      'file:': true
	    },
	    querystring = __webpack_require__(208);

	function urlParse(url, parseQueryString, slashesDenoteHost) {
	  if (url && isObject(url) && url instanceof Url) return url;

	  var u = new Url;
	  u.parse(url, parseQueryString, slashesDenoteHost);
	  return u;
	}

	Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
	  if (!isString(url)) {
	    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
	  }

	  var rest = url;

	  // trim before proceeding.
	  // This is to support parse stuff like "  http://foo.com  \n"
	  rest = rest.trim();

	  var proto = protocolPattern.exec(rest);
	  if (proto) {
	    proto = proto[0];
	    var lowerProto = proto.toLowerCase();
	    this.protocol = lowerProto;
	    rest = rest.substr(proto.length);
	  }

	  // figure out if it's got a host
	  // user@server is *always* interpreted as a hostname, and url
	  // resolution will treat //foo/bar as host=foo,path=bar because that's
	  // how the browser resolves relative URLs.
	  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
	    var slashes = rest.substr(0, 2) === '//';
	    if (slashes && !(proto && hostlessProtocol[proto])) {
	      rest = rest.substr(2);
	      this.slashes = true;
	    }
	  }

	  if (!hostlessProtocol[proto] &&
	      (slashes || (proto && !slashedProtocol[proto]))) {

	    // there's a hostname.
	    // the first instance of /, ?, ;, or # ends the host.
	    //
	    // If there is an @ in the hostname, then non-host chars *are* allowed
	    // to the left of the last @ sign, unless some host-ending character
	    // comes *before* the @-sign.
	    // URLs are obnoxious.
	    //
	    // ex:
	    // http://a@b@c/ => user:a@b host:c
	    // http://a@b?@c => user:a host:c path:/?@c

	    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
	    // Review our test case against browsers more comprehensively.

	    // find the first instance of any hostEndingChars
	    var hostEnd = -1;
	    for (var i = 0; i < hostEndingChars.length; i++) {
	      var hec = rest.indexOf(hostEndingChars[i]);
	      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
	        hostEnd = hec;
	    }

	    // at this point, either we have an explicit point where the
	    // auth portion cannot go past, or the last @ char is the decider.
	    var auth, atSign;
	    if (hostEnd === -1) {
	      // atSign can be anywhere.
	      atSign = rest.lastIndexOf('@');
	    } else {
	      // atSign must be in auth portion.
	      // http://a@b/c@d => host:b auth:a path:/c@d
	      atSign = rest.lastIndexOf('@', hostEnd);
	    }

	    // Now we have a portion which is definitely the auth.
	    // Pull that off.
	    if (atSign !== -1) {
	      auth = rest.slice(0, atSign);
	      rest = rest.slice(atSign + 1);
	      this.auth = decodeURIComponent(auth);
	    }

	    // the host is the remaining to the left of the first non-host char
	    hostEnd = -1;
	    for (var i = 0; i < nonHostChars.length; i++) {
	      var hec = rest.indexOf(nonHostChars[i]);
	      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
	        hostEnd = hec;
	    }
	    // if we still have not hit it, then the entire thing is a host.
	    if (hostEnd === -1)
	      hostEnd = rest.length;

	    this.host = rest.slice(0, hostEnd);
	    rest = rest.slice(hostEnd);

	    // pull out port.
	    this.parseHost();

	    // we've indicated that there is a hostname,
	    // so even if it's empty, it has to be present.
	    this.hostname = this.hostname || '';

	    // if hostname begins with [ and ends with ]
	    // assume that it's an IPv6 address.
	    var ipv6Hostname = this.hostname[0] === '[' &&
	        this.hostname[this.hostname.length - 1] === ']';

	    // validate a little.
	    if (!ipv6Hostname) {
	      var hostparts = this.hostname.split(/\./);
	      for (var i = 0, l = hostparts.length; i < l; i++) {
	        var part = hostparts[i];
	        if (!part) continue;
	        if (!part.match(hostnamePartPattern)) {
	          var newpart = '';
	          for (var j = 0, k = part.length; j < k; j++) {
	            if (part.charCodeAt(j) > 127) {
	              // we replace non-ASCII char with a temporary placeholder
	              // we need this to make sure size of hostname is not
	              // broken by replacing non-ASCII by nothing
	              newpart += 'x';
	            } else {
	              newpart += part[j];
	            }
	          }
	          // we test again with ASCII char only
	          if (!newpart.match(hostnamePartPattern)) {
	            var validParts = hostparts.slice(0, i);
	            var notHost = hostparts.slice(i + 1);
	            var bit = part.match(hostnamePartStart);
	            if (bit) {
	              validParts.push(bit[1]);
	              notHost.unshift(bit[2]);
	            }
	            if (notHost.length) {
	              rest = '/' + notHost.join('.') + rest;
	            }
	            this.hostname = validParts.join('.');
	            break;
	          }
	        }
	      }
	    }

	    if (this.hostname.length > hostnameMaxLen) {
	      this.hostname = '';
	    } else {
	      // hostnames are always lower case.
	      this.hostname = this.hostname.toLowerCase();
	    }

	    if (!ipv6Hostname) {
	      // IDNA Support: Returns a puny coded representation of "domain".
	      // It only converts the part of the domain name that
	      // has non ASCII characters. I.e. it dosent matter if
	      // you call it with a domain that already is in ASCII.
	      var domainArray = this.hostname.split('.');
	      var newOut = [];
	      for (var i = 0; i < domainArray.length; ++i) {
	        var s = domainArray[i];
	        newOut.push(s.match(/[^A-Za-z0-9_-]/) ?
	            'xn--' + punycode.encode(s) : s);
	      }
	      this.hostname = newOut.join('.');
	    }

	    var p = this.port ? ':' + this.port : '';
	    var h = this.hostname || '';
	    this.host = h + p;
	    this.href += this.host;

	    // strip [ and ] from the hostname
	    // the host field still retains them, though
	    if (ipv6Hostname) {
	      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
	      if (rest[0] !== '/') {
	        rest = '/' + rest;
	      }
	    }
	  }

	  // now rest is set to the post-host stuff.
	  // chop off any delim chars.
	  if (!unsafeProtocol[lowerProto]) {

	    // First, make 100% sure that any "autoEscape" chars get
	    // escaped, even if encodeURIComponent doesn't think they
	    // need to be.
	    for (var i = 0, l = autoEscape.length; i < l; i++) {
	      var ae = autoEscape[i];
	      var esc = encodeURIComponent(ae);
	      if (esc === ae) {
	        esc = escape(ae);
	      }
	      rest = rest.split(ae).join(esc);
	    }
	  }


	  // chop off from the tail first.
	  var hash = rest.indexOf('#');
	  if (hash !== -1) {
	    // got a fragment string.
	    this.hash = rest.substr(hash);
	    rest = rest.slice(0, hash);
	  }
	  var qm = rest.indexOf('?');
	  if (qm !== -1) {
	    this.search = rest.substr(qm);
	    this.query = rest.substr(qm + 1);
	    if (parseQueryString) {
	      this.query = querystring.parse(this.query);
	    }
	    rest = rest.slice(0, qm);
	  } else if (parseQueryString) {
	    // no query string, but parseQueryString still requested
	    this.search = '';
	    this.query = {};
	  }
	  if (rest) this.pathname = rest;
	  if (slashedProtocol[lowerProto] &&
	      this.hostname && !this.pathname) {
	    this.pathname = '/';
	  }

	  //to support http.request
	  if (this.pathname || this.search) {
	    var p = this.pathname || '';
	    var s = this.search || '';
	    this.path = p + s;
	  }

	  // finally, reconstruct the href based on what has been validated.
	  this.href = this.format();
	  return this;
	};

	// format a parsed object into a url string
	function urlFormat(obj) {
	  // ensure it's an object, and not a string url.
	  // If it's an obj, this is a no-op.
	  // this way, you can call url_format() on strings
	  // to clean up potentially wonky urls.
	  if (isString(obj)) obj = urlParse(obj);
	  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
	  return obj.format();
	}

	Url.prototype.format = function() {
	  var auth = this.auth || '';
	  if (auth) {
	    auth = encodeURIComponent(auth);
	    auth = auth.replace(/%3A/i, ':');
	    auth += '@';
	  }

	  var protocol = this.protocol || '',
	      pathname = this.pathname || '',
	      hash = this.hash || '',
	      host = false,
	      query = '';

	  if (this.host) {
	    host = auth + this.host;
	  } else if (this.hostname) {
	    host = auth + (this.hostname.indexOf(':') === -1 ?
	        this.hostname :
	        '[' + this.hostname + ']');
	    if (this.port) {
	      host += ':' + this.port;
	    }
	  }

	  if (this.query &&
	      isObject(this.query) &&
	      Object.keys(this.query).length) {
	    query = querystring.stringify(this.query);
	  }

	  var search = this.search || (query && ('?' + query)) || '';

	  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

	  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
	  // unless they had them to begin with.
	  if (this.slashes ||
	      (!protocol || slashedProtocol[protocol]) && host !== false) {
	    host = '//' + (host || '');
	    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
	  } else if (!host) {
	    host = '';
	  }

	  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
	  if (search && search.charAt(0) !== '?') search = '?' + search;

	  pathname = pathname.replace(/[?#]/g, function(match) {
	    return encodeURIComponent(match);
	  });
	  search = search.replace('#', '%23');

	  return protocol + host + pathname + search + hash;
	};

	function urlResolve(source, relative) {
	  return urlParse(source, false, true).resolve(relative);
	}

	Url.prototype.resolve = function(relative) {
	  return this.resolveObject(urlParse(relative, false, true)).format();
	};

	function urlResolveObject(source, relative) {
	  if (!source) return relative;
	  return urlParse(source, false, true).resolveObject(relative);
	}

	Url.prototype.resolveObject = function(relative) {
	  if (isString(relative)) {
	    var rel = new Url();
	    rel.parse(relative, false, true);
	    relative = rel;
	  }

	  var result = new Url();
	  Object.keys(this).forEach(function(k) {
	    result[k] = this[k];
	  }, this);

	  // hash is always overridden, no matter what.
	  // even href="" will remove it.
	  result.hash = relative.hash;

	  // if the relative url is empty, then there's nothing left to do here.
	  if (relative.href === '') {
	    result.href = result.format();
	    return result;
	  }

	  // hrefs like //foo/bar always cut to the protocol.
	  if (relative.slashes && !relative.protocol) {
	    // take everything except the protocol from relative
	    Object.keys(relative).forEach(function(k) {
	      if (k !== 'protocol')
	        result[k] = relative[k];
	    });

	    //urlParse appends trailing / to urls like http://www.example.com
	    if (slashedProtocol[result.protocol] &&
	        result.hostname && !result.pathname) {
	      result.path = result.pathname = '/';
	    }

	    result.href = result.format();
	    return result;
	  }

	  if (relative.protocol && relative.protocol !== result.protocol) {
	    // if it's a known url protocol, then changing
	    // the protocol does weird things
	    // first, if it's not file:, then we MUST have a host,
	    // and if there was a path
	    // to begin with, then we MUST have a path.
	    // if it is file:, then the host is dropped,
	    // because that's known to be hostless.
	    // anything else is assumed to be absolute.
	    if (!slashedProtocol[relative.protocol]) {
	      Object.keys(relative).forEach(function(k) {
	        result[k] = relative[k];
	      });
	      result.href = result.format();
	      return result;
	    }

	    result.protocol = relative.protocol;
	    if (!relative.host && !hostlessProtocol[relative.protocol]) {
	      var relPath = (relative.pathname || '').split('/');
	      while (relPath.length && !(relative.host = relPath.shift()));
	      if (!relative.host) relative.host = '';
	      if (!relative.hostname) relative.hostname = '';
	      if (relPath[0] !== '') relPath.unshift('');
	      if (relPath.length < 2) relPath.unshift('');
	      result.pathname = relPath.join('/');
	    } else {
	      result.pathname = relative.pathname;
	    }
	    result.search = relative.search;
	    result.query = relative.query;
	    result.host = relative.host || '';
	    result.auth = relative.auth;
	    result.hostname = relative.hostname || relative.host;
	    result.port = relative.port;
	    // to support http.request
	    if (result.pathname || result.search) {
	      var p = result.pathname || '';
	      var s = result.search || '';
	      result.path = p + s;
	    }
	    result.slashes = result.slashes || relative.slashes;
	    result.href = result.format();
	    return result;
	  }

	  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
	      isRelAbs = (
	          relative.host ||
	          relative.pathname && relative.pathname.charAt(0) === '/'
	      ),
	      mustEndAbs = (isRelAbs || isSourceAbs ||
	                    (result.host && relative.pathname)),
	      removeAllDots = mustEndAbs,
	      srcPath = result.pathname && result.pathname.split('/') || [],
	      relPath = relative.pathname && relative.pathname.split('/') || [],
	      psychotic = result.protocol && !slashedProtocol[result.protocol];

	  // if the url is a non-slashed url, then relative
	  // links like ../.. should be able
	  // to crawl up to the hostname, as well.  This is strange.
	  // result.protocol has already been set by now.
	  // Later on, put the first path part into the host field.
	  if (psychotic) {
	    result.hostname = '';
	    result.port = null;
	    if (result.host) {
	      if (srcPath[0] === '') srcPath[0] = result.host;
	      else srcPath.unshift(result.host);
	    }
	    result.host = '';
	    if (relative.protocol) {
	      relative.hostname = null;
	      relative.port = null;
	      if (relative.host) {
	        if (relPath[0] === '') relPath[0] = relative.host;
	        else relPath.unshift(relative.host);
	      }
	      relative.host = null;
	    }
	    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
	  }

	  if (isRelAbs) {
	    // it's absolute.
	    result.host = (relative.host || relative.host === '') ?
	                  relative.host : result.host;
	    result.hostname = (relative.hostname || relative.hostname === '') ?
	                      relative.hostname : result.hostname;
	    result.search = relative.search;
	    result.query = relative.query;
	    srcPath = relPath;
	    // fall through to the dot-handling below.
	  } else if (relPath.length) {
	    // it's relative
	    // throw away the existing file, and take the new path instead.
	    if (!srcPath) srcPath = [];
	    srcPath.pop();
	    srcPath = srcPath.concat(relPath);
	    result.search = relative.search;
	    result.query = relative.query;
	  } else if (!isNullOrUndefined(relative.search)) {
	    // just pull out the search.
	    // like href='?foo'.
	    // Put this after the other two cases because it simplifies the booleans
	    if (psychotic) {
	      result.hostname = result.host = srcPath.shift();
	      //occationaly the auth can get stuck only in host
	      //this especialy happens in cases like
	      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
	      var authInHost = result.host && result.host.indexOf('@') > 0 ?
	                       result.host.split('@') : false;
	      if (authInHost) {
	        result.auth = authInHost.shift();
	        result.host = result.hostname = authInHost.shift();
	      }
	    }
	    result.search = relative.search;
	    result.query = relative.query;
	    //to support http.request
	    if (!isNull(result.pathname) || !isNull(result.search)) {
	      result.path = (result.pathname ? result.pathname : '') +
	                    (result.search ? result.search : '');
	    }
	    result.href = result.format();
	    return result;
	  }

	  if (!srcPath.length) {
	    // no path at all.  easy.
	    // we've already handled the other stuff above.
	    result.pathname = null;
	    //to support http.request
	    if (result.search) {
	      result.path = '/' + result.search;
	    } else {
	      result.path = null;
	    }
	    result.href = result.format();
	    return result;
	  }

	  // if a url ENDs in . or .., then it must get a trailing slash.
	  // however, if it ends in anything else non-slashy,
	  // then it must NOT get a trailing slash.
	  var last = srcPath.slice(-1)[0];
	  var hasTrailingSlash = (
	      (result.host || relative.host) && (last === '.' || last === '..') ||
	      last === '');

	  // strip single dots, resolve double dots to parent dir
	  // if the path tries to go above the root, `up` ends up > 0
	  var up = 0;
	  for (var i = srcPath.length; i >= 0; i--) {
	    last = srcPath[i];
	    if (last == '.') {
	      srcPath.splice(i, 1);
	    } else if (last === '..') {
	      srcPath.splice(i, 1);
	      up++;
	    } else if (up) {
	      srcPath.splice(i, 1);
	      up--;
	    }
	  }

	  // if the path is allowed to go above the root, restore leading ..s
	  if (!mustEndAbs && !removeAllDots) {
	    for (; up--; up) {
	      srcPath.unshift('..');
	    }
	  }

	  if (mustEndAbs && srcPath[0] !== '' &&
	      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
	    srcPath.unshift('');
	  }

	  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
	    srcPath.push('');
	  }

	  var isAbsolute = srcPath[0] === '' ||
	      (srcPath[0] && srcPath[0].charAt(0) === '/');

	  // put the host back
	  if (psychotic) {
	    result.hostname = result.host = isAbsolute ? '' :
	                                    srcPath.length ? srcPath.shift() : '';
	    //occationaly the auth can get stuck only in host
	    //this especialy happens in cases like
	    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
	    var authInHost = result.host && result.host.indexOf('@') > 0 ?
	                     result.host.split('@') : false;
	    if (authInHost) {
	      result.auth = authInHost.shift();
	      result.host = result.hostname = authInHost.shift();
	    }
	  }

	  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

	  if (mustEndAbs && !isAbsolute) {
	    srcPath.unshift('');
	  }

	  if (!srcPath.length) {
	    result.pathname = null;
	    result.path = null;
	  } else {
	    result.pathname = srcPath.join('/');
	  }

	  //to support request.http
	  if (!isNull(result.pathname) || !isNull(result.search)) {
	    result.path = (result.pathname ? result.pathname : '') +
	                  (result.search ? result.search : '');
	  }
	  result.auth = relative.auth || result.auth;
	  result.slashes = result.slashes || relative.slashes;
	  result.href = result.format();
	  return result;
	};

	Url.prototype.parseHost = function() {
	  var host = this.host;
	  var port = portPattern.exec(host);
	  if (port) {
	    port = port[0];
	    if (port !== ':') {
	      this.port = port.substr(1);
	    }
	    host = host.substr(0, host.length - port.length);
	  }
	  if (host) this.hostname = host;
	};

	function isString(arg) {
	  return typeof arg === "string";
	}

	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}

	function isNull(arg) {
	  return arg === null;
	}
	function isNullOrUndefined(arg) {
	  return  arg == null;
	}


/***/ },
/* 207 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {/*! https://mths.be/punycode v1.3.2 by @mathias */
	;(function(root) {

		/** Detect free variables */
		var freeExports = typeof exports == 'object' && exports &&
			!exports.nodeType && exports;
		var freeModule = typeof module == 'object' && module &&
			!module.nodeType && module;
		var freeGlobal = typeof global == 'object' && global;
		if (
			freeGlobal.global === freeGlobal ||
			freeGlobal.window === freeGlobal ||
			freeGlobal.self === freeGlobal
		) {
			root = freeGlobal;
		}

		/**
		 * The `punycode` object.
		 * @name punycode
		 * @type Object
		 */
		var punycode,

		/** Highest positive signed 32-bit float value */
		maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

		/** Bootstring parameters */
		base = 36,
		tMin = 1,
		tMax = 26,
		skew = 38,
		damp = 700,
		initialBias = 72,
		initialN = 128, // 0x80
		delimiter = '-', // '\x2D'

		/** Regular expressions */
		regexPunycode = /^xn--/,
		regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
		regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

		/** Error messages */
		errors = {
			'overflow': 'Overflow: input needs wider integers to process',
			'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
			'invalid-input': 'Invalid input'
		},

		/** Convenience shortcuts */
		baseMinusTMin = base - tMin,
		floor = Math.floor,
		stringFromCharCode = String.fromCharCode,

		/** Temporary variable */
		key;

		/*--------------------------------------------------------------------------*/

		/**
		 * A generic error utility function.
		 * @private
		 * @param {String} type The error type.
		 * @returns {Error} Throws a `RangeError` with the applicable error message.
		 */
		function error(type) {
			throw RangeError(errors[type]);
		}

		/**
		 * A generic `Array#map` utility function.
		 * @private
		 * @param {Array} array The array to iterate over.
		 * @param {Function} callback The function that gets called for every array
		 * item.
		 * @returns {Array} A new array of values returned by the callback function.
		 */
		function map(array, fn) {
			var length = array.length;
			var result = [];
			while (length--) {
				result[length] = fn(array[length]);
			}
			return result;
		}

		/**
		 * A simple `Array#map`-like wrapper to work with domain name strings or email
		 * addresses.
		 * @private
		 * @param {String} domain The domain name or email address.
		 * @param {Function} callback The function that gets called for every
		 * character.
		 * @returns {Array} A new string of characters returned by the callback
		 * function.
		 */
		function mapDomain(string, fn) {
			var parts = string.split('@');
			var result = '';
			if (parts.length > 1) {
				// In email addresses, only the domain name should be punycoded. Leave
				// the local part (i.e. everything up to `@`) intact.
				result = parts[0] + '@';
				string = parts[1];
			}
			// Avoid `split(regex)` for IE8 compatibility. See #17.
			string = string.replace(regexSeparators, '\x2E');
			var labels = string.split('.');
			var encoded = map(labels, fn).join('.');
			return result + encoded;
		}

		/**
		 * Creates an array containing the numeric code points of each Unicode
		 * character in the string. While JavaScript uses UCS-2 internally,
		 * this function will convert a pair of surrogate halves (each of which
		 * UCS-2 exposes as separate characters) into a single code point,
		 * matching UTF-16.
		 * @see `punycode.ucs2.encode`
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode.ucs2
		 * @name decode
		 * @param {String} string The Unicode input string (UCS-2).
		 * @returns {Array} The new array of code points.
		 */
		function ucs2decode(string) {
			var output = [],
			    counter = 0,
			    length = string.length,
			    value,
			    extra;
			while (counter < length) {
				value = string.charCodeAt(counter++);
				if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
					// high surrogate, and there is a next character
					extra = string.charCodeAt(counter++);
					if ((extra & 0xFC00) == 0xDC00) { // low surrogate
						output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
					} else {
						// unmatched surrogate; only append this code unit, in case the next
						// code unit is the high surrogate of a surrogate pair
						output.push(value);
						counter--;
					}
				} else {
					output.push(value);
				}
			}
			return output;
		}

		/**
		 * Creates a string based on an array of numeric code points.
		 * @see `punycode.ucs2.decode`
		 * @memberOf punycode.ucs2
		 * @name encode
		 * @param {Array} codePoints The array of numeric code points.
		 * @returns {String} The new Unicode string (UCS-2).
		 */
		function ucs2encode(array) {
			return map(array, function(value) {
				var output = '';
				if (value > 0xFFFF) {
					value -= 0x10000;
					output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
					value = 0xDC00 | value & 0x3FF;
				}
				output += stringFromCharCode(value);
				return output;
			}).join('');
		}

		/**
		 * Converts a basic code point into a digit/integer.
		 * @see `digitToBasic()`
		 * @private
		 * @param {Number} codePoint The basic numeric code point value.
		 * @returns {Number} The numeric value of a basic code point (for use in
		 * representing integers) in the range `0` to `base - 1`, or `base` if
		 * the code point does not represent a value.
		 */
		function basicToDigit(codePoint) {
			if (codePoint - 48 < 10) {
				return codePoint - 22;
			}
			if (codePoint - 65 < 26) {
				return codePoint - 65;
			}
			if (codePoint - 97 < 26) {
				return codePoint - 97;
			}
			return base;
		}

		/**
		 * Converts a digit/integer into a basic code point.
		 * @see `basicToDigit()`
		 * @private
		 * @param {Number} digit The numeric value of a basic code point.
		 * @returns {Number} The basic code point whose value (when used for
		 * representing integers) is `digit`, which needs to be in the range
		 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
		 * used; else, the lowercase form is used. The behavior is undefined
		 * if `flag` is non-zero and `digit` has no uppercase form.
		 */
		function digitToBasic(digit, flag) {
			//  0..25 map to ASCII a..z or A..Z
			// 26..35 map to ASCII 0..9
			return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
		}

		/**
		 * Bias adaptation function as per section 3.4 of RFC 3492.
		 * http://tools.ietf.org/html/rfc3492#section-3.4
		 * @private
		 */
		function adapt(delta, numPoints, firstTime) {
			var k = 0;
			delta = firstTime ? floor(delta / damp) : delta >> 1;
			delta += floor(delta / numPoints);
			for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
				delta = floor(delta / baseMinusTMin);
			}
			return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
		}

		/**
		 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
		 * symbols.
		 * @memberOf punycode
		 * @param {String} input The Punycode string of ASCII-only symbols.
		 * @returns {String} The resulting string of Unicode symbols.
		 */
		function decode(input) {
			// Don't use UCS-2
			var output = [],
			    inputLength = input.length,
			    out,
			    i = 0,
			    n = initialN,
			    bias = initialBias,
			    basic,
			    j,
			    index,
			    oldi,
			    w,
			    k,
			    digit,
			    t,
			    /** Cached calculation results */
			    baseMinusT;

			// Handle the basic code points: let `basic` be the number of input code
			// points before the last delimiter, or `0` if there is none, then copy
			// the first basic code points to the output.

			basic = input.lastIndexOf(delimiter);
			if (basic < 0) {
				basic = 0;
			}

			for (j = 0; j < basic; ++j) {
				// if it's not a basic code point
				if (input.charCodeAt(j) >= 0x80) {
					error('not-basic');
				}
				output.push(input.charCodeAt(j));
			}

			// Main decoding loop: start just after the last delimiter if any basic code
			// points were copied; start at the beginning otherwise.

			for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

				// `index` is the index of the next character to be consumed.
				// Decode a generalized variable-length integer into `delta`,
				// which gets added to `i`. The overflow checking is easier
				// if we increase `i` as we go, then subtract off its starting
				// value at the end to obtain `delta`.
				for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

					if (index >= inputLength) {
						error('invalid-input');
					}

					digit = basicToDigit(input.charCodeAt(index++));

					if (digit >= base || digit > floor((maxInt - i) / w)) {
						error('overflow');
					}

					i += digit * w;
					t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

					if (digit < t) {
						break;
					}

					baseMinusT = base - t;
					if (w > floor(maxInt / baseMinusT)) {
						error('overflow');
					}

					w *= baseMinusT;

				}

				out = output.length + 1;
				bias = adapt(i - oldi, out, oldi == 0);

				// `i` was supposed to wrap around from `out` to `0`,
				// incrementing `n` each time, so we'll fix that now:
				if (floor(i / out) > maxInt - n) {
					error('overflow');
				}

				n += floor(i / out);
				i %= out;

				// Insert `n` at position `i` of the output
				output.splice(i++, 0, n);

			}

			return ucs2encode(output);
		}

		/**
		 * Converts a string of Unicode symbols (e.g. a domain name label) to a
		 * Punycode string of ASCII-only symbols.
		 * @memberOf punycode
		 * @param {String} input The string of Unicode symbols.
		 * @returns {String} The resulting Punycode string of ASCII-only symbols.
		 */
		function encode(input) {
			var n,
			    delta,
			    handledCPCount,
			    basicLength,
			    bias,
			    j,
			    m,
			    q,
			    k,
			    t,
			    currentValue,
			    output = [],
			    /** `inputLength` will hold the number of code points in `input`. */
			    inputLength,
			    /** Cached calculation results */
			    handledCPCountPlusOne,
			    baseMinusT,
			    qMinusT;

			// Convert the input in UCS-2 to Unicode
			input = ucs2decode(input);

			// Cache the length
			inputLength = input.length;

			// Initialize the state
			n = initialN;
			delta = 0;
			bias = initialBias;

			// Handle the basic code points
			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue < 0x80) {
					output.push(stringFromCharCode(currentValue));
				}
			}

			handledCPCount = basicLength = output.length;

			// `handledCPCount` is the number of code points that have been handled;
			// `basicLength` is the number of basic code points.

			// Finish the basic string - if it is not empty - with a delimiter
			if (basicLength) {
				output.push(delimiter);
			}

			// Main encoding loop:
			while (handledCPCount < inputLength) {

				// All non-basic code points < n have been handled already. Find the next
				// larger one:
				for (m = maxInt, j = 0; j < inputLength; ++j) {
					currentValue = input[j];
					if (currentValue >= n && currentValue < m) {
						m = currentValue;
					}
				}

				// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
				// but guard against overflow
				handledCPCountPlusOne = handledCPCount + 1;
				if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
					error('overflow');
				}

				delta += (m - n) * handledCPCountPlusOne;
				n = m;

				for (j = 0; j < inputLength; ++j) {
					currentValue = input[j];

					if (currentValue < n && ++delta > maxInt) {
						error('overflow');
					}

					if (currentValue == n) {
						// Represent delta as a generalized variable-length integer
						for (q = delta, k = base; /* no condition */; k += base) {
							t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
							if (q < t) {
								break;
							}
							qMinusT = q - t;
							baseMinusT = base - t;
							output.push(
								stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
							);
							q = floor(qMinusT / baseMinusT);
						}

						output.push(stringFromCharCode(digitToBasic(q, 0)));
						bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
						delta = 0;
						++handledCPCount;
					}
				}

				++delta;
				++n;

			}
			return output.join('');
		}

		/**
		 * Converts a Punycode string representing a domain name or an email address
		 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
		 * it doesn't matter if you call it on a string that has already been
		 * converted to Unicode.
		 * @memberOf punycode
		 * @param {String} input The Punycoded domain name or email address to
		 * convert to Unicode.
		 * @returns {String} The Unicode representation of the given Punycode
		 * string.
		 */
		function toUnicode(input) {
			return mapDomain(input, function(string) {
				return regexPunycode.test(string)
					? decode(string.slice(4).toLowerCase())
					: string;
			});
		}

		/**
		 * Converts a Unicode string representing a domain name or an email address to
		 * Punycode. Only the non-ASCII parts of the domain name will be converted,
		 * i.e. it doesn't matter if you call it with a domain that's already in
		 * ASCII.
		 * @memberOf punycode
		 * @param {String} input The domain name or email address to convert, as a
		 * Unicode string.
		 * @returns {String} The Punycode representation of the given domain name or
		 * email address.
		 */
		function toASCII(input) {
			return mapDomain(input, function(string) {
				return regexNonASCII.test(string)
					? 'xn--' + encode(string)
					: string;
			});
		}

		/*--------------------------------------------------------------------------*/

		/** Define the public API */
		punycode = {
			/**
			 * A string representing the current Punycode.js version number.
			 * @memberOf punycode
			 * @type String
			 */
			'version': '1.3.2',
			/**
			 * An object of methods to convert from JavaScript's internal character
			 * representation (UCS-2) to Unicode code points, and back.
			 * @see <https://mathiasbynens.be/notes/javascript-encoding>
			 * @memberOf punycode
			 * @type Object
			 */
			'ucs2': {
				'decode': ucs2decode,
				'encode': ucs2encode
			},
			'decode': decode,
			'encode': encode,
			'toASCII': toASCII,
			'toUnicode': toUnicode
		};

		/** Expose `punycode` */
		// Some AMD build optimizers, like r.js, check for specific condition patterns
		// like the following:
		if (
			true
		) {
			!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
				return punycode;
			}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else if (freeExports && freeModule) {
			if (module.exports == freeExports) { // in Node.js or RingoJS v0.8.0+
				freeModule.exports = punycode;
			} else { // in Narwhal or RingoJS v0.7.0-
				for (key in punycode) {
					punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
				}
			}
		} else { // in Rhino or a web browser
			root.punycode = punycode;
		}

	}(this));

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(107)(module), (function() { return this; }())))

/***/ },
/* 208 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.decode = exports.parse = __webpack_require__(209);
	exports.encode = exports.stringify = __webpack_require__(210);


/***/ },
/* 209 */
/***/ function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	'use strict';

	// If obj.hasOwnProperty has been overridden, then calling
	// obj.hasOwnProperty(prop) will break.
	// See: https://github.com/joyent/node/issues/1707
	function hasOwnProperty(obj, prop) {
	  return Object.prototype.hasOwnProperty.call(obj, prop);
	}

	module.exports = function(qs, sep, eq, options) {
	  sep = sep || '&';
	  eq = eq || '=';
	  var obj = {};

	  if (typeof qs !== 'string' || qs.length === 0) {
	    return obj;
	  }

	  var regexp = /\+/g;
	  qs = qs.split(sep);

	  var maxKeys = 1000;
	  if (options && typeof options.maxKeys === 'number') {
	    maxKeys = options.maxKeys;
	  }

	  var len = qs.length;
	  // maxKeys <= 0 means that we should not limit keys count
	  if (maxKeys > 0 && len > maxKeys) {
	    len = maxKeys;
	  }

	  for (var i = 0; i < len; ++i) {
	    var x = qs[i].replace(regexp, '%20'),
	        idx = x.indexOf(eq),
	        kstr, vstr, k, v;

	    if (idx >= 0) {
	      kstr = x.substr(0, idx);
	      vstr = x.substr(idx + 1);
	    } else {
	      kstr = x;
	      vstr = '';
	    }

	    k = decodeURIComponent(kstr);
	    v = decodeURIComponent(vstr);

	    if (!hasOwnProperty(obj, k)) {
	      obj[k] = v;
	    } else if (Array.isArray(obj[k])) {
	      obj[k].push(v);
	    } else {
	      obj[k] = [obj[k], v];
	    }
	  }

	  return obj;
	};


/***/ },
/* 210 */
/***/ function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	'use strict';

	var stringifyPrimitive = function(v) {
	  switch (typeof v) {
	    case 'string':
	      return v;

	    case 'boolean':
	      return v ? 'true' : 'false';

	    case 'number':
	      return isFinite(v) ? v : '';

	    default:
	      return '';
	  }
	};

	module.exports = function(obj, sep, eq, name) {
	  sep = sep || '&';
	  eq = eq || '=';
	  if (obj === null) {
	    obj = undefined;
	  }

	  if (typeof obj === 'object') {
	    return Object.keys(obj).map(function(k) {
	      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
	      if (Array.isArray(obj[k])) {
	        return obj[k].map(function(v) {
	          return ks + encodeURIComponent(stringifyPrimitive(v));
	        }).join(sep);
	      } else {
	        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
	      }
	    }).join(sep);

	  }

	  if (!name) return '';
	  return encodeURIComponent(stringifyPrimitive(name)) + eq +
	         encodeURIComponent(stringifyPrimitive(obj));
	};


/***/ },
/* 211 */
/***/ function(module, exports, __webpack_require__) {

	var assignValue = __webpack_require__(212),
	    copyObject = __webpack_require__(214),
	    createAssigner = __webpack_require__(215),
	    isArrayLike = __webpack_require__(30),
	    isPrototype = __webpack_require__(38),
	    keys = __webpack_require__(25);

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Assigns own enumerable string keyed properties of source objects to the
	 * destination object. Source objects are applied from left to right.
	 * Subsequent sources overwrite property assignments of previous sources.
	 *
	 * **Note:** This method mutates `object` and is loosely based on
	 * [`Object.assign`](https://mdn.io/Object/assign).
	 *
	 * @static
	 * @memberOf _
	 * @since 0.10.0
	 * @category Object
	 * @param {Object} object The destination object.
	 * @param {...Object} [sources] The source objects.
	 * @returns {Object} Returns `object`.
	 * @see _.assignIn
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 * }
	 *
	 * function Bar() {
	 *   this.c = 3;
	 * }
	 *
	 * Foo.prototype.b = 2;
	 * Bar.prototype.d = 4;
	 *
	 * _.assign({ 'a': 0 }, new Foo, new Bar);
	 * // => { 'a': 1, 'c': 3 }
	 */
	var assign = createAssigner(function(object, source) {
	  if (isPrototype(source) || isArrayLike(source)) {
	    copyObject(source, keys(source), object);
	    return;
	  }
	  for (var key in source) {
	    if (hasOwnProperty.call(source, key)) {
	      assignValue(object, key, source[key]);
	    }
	  }
	});

	module.exports = assign;


/***/ },
/* 212 */
/***/ function(module, exports, __webpack_require__) {

	var baseAssignValue = __webpack_require__(213),
	    eq = __webpack_require__(50);

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Assigns `value` to `key` of `object` if the existing value is not equivalent
	 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * for equality comparisons.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {string} key The key of the property to assign.
	 * @param {*} value The value to assign.
	 */
	function assignValue(object, key, value) {
	  var objValue = object[key];
	  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
	      (value === undefined && !(key in object))) {
	    baseAssignValue(object, key, value);
	  }
	}

	module.exports = assignValue;


/***/ },
/* 213 */
/***/ function(module, exports) {

	/** Built-in value references. */
	var defineProperty = Object.defineProperty;

	/**
	 * The base implementation of `assignValue` and `assignMergeValue` without
	 * value checks.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {string} key The key of the property to assign.
	 * @param {*} value The value to assign.
	 */
	function baseAssignValue(object, key, value) {
	  if (key == '__proto__' && defineProperty) {
	    defineProperty(object, key, {
	      'configurable': true,
	      'enumerable': true,
	      'value': value,
	      'writable': true
	    });
	  } else {
	    object[key] = value;
	  }
	}

	module.exports = baseAssignValue;


/***/ },
/* 214 */
/***/ function(module, exports, __webpack_require__) {

	var assignValue = __webpack_require__(212),
	    baseAssignValue = __webpack_require__(213);

	/**
	 * Copies properties of `source` to `object`.
	 *
	 * @private
	 * @param {Object} source The object to copy properties from.
	 * @param {Array} props The property identifiers to copy.
	 * @param {Object} [object={}] The object to copy properties to.
	 * @param {Function} [customizer] The function to customize copied values.
	 * @returns {Object} Returns `object`.
	 */
	function copyObject(source, props, object, customizer) {
	  var isNew = !object;
	  object || (object = {});

	  var index = -1,
	      length = props.length;

	  while (++index < length) {
	    var key = props[index];

	    var newValue = customizer
	      ? customizer(object[key], source[key], key, object, source)
	      : undefined;

	    if (newValue === undefined) {
	      newValue = source[key];
	    }
	    if (isNew) {
	      baseAssignValue(object, key, newValue);
	    } else {
	      assignValue(object, key, newValue);
	    }
	  }
	  return object;
	}

	module.exports = copyObject;


/***/ },
/* 215 */
/***/ function(module, exports, __webpack_require__) {

	var baseRest = __webpack_require__(151),
	    isIterateeCall = __webpack_require__(216);

	/**
	 * Creates a function like `_.assign`.
	 *
	 * @private
	 * @param {Function} assigner The function to assign values.
	 * @returns {Function} Returns the new assigner function.
	 */
	function createAssigner(assigner) {
	  return baseRest(function(object, sources) {
	    var index = -1,
	        length = sources.length,
	        customizer = length > 1 ? sources[length - 1] : undefined,
	        guard = length > 2 ? sources[2] : undefined;

	    customizer = (assigner.length > 3 && typeof customizer == 'function')
	      ? (length--, customizer)
	      : undefined;

	    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
	      customizer = length < 3 ? undefined : customizer;
	      length = 1;
	    }
	    object = Object(object);
	    while (++index < length) {
	      var source = sources[index];
	      if (source) {
	        assigner(object, source, index, customizer);
	      }
	    }
	    return object;
	  });
	}

	module.exports = createAssigner;


/***/ },
/* 216 */
/***/ function(module, exports, __webpack_require__) {

	var eq = __webpack_require__(50),
	    isArrayLike = __webpack_require__(30),
	    isIndex = __webpack_require__(36),
	    isObject = __webpack_require__(32);

	/**
	 * Checks if the given arguments are from an iteratee call.
	 *
	 * @private
	 * @param {*} value The potential iteratee value argument.
	 * @param {*} index The potential iteratee index or key argument.
	 * @param {*} object The potential iteratee object argument.
	 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
	 *  else `false`.
	 */
	function isIterateeCall(value, index, object) {
	  if (!isObject(object)) {
	    return false;
	  }
	  var type = typeof index;
	  if (type == 'number'
	        ? (isArrayLike(object) && isIndex(index, object.length))
	        : (type == 'string' && index in object)
	      ) {
	    return eq(object[index], value);
	  }
	  return false;
	}

	module.exports = isIterateeCall;


/***/ },
/* 217 */
/***/ function(module, exports, __webpack_require__) {

	var isArray = __webpack_require__(35),
	    isObjectLike = __webpack_require__(34);

	/** `Object#toString` result references. */
	var stringTag = '[object String]';

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objectToString = objectProto.toString;

	/**
	 * Checks if `value` is classified as a `String` primitive or object.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a string, else `false`.
	 * @example
	 *
	 * _.isString('abc');
	 * // => true
	 *
	 * _.isString(1);
	 * // => false
	 */
	function isString(value) {
	  return typeof value == 'string' ||
	    (!isArray(value) && isObjectLike(value) && objectToString.call(value) == stringTag);
	}

	module.exports = isString;


/***/ },
/* 218 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.CustomEndpoint = undefined;

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // eslint-disable-line no-unused-vars


	var _client = __webpack_require__(10);

	var _request = __webpack_require__(219);

	var _errors = __webpack_require__(11);

	var _regeneratorRuntime = __webpack_require__(148);

	var _regeneratorRuntime2 = _interopRequireDefault(_regeneratorRuntime);

	var _url = __webpack_require__(206);

	var _url2 = _interopRequireDefault(_url);

	var _assign = __webpack_require__(211);

	var _assign2 = _interopRequireDefault(_assign);

	var _isString = __webpack_require__(217);

	var _isString2 = _interopRequireDefault(_isString);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { return step("next", value); }, function (err) { return step("throw", err); }); } } return step("next"); }); }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var rpcNamespace = process && process.env && process.env.KINVEY_RPC_NAMESPACE || 'rpc' || 'rpc';

	/**
	 * Executes a custom endpoint on the Kinvey backend.
	 */

	var CustomEndpoint = exports.CustomEndpoint = function () {
	  function CustomEndpoint() {
	    _classCallCheck(this, CustomEndpoint);

	    throw new _errors.KinveyError('Not allowed to create an instance of the `CustomEndpoint` class.', 'Please use `CustomEndpoint.execute()` function.');
	  }
	  /**
	   * Execute a custom endpoint. A promise will be returned that will be resolved
	   * with the result of the command or rejected with an error.
	   *
	   * @param   {String}          endpoint                          Endpoint to execute.
	   * @param   {Object}          [args]                            Command arguments
	   * @param   {Object}          [options={}]                      Options
	   * @param   {Properties}      [options.properties]              Custom properties to send with
	   *                                                              the request.
	   * @param   {Number}          [options.timeout]                 Timeout for the request.
	   * @return  {Promise}                                           Promise
	   *
	   * @example
	   * var promise = CustomEndpoint.execute('myCustomEndpoint').then(function(data) {
	   *   ...
	   * }).catch(function(error) {
	   *   ...
	   * });
	   */


	  _createClass(CustomEndpoint, null, [{
	    key: 'execute',
	    value: function () {
	      var _ref = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee(endpoint, args) {
	        var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];
	        var request, response;
	        return _regeneratorRuntime2.default.wrap(function _callee$(_context) {
	          while (1) {
	            switch (_context.prev = _context.next) {
	              case 0:
	                options = (0, _assign2.default)({
	                  client: _client.Client.sharedInstance()
	                }, options);

	                if (endpoint) {
	                  _context.next = 3;
	                  break;
	                }

	                throw new _errors.KinveyError('An endpoint argument is required.');

	              case 3:
	                if ((0, _isString2.default)(endpoint)) {
	                  _context.next = 5;
	                  break;
	                }

	                throw new _errors.KinveyError('The endpoint argument must be a string.');

	              case 5:
	                request = new _request.KinveyRequest({
	                  method: _request.RequestMethod.POST,
	                  authType: _request.AuthType.Default,
	                  url: _url2.default.format({
	                    protocol: options.client.protocol,
	                    host: options.client.host,
	                    pathname: '/' + rpcNamespace + '/' + options.client.appKey + '/custom/' + endpoint
	                  }),
	                  properties: options.properties,
	                  body: args,
	                  timeout: options.timeout,
	                  client: options.client
	                });
	                _context.next = 8;
	                return request.execute();

	              case 8:
	                response = _context.sent;
	                return _context.abrupt('return', response.data);

	              case 10:
	              case 'end':
	                return _context.stop();
	            }
	          }
	        }, _callee, this);
	      }));

	      function execute(_x, _x2, _x3) {
	        return _ref.apply(this, arguments);
	      }

	      return execute;
	    }()
	  }]);

	  return CustomEndpoint;
	}();
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 219 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.StatusCode = exports.Response = exports.RequestMethod = exports.Properties = exports.NetworkRequest = exports.KinveyResponse = exports.KinveyRequest = exports.Headers = exports.DeltaFetchRequest = exports.CacheRequest = exports.AuthType = undefined;

	var _cacherequest = __webpack_require__(220);

	var _cacherequest2 = _interopRequireDefault(_cacherequest);

	var _deltafetchrequest = __webpack_require__(408);

	var _deltafetchrequest2 = _interopRequireDefault(_deltafetchrequest);

	var _headers = __webpack_require__(223);

	var _headers2 = _interopRequireDefault(_headers);

	var _kinveyrequest = __webpack_require__(409);

	var _kinveyrequest2 = _interopRequireDefault(_kinveyrequest);

	var _kinveyresponse = __webpack_require__(233);

	var _kinveyresponse2 = _interopRequireDefault(_kinveyresponse);

	var _networkrequest = __webpack_require__(410);

	var _networkrequest2 = _interopRequireDefault(_networkrequest);

	var _request = __webpack_require__(221);

	var _request2 = _interopRequireDefault(_request);

	var _response = __webpack_require__(222);

	var _response2 = _interopRequireDefault(_response);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	// Export
	exports.AuthType = _kinveyrequest.AuthType;
	exports.CacheRequest = _cacherequest2.default;
	exports.DeltaFetchRequest = _deltafetchrequest2.default;
	exports.Headers = _headers2.default;
	exports.KinveyRequest = _kinveyrequest2.default;
	exports.KinveyResponse = _kinveyresponse2.default;
	exports.NetworkRequest = _networkrequest2.default;
	exports.Properties = _kinveyrequest.Properties;
	exports.RequestMethod = _request.RequestMethod;
	exports.Response = _response2.default;
	exports.StatusCode = _response.StatusCode;

	// Export default

	exports.default = _request2.default;

/***/ },
/* 220 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _set = function set(object, property, value, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent !== null) { set(parent, property, value, receiver); } } else if ("value" in desc && desc.writable) { desc.value = value; } else { var setter = desc.set; if (setter !== undefined) { setter.call(receiver, value); } } return value; };

	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _request = __webpack_require__(221);

	var _request2 = _interopRequireDefault(_request);

	var _kinveyresponse = __webpack_require__(233);

	var _kinveyresponse2 = _interopRequireDefault(_kinveyresponse);

	var _errors = __webpack_require__(11);

	var _client = __webpack_require__(10);

	var _kinveyJavascriptRack = __webpack_require__(234);

	var _urlPattern = __webpack_require__(406);

	var _urlPattern2 = _interopRequireDefault(_urlPattern);

	var _url = __webpack_require__(206);

	var _url2 = _interopRequireDefault(_url);

	var _assign = __webpack_require__(211);

	var _assign2 = _interopRequireDefault(_assign);

	var _regeneratorRuntime = __webpack_require__(148);

	var _regeneratorRuntime2 = _interopRequireDefault(_regeneratorRuntime);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { return step("next", value); }, function (err) { return step("throw", err); }); } } return step("next"); }); }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	// eslint-disable-line no-unused-vars

	/**
	 * @private
	 */
	var CacheRequest = function (_Request) {
	  _inherits(CacheRequest, _Request);

	  function CacheRequest() {
	    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

	    _classCallCheck(this, CacheRequest);

	    // Set default options
	    var _this = _possibleConstructorReturn(this, (CacheRequest.__proto__ || Object.getPrototypeOf(CacheRequest)).call(this, options));

	    options = (0, _assign2.default)({
	      query: null,
	      client: _client.Client.sharedInstance()
	    }, options);

	    _this.query = options.query;
	    _this.client = options.client;
	    _this.rack = new _kinveyJavascriptRack.CacheRack();
	    return _this;
	  }

	  _createClass(CacheRequest, [{
	    key: 'execute',
	    value: function () {
	      var _ref = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee() {
	        var response;
	        return _regeneratorRuntime2.default.wrap(function _callee$(_context) {
	          while (1) {
	            switch (_context.prev = _context.next) {
	              case 0:
	                _context.next = 2;
	                return _get(CacheRequest.prototype.__proto__ || Object.getPrototypeOf(CacheRequest.prototype), 'execute', this).call(this);

	              case 2:
	                response = _context.sent;


	                if (!(response instanceof _kinveyresponse2.default)) {
	                  response = new _kinveyresponse2.default({
	                    statusCode: response.statusCode,
	                    headers: response.headers,
	                    data: response.data
	                  });
	                }

	                // Throw the response error if we did not receive
	                // a successfull response

	                if (response.isSuccess()) {
	                  _context.next = 6;
	                  break;
	                }

	                throw response.error;

	              case 6:

	                // If a query was provided then process the data with the query
	                if (this.query) {
	                  response.data = this.query.process(response.data);
	                }

	                // Just return the response
	                return _context.abrupt('return', response);

	              case 8:
	              case 'end':
	                return _context.stop();
	            }
	          }
	        }, _callee, this);
	      }));

	      function execute() {
	        return _ref.apply(this, arguments);
	      }

	      return execute;
	    }()
	  }, {
	    key: 'cancel',
	    value: function () {
	      var _ref2 = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee2() {
	        return _regeneratorRuntime2.default.wrap(function _callee2$(_context2) {
	          while (1) {
	            switch (_context2.prev = _context2.next) {
	              case 0:
	                _context2.next = 2;
	                return _get(CacheRequest.prototype.__proto__ || Object.getPrototypeOf(CacheRequest.prototype), 'cancel', this).call(this);

	              case 2:
	                return _context2.abrupt('return', this.rack.cancel());

	              case 3:
	              case 'end':
	                return _context2.stop();
	            }
	          }
	        }, _callee2, this);
	      }));

	      function cancel() {
	        return _ref2.apply(this, arguments);
	      }

	      return cancel;
	    }()
	  }, {
	    key: 'toPlainObject',
	    value: function toPlainObject() {
	      var obj = _get(CacheRequest.prototype.__proto__ || Object.getPrototypeOf(CacheRequest.prototype), 'toPlainObject', this).call(this);
	      obj.appKey = this.appKey;
	      obj.collection = this.collection;
	      obj.entityId = this.entityId;
	      obj.encryptionKey = this.client ? this.client.encryptionKey : undefined;
	      return obj;
	    }
	  }, {
	    key: 'url',
	    get: function get() {
	      return _get(CacheRequest.prototype.__proto__ || Object.getPrototypeOf(CacheRequest.prototype), 'url', this);
	    },
	    set: function set(urlString) {
	      _set(CacheRequest.prototype.__proto__ || Object.getPrototypeOf(CacheRequest.prototype), 'url', urlString, this);
	      var pathname = global.escape(_url2.default.parse(urlString).pathname);
	      var pattern = new _urlPattern2.default('(/:namespace)(/)(:appKey)(/)(:collection)(/)(:entityId)(/)');

	      var _ref3 = pattern.match(pathname) || {};

	      var appKey = _ref3.appKey;
	      var collection = _ref3.collection;
	      var entityId = _ref3.entityId;

	      this.appKey = appKey;
	      this.collection = collection;
	      this.entityId = entityId;
	    }
	  }, {
	    key: 'client',
	    get: function get() {
	      return this._client;
	    },
	    set: function set(client) {
	      if (client) {
	        if (!(client instanceof _client.Client)) {
	          throw new _errors.KinveyError('client must be an instance of the Client class.');
	        }
	      }

	      this._client = client;
	    }
	  }]);

	  return CacheRequest;
	}(_request2.default);

	exports.default = CacheRequest;
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 221 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.RequestMethod = undefined;

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // eslint-disable-line no-unused-vars


	var _errors = __webpack_require__(11);

	var _response = __webpack_require__(222);

	var _response2 = _interopRequireDefault(_response);

	var _headers = __webpack_require__(223);

	var _headers2 = _interopRequireDefault(_headers);

	var _regeneratorRuntime = __webpack_require__(148);

	var _regeneratorRuntime2 = _interopRequireDefault(_regeneratorRuntime);

	var _qs = __webpack_require__(226);

	var _qs2 = _interopRequireDefault(_qs);

	var _appendQuery = __webpack_require__(230);

	var _appendQuery2 = _interopRequireDefault(_appendQuery);

	var _assign = __webpack_require__(211);

	var _assign2 = _interopRequireDefault(_assign);

	var _isString = __webpack_require__(217);

	var _isString2 = _interopRequireDefault(_isString);

	var _isNumber = __webpack_require__(232);

	var _isNumber2 = _interopRequireDefault(_isNumber);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { return step("next", value); }, function (err) { return step("throw", err); }); } } return step("next"); }); }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var defaultTimeout = process && process.env && process.env.KINVEY_DEFAULT_TIMEOUT || '30' || 30;

	/**
	 * @private
	 * Enum for Request Methods.
	 */
	var RequestMethod = {
	  GET: 'GET',
	  POST: 'POST',
	  PATCH: 'PATCH',
	  PUT: 'PUT',
	  DELETE: 'DELETE'
	};
	Object.freeze(RequestMethod);
	exports.RequestMethod = RequestMethod;

	/**
	 * @private
	 */

	var Request = function () {
	  function Request() {
	    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

	    _classCallCheck(this, Request);

	    options = (0, _assign2.default)({
	      method: RequestMethod.GET,
	      headers: new _headers2.default(),
	      url: '',
	      body: null,
	      timeout: defaultTimeout,
	      followRedirect: true,
	      cache: false
	    }, options);

	    this.method = options.method;
	    this.headers = options.headers;
	    this.url = options.url;
	    this.body = options.body || options.data;
	    this.timeout = options.timeout;
	    this.followRedirect = options.followRedirect;
	    this.cache = options.cache;
	    this.executing = false;
	  }

	  _createClass(Request, [{
	    key: 'isExecuting',
	    value: function isExecuting() {
	      return !!this.executing;
	    }
	  }, {
	    key: 'execute',
	    value: function () {
	      var _ref = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee() {
	        var response;
	        return _regeneratorRuntime2.default.wrap(function _callee$(_context) {
	          while (1) {
	            switch (_context.prev = _context.next) {
	              case 0:
	                if (this.rack) {
	                  _context.next = 2;
	                  break;
	                }

	                throw new _errors.KinveyError('Unable to execute the request. Please provide a rack to execute the request.');

	              case 2:
	                _context.next = 4;
	                return this.rack.execute(this.toPlainObject());

	              case 4:
	                response = _context.sent;

	                if (response) {
	                  _context.next = 7;
	                  break;
	                }

	                throw new _errors.NoResponseError();

	              case 7:

	                if (!(response instanceof _response2.default)) {
	                  response = new _response2.default({
	                    statusCode: response.statusCode,
	                    headers: response.headers,
	                    data: response.data
	                  });
	                }

	                return _context.abrupt('return', response);

	              case 9:
	              case 'end':
	                return _context.stop();
	            }
	          }
	        }, _callee, this);
	      }));

	      function execute() {
	        return _ref.apply(this, arguments);
	      }

	      return execute;
	    }()
	  }, {
	    key: 'toPlainObject',
	    value: function toPlainObject() {
	      return {
	        method: this.method,
	        headers: this.headers.toPlainObject(),
	        url: this.url,
	        body: this.body,
	        timeout: this.timeout,
	        followRedirect: this.followRedirect
	      };
	    }
	  }, {
	    key: 'method',
	    get: function get() {
	      return this._method;
	    },
	    set: function set(method) {
	      if (!(0, _isString2.default)(method)) {
	        method = String(method);
	      }

	      method = method.toUpperCase();
	      switch (method) {
	        case RequestMethod.GET:
	        case RequestMethod.POST:
	        case RequestMethod.PATCH:
	        case RequestMethod.PUT:
	        case RequestMethod.DELETE:
	          this._method = method;
	          break;
	        default:
	          throw new Error('Invalid request method. Only GET, POST, PATCH, PUT, and DELETE are allowed.');
	      }
	    }
	  }, {
	    key: 'headers',
	    get: function get() {
	      return this._headers;
	    },
	    set: function set(headers) {
	      if (!(headers instanceof _headers2.default)) {
	        headers = new _headers2.default(headers);
	      }

	      this._headers = headers;
	    }
	  }, {
	    key: 'url',
	    get: function get() {
	      // If `cache` is true, add a cache busting query string.
	      // This is useful for Android < 4.0 which caches all requests aggressively.
	      if (this.cache === true) {
	        return (0, _appendQuery2.default)(this._url, _qs2.default.stringify({
	          _: Math.random().toString(36).substr(2)
	        }));
	      }

	      return this._url;
	    },
	    set: function set(urlString) {
	      this._url = urlString;
	    }
	  }, {
	    key: 'data',
	    get: function get() {
	      return this.body;
	    },
	    set: function set(data) {
	      this.body = data;
	    }
	  }, {
	    key: 'timeout',
	    get: function get() {
	      return this._timeout;
	    },
	    set: function set(timeout) {
	      this._timeout = (0, _isNumber2.default)(timeout) ? timeout : defaultTimeout;
	    }
	  }, {
	    key: 'followRedirect',
	    get: function get() {
	      return this._followRedirect;
	    },
	    set: function set(followRedirect) {
	      this._followRedirect = !!followRedirect;
	    }
	  }, {
	    key: 'cache',
	    get: function get() {
	      return this._cache;
	    },
	    set: function set(cache) {
	      this._cache = !!cache;
	    }
	  }]);

	  return Request;
	}();

	exports.default = Request;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 222 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.StatusCode = undefined;

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _headers = __webpack_require__(223);

	var _headers2 = _interopRequireDefault(_headers);

	var _errors = __webpack_require__(11);

	var _assign = __webpack_require__(211);

	var _assign2 = _interopRequireDefault(_assign);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * @private
	 * Enum for Status Codes.
	 */
	var StatusCode = {
	  Ok: 200,
	  Created: 201,
	  Empty: 204,
	  RedirectTemporarily: 301,
	  RedirectPermanently: 302,
	  NotModified: 304,
	  ResumeIncomplete: 308,
	  NotFound: 404,
	  ServerError: 500
	};
	Object.freeze(StatusCode);
	exports.StatusCode = StatusCode;

	/**
	 * @private
	 */

	var Response = function () {
	  function Response() {
	    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

	    _classCallCheck(this, Response);

	    options = (0, _assign2.default)({
	      statusCode: StatusCode.Empty,
	      headers: new _headers2.default(),
	      data: null
	    }, options);

	    this.statusCode = options.statusCode;
	    this.headers = options.headers;
	    this.data = options.data;
	  }

	  _createClass(Response, [{
	    key: 'isSuccess',
	    value: function isSuccess() {
	      return this.statusCode >= 200 && this.statusCode < 300 || this.statusCode === StatusCode.RedirectPermanently || this.statusCode === StatusCode.NotModified;
	    }
	  }, {
	    key: 'headers',
	    get: function get() {
	      return this._headers;
	    },
	    set: function set(headers) {
	      if (!(headers instanceof _headers2.default)) {
	        headers = new _headers2.default(headers);
	      }

	      this._headers = headers;
	    }
	  }, {
	    key: 'error',
	    get: function get() {
	      if (this.isSuccess()) {
	        return null;
	      }

	      var data = this.data || {};
	      var message = data.message || data.description;
	      var debug = data.debug;
	      var code = this.statusCode;

	      return new _errors.KinveyError(message, debug, code);
	    }
	  }]);

	  return Response;
	}();

	exports.default = Response;

/***/ },
/* 223 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _forEach = __webpack_require__(19);

	var _forEach2 = _interopRequireDefault(_forEach);

	var _isString = __webpack_require__(217);

	var _isString2 = _interopRequireDefault(_isString);

	var _isPlainObject = __webpack_require__(224);

	var _isPlainObject2 = _interopRequireDefault(_isPlainObject);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var Headers = function () {
	  function Headers() {
	    var headers = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

	    _classCallCheck(this, Headers);

	    this.headers = {};
	    this.addAll(headers);
	  }

	  _createClass(Headers, [{
	    key: 'get',
	    value: function get(name) {
	      if (name) {
	        if (!(0, _isString2.default)(name)) {
	          name = String(name);
	        }

	        var headers = this.headers;
	        return headers[name.toLowerCase()];
	      }

	      return undefined;
	    }
	  }, {
	    key: 'set',
	    value: function set(name, value) {
	      if (name === undefined || name === null || value === undefined || value === null) {
	        throw new Error('A name and value must be provided to set a header.');
	      }

	      if (!(0, _isString2.default)(name)) {
	        name = String(name);
	      }

	      var headers = this.headers;
	      name = name.toLowerCase();

	      if (!(0, _isString2.default)(value)) {
	        headers[name] = JSON.stringify(value);
	      } else {
	        headers[name] = value;
	      }

	      this.headers = headers;
	      return this;
	    }
	  }, {
	    key: 'has',
	    value: function has(name) {
	      return !!this.get(name);
	    }
	  }, {
	    key: 'add',
	    value: function add() {
	      var header = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

	      return this.set(header.name, header.value);
	    }
	  }, {
	    key: 'addAll',
	    value: function addAll() {
	      var _this = this;

	      var headers = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

	      if (headers instanceof Headers) {
	        headers = headers.toPlainObject();
	      }

	      if (!(0, _isPlainObject2.default)(headers)) {
	        throw new Error('Headers argument must be an object.');
	      }

	      var names = Object.keys(headers);
	      (0, _forEach2.default)(names, function (name) {
	        var value = headers[name];
	        _this.set(name, value);
	      });
	      return this;
	    }
	  }, {
	    key: 'remove',
	    value: function remove(name) {
	      if (name) {
	        if (!(0, _isString2.default)(name)) {
	          name = String(name);
	        }

	        var headers = this.headers;
	        delete headers[name.toLowerCase()];
	        this.headers = headers;
	      }

	      return this;
	    }
	  }, {
	    key: 'clear',
	    value: function clear() {
	      this.headers = {};
	      return this;
	    }
	  }, {
	    key: 'toPlainObject',
	    value: function toPlainObject() {
	      return this.headers;
	    }
	  }, {
	    key: 'toString',
	    value: function toString() {
	      return JSON.stringify(this.toPlainObject());
	    }
	  }]);

	  return Headers;
	}();

	exports.default = Headers;

/***/ },
/* 224 */
/***/ function(module, exports, __webpack_require__) {

	var getPrototype = __webpack_require__(225),
	    isObjectLike = __webpack_require__(34);

	/** `Object#toString` result references. */
	var objectTag = '[object Object]';

	/** Used for built-in method references. */
	var funcProto = Function.prototype,
	    objectProto = Object.prototype;

	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/** Used to infer the `Object` constructor. */
	var objectCtorString = funcToString.call(Object);

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objectToString = objectProto.toString;

	/**
	 * Checks if `value` is a plain object, that is, an object created by the
	 * `Object` constructor or one with a `[[Prototype]]` of `null`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.8.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 * }
	 *
	 * _.isPlainObject(new Foo);
	 * // => false
	 *
	 * _.isPlainObject([1, 2, 3]);
	 * // => false
	 *
	 * _.isPlainObject({ 'x': 0, 'y': 0 });
	 * // => true
	 *
	 * _.isPlainObject(Object.create(null));
	 * // => true
	 */
	function isPlainObject(value) {
	  if (!isObjectLike(value) || objectToString.call(value) != objectTag) {
	    return false;
	  }
	  var proto = getPrototype(value);
	  if (proto === null) {
	    return true;
	  }
	  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
	  return (typeof Ctor == 'function' &&
	    Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString);
	}

	module.exports = isPlainObject;


/***/ },
/* 225 */
/***/ function(module, exports, __webpack_require__) {

	var overArg = __webpack_require__(40);

	/** Built-in value references. */
	var getPrototype = overArg(Object.getPrototypeOf, Object);

	module.exports = getPrototype;


/***/ },
/* 226 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Stringify = __webpack_require__(227);
	var Parse = __webpack_require__(229);

	module.exports = {
	    stringify: Stringify,
	    parse: Parse
	};


/***/ },
/* 227 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Utils = __webpack_require__(228);

	var arrayPrefixGenerators = {
	    brackets: function brackets(prefix) {
	        return prefix + '[]';
	    },
	    indices: function indices(prefix, key) {
	        return prefix + '[' + key + ']';
	    },
	    repeat: function repeat(prefix) {
	        return prefix;
	    }
	};

	var defaults = {
	    delimiter: '&',
	    strictNullHandling: false,
	    skipNulls: false,
	    encode: true,
	    encoder: Utils.encode
	};

	var stringify = function stringify(object, prefix, generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots) {
	    var obj = object;
	    if (typeof filter === 'function') {
	        obj = filter(prefix, obj);
	    } else if (obj instanceof Date) {
	        obj = obj.toISOString();
	    } else if (obj === null) {
	        if (strictNullHandling) {
	            return encoder ? encoder(prefix) : prefix;
	        }

	        obj = '';
	    }

	    if (typeof obj === 'string' || typeof obj === 'number' || typeof obj === 'boolean' || Utils.isBuffer(obj)) {
	        if (encoder) {
	            return [encoder(prefix) + '=' + encoder(obj)];
	        }
	        return [prefix + '=' + String(obj)];
	    }

	    var values = [];

	    if (typeof obj === 'undefined') {
	        return values;
	    }

	    var objKeys;
	    if (Array.isArray(filter)) {
	        objKeys = filter;
	    } else {
	        var keys = Object.keys(obj);
	        objKeys = sort ? keys.sort(sort) : keys;
	    }

	    for (var i = 0; i < objKeys.length; ++i) {
	        var key = objKeys[i];

	        if (skipNulls && obj[key] === null) {
	            continue;
	        }

	        if (Array.isArray(obj)) {
	            values = values.concat(stringify(obj[key], generateArrayPrefix(prefix, key), generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots));
	        } else {
	            values = values.concat(stringify(obj[key], prefix + (allowDots ? '.' + key : '[' + key + ']'), generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots));
	        }
	    }

	    return values;
	};

	module.exports = function (object, opts) {
	    var obj = object;
	    var options = opts || {};
	    var delimiter = typeof options.delimiter === 'undefined' ? defaults.delimiter : options.delimiter;
	    var strictNullHandling = typeof options.strictNullHandling === 'boolean' ? options.strictNullHandling : defaults.strictNullHandling;
	    var skipNulls = typeof options.skipNulls === 'boolean' ? options.skipNulls : defaults.skipNulls;
	    var encode = typeof options.encode === 'boolean' ? options.encode : defaults.encode;
	    var encoder = encode ? (typeof options.encoder === 'function' ? options.encoder : defaults.encoder) : null;
	    var sort = typeof options.sort === 'function' ? options.sort : null;
	    var allowDots = typeof options.allowDots === 'undefined' ? false : options.allowDots;
	    var objKeys;
	    var filter;

	    if (options.encoder !== null && options.encoder !== undefined && typeof options.encoder !== 'function') {
	        throw new TypeError('Encoder has to be a function.');
	    }

	    if (typeof options.filter === 'function') {
	        filter = options.filter;
	        obj = filter('', obj);
	    } else if (Array.isArray(options.filter)) {
	        objKeys = filter = options.filter;
	    }

	    var keys = [];

	    if (typeof obj !== 'object' || obj === null) {
	        return '';
	    }

	    var arrayFormat;
	    if (options.arrayFormat in arrayPrefixGenerators) {
	        arrayFormat = options.arrayFormat;
	    } else if ('indices' in options) {
	        arrayFormat = options.indices ? 'indices' : 'repeat';
	    } else {
	        arrayFormat = 'indices';
	    }

	    var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];

	    if (!objKeys) {
	        objKeys = Object.keys(obj);
	    }

	    if (sort) {
	        objKeys.sort(sort);
	    }

	    for (var i = 0; i < objKeys.length; ++i) {
	        var key = objKeys[i];

	        if (skipNulls && obj[key] === null) {
	            continue;
	        }

	        keys = keys.concat(stringify(obj[key], key, generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots));
	    }

	    return keys.join(delimiter);
	};


/***/ },
/* 228 */
/***/ function(module, exports) {

	'use strict';

	var hexTable = (function () {
	    var array = new Array(256);
	    for (var i = 0; i < 256; ++i) {
	        array[i] = '%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase();
	    }

	    return array;
	}());

	exports.arrayToObject = function (source, options) {
	    var obj = options.plainObjects ? Object.create(null) : {};
	    for (var i = 0; i < source.length; ++i) {
	        if (typeof source[i] !== 'undefined') {
	            obj[i] = source[i];
	        }
	    }

	    return obj;
	};

	exports.merge = function (target, source, options) {
	    if (!source) {
	        return target;
	    }

	    if (typeof source !== 'object') {
	        if (Array.isArray(target)) {
	            target.push(source);
	        } else if (typeof target === 'object') {
	            target[source] = true;
	        } else {
	            return [target, source];
	        }

	        return target;
	    }

	    if (typeof target !== 'object') {
	        return [target].concat(source);
	    }

	    var mergeTarget = target;
	    if (Array.isArray(target) && !Array.isArray(source)) {
	        mergeTarget = exports.arrayToObject(target, options);
	    }

	    return Object.keys(source).reduce(function (acc, key) {
	        var value = source[key];

	        if (Object.prototype.hasOwnProperty.call(acc, key)) {
	            acc[key] = exports.merge(acc[key], value, options);
	        } else {
	            acc[key] = value;
	        }
	        return acc;
	    }, mergeTarget);
	};

	exports.decode = function (str) {
	    try {
	        return decodeURIComponent(str.replace(/\+/g, ' '));
	    } catch (e) {
	        return str;
	    }
	};

	exports.encode = function (str) {
	    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.
	    // It has been adapted here for stricter adherence to RFC 3986
	    if (str.length === 0) {
	        return str;
	    }

	    var string = typeof str === 'string' ? str : String(str);

	    var out = '';
	    for (var i = 0; i < string.length; ++i) {
	        var c = string.charCodeAt(i);

	        if (
	            c === 0x2D || // -
	            c === 0x2E || // .
	            c === 0x5F || // _
	            c === 0x7E || // ~
	            (c >= 0x30 && c <= 0x39) || // 0-9
	            (c >= 0x41 && c <= 0x5A) || // a-z
	            (c >= 0x61 && c <= 0x7A) // A-Z
	        ) {
	            out += string.charAt(i);
	            continue;
	        }

	        if (c < 0x80) {
	            out = out + hexTable[c];
	            continue;
	        }

	        if (c < 0x800) {
	            out = out + (hexTable[0xC0 | (c >> 6)] + hexTable[0x80 | (c & 0x3F)]);
	            continue;
	        }

	        if (c < 0xD800 || c >= 0xE000) {
	            out = out + (hexTable[0xE0 | (c >> 12)] + hexTable[0x80 | ((c >> 6) & 0x3F)] + hexTable[0x80 | (c & 0x3F)]);
	            continue;
	        }

	        i += 1;
	        c = 0x10000 + (((c & 0x3FF) << 10) | (string.charCodeAt(i) & 0x3FF));
	        out += hexTable[0xF0 | (c >> 18)] + hexTable[0x80 | ((c >> 12) & 0x3F)] + hexTable[0x80 | ((c >> 6) & 0x3F)] + hexTable[0x80 | (c & 0x3F)];
	    }

	    return out;
	};

	exports.compact = function (obj, references) {
	    if (typeof obj !== 'object' || obj === null) {
	        return obj;
	    }

	    var refs = references || [];
	    var lookup = refs.indexOf(obj);
	    if (lookup !== -1) {
	        return refs[lookup];
	    }

	    refs.push(obj);

	    if (Array.isArray(obj)) {
	        var compacted = [];

	        for (var i = 0; i < obj.length; ++i) {
	            if (obj[i] && typeof obj[i] === 'object') {
	                compacted.push(exports.compact(obj[i], refs));
	            } else if (typeof obj[i] !== 'undefined') {
	                compacted.push(obj[i]);
	            }
	        }

	        return compacted;
	    }

	    var keys = Object.keys(obj);
	    for (var j = 0; j < keys.length; ++j) {
	        var key = keys[j];
	        obj[key] = exports.compact(obj[key], refs);
	    }

	    return obj;
	};

	exports.isRegExp = function (obj) {
	    return Object.prototype.toString.call(obj) === '[object RegExp]';
	};

	exports.isBuffer = function (obj) {
	    if (obj === null || typeof obj === 'undefined') {
	        return false;
	    }

	    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
	};


/***/ },
/* 229 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Utils = __webpack_require__(228);

	var has = Object.prototype.hasOwnProperty;

	var defaults = {
	    delimiter: '&',
	    depth: 5,
	    arrayLimit: 20,
	    parameterLimit: 1000,
	    strictNullHandling: false,
	    plainObjects: false,
	    allowPrototypes: false,
	    allowDots: false,
	    decoder: Utils.decode
	};

	var parseValues = function parseValues(str, options) {
	    var obj = {};
	    var parts = str.split(options.delimiter, options.parameterLimit === Infinity ? undefined : options.parameterLimit);

	    for (var i = 0; i < parts.length; ++i) {
	        var part = parts[i];
	        var pos = part.indexOf(']=') === -1 ? part.indexOf('=') : part.indexOf(']=') + 1;

	        var key, val;
	        if (pos === -1) {
	            key = options.decoder(part);
	            val = options.strictNullHandling ? null : '';
	        } else {
	            key = options.decoder(part.slice(0, pos));
	            val = options.decoder(part.slice(pos + 1));
	        }
	        if (has.call(obj, key)) {
	            obj[key] = [].concat(obj[key]).concat(val);
	        } else {
	            obj[key] = val;
	        }
	    }

	    return obj;
	};

	var parseObject = function parseObject(chain, val, options) {
	    if (!chain.length) {
	        return val;
	    }

	    var root = chain.shift();

	    var obj;
	    if (root === '[]') {
	        obj = [];
	        obj = obj.concat(parseObject(chain, val, options));
	    } else {
	        obj = options.plainObjects ? Object.create(null) : {};
	        var cleanRoot = root[0] === '[' && root[root.length - 1] === ']' ? root.slice(1, root.length - 1) : root;
	        var index = parseInt(cleanRoot, 10);
	        if (
	            !isNaN(index) &&
	            root !== cleanRoot &&
	            String(index) === cleanRoot &&
	            index >= 0 &&
	            (options.parseArrays && index <= options.arrayLimit)
	        ) {
	            obj = [];
	            obj[index] = parseObject(chain, val, options);
	        } else {
	            obj[cleanRoot] = parseObject(chain, val, options);
	        }
	    }

	    return obj;
	};

	var parseKeys = function parseKeys(givenKey, val, options) {
	    if (!givenKey) {
	        return;
	    }

	    // Transform dot notation to bracket notation
	    var key = options.allowDots ? givenKey.replace(/\.([^\.\[]+)/g, '[$1]') : givenKey;

	    // The regex chunks

	    var parent = /^([^\[\]]*)/;
	    var child = /(\[[^\[\]]*\])/g;

	    // Get the parent

	    var segment = parent.exec(key);

	    // Stash the parent if it exists

	    var keys = [];
	    if (segment[1]) {
	        // If we aren't using plain objects, optionally prefix keys
	        // that would overwrite object prototype properties
	        if (!options.plainObjects && has.call(Object.prototype, segment[1])) {
	            if (!options.allowPrototypes) {
	                return;
	            }
	        }

	        keys.push(segment[1]);
	    }

	    // Loop through children appending to the array until we hit depth

	    var i = 0;
	    while ((segment = child.exec(key)) !== null && i < options.depth) {
	        i += 1;
	        if (!options.plainObjects && has.call(Object.prototype, segment[1].replace(/\[|\]/g, ''))) {
	            if (!options.allowPrototypes) {
	                continue;
	            }
	        }
	        keys.push(segment[1]);
	    }

	    // If there's a remainder, just add whatever is left

	    if (segment) {
	        keys.push('[' + key.slice(segment.index) + ']');
	    }

	    return parseObject(keys, val, options);
	};

	module.exports = function (str, opts) {
	    var options = opts || {};

	    if (options.decoder !== null && options.decoder !== undefined && typeof options.decoder !== 'function') {
	        throw new TypeError('Decoder has to be a function.');
	    }

	    options.delimiter = typeof options.delimiter === 'string' || Utils.isRegExp(options.delimiter) ? options.delimiter : defaults.delimiter;
	    options.depth = typeof options.depth === 'number' ? options.depth : defaults.depth;
	    options.arrayLimit = typeof options.arrayLimit === 'number' ? options.arrayLimit : defaults.arrayLimit;
	    options.parseArrays = options.parseArrays !== false;
	    options.decoder = typeof options.decoder === 'function' ? options.decoder : defaults.decoder;
	    options.allowDots = typeof options.allowDots === 'boolean' ? options.allowDots : defaults.allowDots;
	    options.plainObjects = typeof options.plainObjects === 'boolean' ? options.plainObjects : defaults.plainObjects;
	    options.allowPrototypes = typeof options.allowPrototypes === 'boolean' ? options.allowPrototypes : defaults.allowPrototypes;
	    options.parameterLimit = typeof options.parameterLimit === 'number' ? options.parameterLimit : defaults.parameterLimit;
	    options.strictNullHandling = typeof options.strictNullHandling === 'boolean' ? options.strictNullHandling : defaults.strictNullHandling;

	    if (str === '' || str === null || typeof str === 'undefined') {
	        return options.plainObjects ? Object.create(null) : {};
	    }

	    var tempObj = typeof str === 'string' ? parseValues(str, options) : str;
	    var obj = options.plainObjects ? Object.create(null) : {};

	    // Iterate over the keys and setup the new object

	    var keys = Object.keys(tempObj);
	    for (var i = 0; i < keys.length; ++i) {
	        var key = keys[i];
	        var newObj = parseKeys(key, tempObj[key], options);
	        obj = Utils.merge(obj, newObj, options);
	    }

	    return Utils.compact(obj);
	};


/***/ },
/* 230 */
/***/ function(module, exports, __webpack_require__) {

	var querystring = __webpack_require__(208)
	  , extend = __webpack_require__(231)
	  , url = __webpack_require__(206)

	module.exports = function appendQuery(uri, q) {
	  var parts = url.parse(uri, true)
	    , parsedQuery = extend(true, {}, parts.query, typeof q === 'string' ? querystring.parse(q) : q)

	  parts.search = '?' + serialize(parsedQuery)
	  return url.format(parts)
	}

	// serialize an object recursively
	function serialize(obj, prefix) {
	  var str = []
	    , useArraySyntax = false

	  // if there's a prefix, and this object is an array, use array syntax
	  // i.e., `prefix[]=foo&prefix[]=bar` instead of `prefix[0]=foo&prefix[1]=bar`
	  if (Array.isArray(obj) && prefix) {
	    useArraySyntax = true
	  }

	  Object.keys(obj).forEach(function (prop) {
	    var key, query, val = obj[prop]

	    key = prefix ?
	      prefix + '[' + (useArraySyntax ? '' : prop) + ']' :
	      prop

	    query = typeof val === 'object' ?
	      serialize(val, key) :
	      encodeURIComponent(key) + '=' + encodeURIComponent(val)

	    str.push(query)
	  })

	  return str.join('&')
	}


/***/ },
/* 231 */
/***/ function(module, exports) {

	var hasOwn = Object.prototype.hasOwnProperty;
	var toString = Object.prototype.toString;
	var undefined;

	var isPlainObject = function isPlainObject(obj) {
		"use strict";
		if (!obj || toString.call(obj) !== '[object Object]' || obj.nodeType || obj.setInterval) {
			return false;
		}

		var has_own_constructor = hasOwn.call(obj, 'constructor');
		var has_is_property_of_method = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');
		// Not own constructor property must be Object
		if (obj.constructor && !has_own_constructor && !has_is_property_of_method) {
			return false;
		}

		// Own properties are enumerated firstly, so to speed up,
		// if last one is own, then all properties are own.
		var key;
		for (key in obj) {}

		return key === undefined || hasOwn.call(obj, key);
	};

	module.exports = function extend() {
		"use strict";
		var options, name, src, copy, copyIsArray, clone,
			target = arguments[0],
			i = 1,
			length = arguments.length,
			deep = false;

		// Handle a deep copy situation
		if (typeof target === "boolean") {
			deep = target;
			target = arguments[1] || {};
			// skip the boolean and the target
			i = 2;
		} else if (typeof target !== "object" && typeof target !== "function" || target == undefined) {
				target = {};
		}

		for (; i < length; ++i) {
			// Only deal with non-null/undefined values
			if ((options = arguments[i]) != null) {
				// Extend the base object
				for (name in options) {
					src = target[name];
					copy = options[name];

					// Prevent never-ending loop
					if (target === copy) {
						continue;
					}

					// Recurse if we're merging plain objects or arrays
					if (deep && copy && (isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {
						if (copyIsArray) {
							copyIsArray = false;
							clone = src && Array.isArray(src) ? src : [];
						} else {
							clone = src && isPlainObject(src) ? src : {};
						}

						// Never move original objects, clone them
						target[name] = extend(deep, clone, copy);

					// Don't bring in undefined values
					} else if (copy !== undefined) {
						target[name] = copy;
					}
				}
			}
		}

		// Return the modified object
		return target;
	};



/***/ },
/* 232 */
/***/ function(module, exports, __webpack_require__) {

	var isObjectLike = __webpack_require__(34);

	/** `Object#toString` result references. */
	var numberTag = '[object Number]';

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objectToString = objectProto.toString;

	/**
	 * Checks if `value` is classified as a `Number` primitive or object.
	 *
	 * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
	 * classified as numbers, use the `_.isFinite` method.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a number, else `false`.
	 * @example
	 *
	 * _.isNumber(3);
	 * // => true
	 *
	 * _.isNumber(Number.MIN_VALUE);
	 * // => true
	 *
	 * _.isNumber(Infinity);
	 * // => true
	 *
	 * _.isNumber('3');
	 * // => false
	 */
	function isNumber(value) {
	  return typeof value == 'number' ||
	    (isObjectLike(value) && objectToString.call(value) == numberTag);
	}

	module.exports = isNumber;


/***/ },
/* 233 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _errors = __webpack_require__(11);

	var _response = __webpack_require__(222);

	var _response2 = _interopRequireDefault(_response);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * @private
	 */
	var KinveyResponse = function (_Response) {
	  _inherits(KinveyResponse, _Response);

	  function KinveyResponse() {
	    _classCallCheck(this, KinveyResponse);

	    return _possibleConstructorReturn(this, (KinveyResponse.__proto__ || Object.getPrototypeOf(KinveyResponse)).apply(this, arguments));
	  }

	  _createClass(KinveyResponse, [{
	    key: 'error',
	    get: function get() {
	      if (this.isSuccess()) {
	        return null;
	      }

	      var data = this.data || {};
	      var name = data.name || data.error;
	      var message = data.message || data.description;
	      var debug = data.debug;
	      var code = this.statusCode;

	      if (name === 'FeatureUnavailableError') {
	        return new _errors.FeatureUnavailableError(message, debug, code);
	      } else if (name === 'IncompleteRequestBodyError') {
	        return new _errors.IncompleteRequestBodyError(message, debug, code);
	      } else if (name === 'InsufficientCredentials') {
	        return new _errors.InsufficientCredentialsError(message, debug, code);
	      } else if (name === 'InvalidCredentials') {
	        return new _errors.InvalidCredentialsError(message, debug, code);
	      } else if (name === 'InvalidIdentifierError') {
	        return new _errors.InvalidIdentifierError(message, debug, code);
	      } else if (name === 'InvalidQuerySyntaxError') {
	        return new _errors.InvalidQuerySyntaxError(message, debug, code);
	      } else if (name === 'JSONParseError') {
	        return new _errors.JSONParseError(message, debug, code);
	      } else if (name === 'MissingQueryError') {
	        return new _errors.MissingQueryError(message, debug, code);
	      } else if (name === 'MissingRequestHeaderError') {
	        return new _errors.MissingRequestHeaderError(message, debug, code);
	      } else if (name === 'MissingRequestParameterError') {
	        return new _errors.MissingRequestParameterError(message, debug, code);
	      } else if (name === 'EntityNotFound' || name === 'CollectionNotFound' || name === 'AppNotFound' || name === 'UserNotFound' || name === 'BlobNotFound' || name === 'DocumentNotFound' || code === _response.StatusCode.NotFound) {
	        return new _errors.NotFoundError(message, debug, code);
	      } else if (name === 'ParameterValueOutOfRangeError') {
	        return new _errors.ParameterValueOutOfRangeError(message, debug, code);
	      } else if (name === 'ServerError' || code === _response.StatusCode.ServerError) {
	        return new _errors.ServerError(message, debug, code);
	      }

	      return _get(KinveyResponse.prototype.__proto__ || Object.getPrototypeOf(KinveyResponse.prototype), 'error', this);
	    }
	  }]);

	  return KinveyResponse;
	}(_response2.default);

	exports.default = KinveyResponse;

/***/ },
/* 234 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.NetworkRack = exports.Middleware = exports.CacheRack = undefined;

	var _middleware = __webpack_require__(235);

	var _rack = __webpack_require__(403);

	var _rack2 = _interopRequireDefault(_rack);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	// Export
	exports.CacheRack = _rack.CacheRack;
	exports.Middleware = _middleware.Middleware;
	exports.NetworkRack = _rack.NetworkRack;

	// Export default

	exports.default = _rack2.default;

/***/ },
/* 235 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.SerializeMiddleware = exports.ParseMiddleware = exports.HttpMiddleware = exports.CacheMiddleware = undefined;

	var _cache = __webpack_require__(236);

	var _cache2 = _interopRequireDefault(_cache);

	var _middleware = __webpack_require__(239);

	var _middleware2 = _interopRequireDefault(_middleware);

	var _http = __webpack_require__(360);

	var _http2 = _interopRequireDefault(_http);

	var _parse = __webpack_require__(401);

	var _parse2 = _interopRequireDefault(_parse);

	var _serialize = __webpack_require__(402);

	var _serialize2 = _interopRequireDefault(_serialize);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	// Export
	exports.CacheMiddleware = _cache2.default;
	exports.HttpMiddleware = _http2.default;
	exports.ParseMiddleware = _parse2.default;
	exports.SerializeMiddleware = _serialize2.default;

	// Export default

	exports.default = _middleware2.default;

/***/ },
/* 236 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _errors = __webpack_require__(237);

	var _middleware = __webpack_require__(239);

	var _middleware2 = _interopRequireDefault(_middleware);

	var _storage = __webpack_require__(241);

	var _storage2 = _interopRequireDefault(_storage);

	var _regeneratorRuntime = __webpack_require__(148);

	var _regeneratorRuntime2 = _interopRequireDefault(_regeneratorRuntime);

	var _isEmpty = __webpack_require__(359);

	var _isEmpty2 = _interopRequireDefault(_isEmpty);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { return step("next", value); }, function (err) { return step("throw", err); }); } } return step("next"); }); }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // eslint-disable-line no-unused-vars


	var CacheMiddleware = function (_Middleware) {
	  _inherits(CacheMiddleware, _Middleware);

	  function CacheMiddleware() {
	    var name = arguments.length <= 0 || arguments[0] === undefined ? 'Cache Middleware' : arguments[0];

	    _classCallCheck(this, CacheMiddleware);

	    return _possibleConstructorReturn(this, (CacheMiddleware.__proto__ || Object.getPrototypeOf(CacheMiddleware)).call(this, name));
	  }

	  _createClass(CacheMiddleware, [{
	    key: 'handle',
	    value: function () {
	      var _ref = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee(request) {
	        var method, body, appKey, collection, entityId, storage, data, response;
	        return _regeneratorRuntime2.default.wrap(function _callee$(_context) {
	          while (1) {
	            switch (_context.prev = _context.next) {
	              case 0:
	                method = request.method;
	                body = request.body;
	                appKey = request.appKey;
	                collection = request.collection;
	                entityId = request.entityId;
	                storage = new _storage2.default(appKey);
	                data = void 0;
	                response = {
	                  statusCode: method === 'POST' ? 201 : 200,
	                  headers: {},
	                  data: data
	                };
	                _context.prev = 8;

	                if (!(method === 'GET')) {
	                  _context.next = 21;
	                  break;
	                }

	                if (!entityId) {
	                  _context.next = 16;
	                  break;
	                }

	                _context.next = 13;
	                return storage.findById(collection, entityId);

	              case 13:
	                data = _context.sent;
	                _context.next = 19;
	                break;

	              case 16:
	                _context.next = 18;
	                return storage.find(collection);

	              case 18:
	                data = _context.sent;

	              case 19:
	                _context.next = 43;
	                break;

	              case 21:
	                if (!(method === 'POST' || method === 'PUT')) {
	                  _context.next = 27;
	                  break;
	                }

	                _context.next = 24;
	                return storage.save(collection, body);

	              case 24:
	                data = _context.sent;
	                _context.next = 43;
	                break;

	              case 27:
	                if (!(method === 'DELETE')) {
	                  _context.next = 43;
	                  break;
	                }

	                if (!(collection && entityId)) {
	                  _context.next = 34;
	                  break;
	                }

	                _context.next = 31;
	                return storage.removeById(collection, entityId);

	              case 31:
	                data = _context.sent;
	                _context.next = 43;
	                break;

	              case 34:
	                if (collection) {
	                  _context.next = 40;
	                  break;
	                }

	                _context.next = 37;
	                return storage.clear();

	              case 37:
	                data = _context.sent;
	                _context.next = 43;
	                break;

	              case 40:
	                _context.next = 42;
	                return storage.remove(collection, body);

	              case 42:
	                data = _context.sent;

	              case 43:

	                response.data = data;

	                if (!data || (0, _isEmpty2.default)(data)) {
	                  response.statusCode = 204;
	                }
	                _context.next = 50;
	                break;

	              case 47:
	                _context.prev = 47;
	                _context.t0 = _context['catch'](8);

	                if (_context.t0 instanceof _errors.NotFoundError) {
	                  response.statusCode = 404;
	                } else {
	                  response.statusCode = 500;
	                }

	              case 50:
	                return _context.abrupt('return', { response: response });

	              case 51:
	              case 'end':
	                return _context.stop();
	            }
	          }
	        }, _callee, this, [[8, 47]]);
	      }));

	      function handle(_x2) {
	        return _ref.apply(this, arguments);
	      }

	      return handle;
	    }()
	  }]);

	  return CacheMiddleware;
	}(_middleware2.default);

	exports.default = CacheMiddleware;

/***/ },
/* 237 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.NotFoundError = undefined;

	var _notfound = __webpack_require__(238);

	var _notfound2 = _interopRequireDefault(_notfound);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	// Export
	exports.NotFoundError = _notfound2.default;

/***/ },
/* 238 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _es6Error = __webpack_require__(12);

	var _es6Error2 = _interopRequireDefault(_es6Error);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var NotFoundError = function (_ExtendableError) {
	  _inherits(NotFoundError, _ExtendableError);

	  function NotFoundError() {
	    _classCallCheck(this, NotFoundError);

	    return _possibleConstructorReturn(this, (NotFoundError.__proto__ || Object.getPrototypeOf(NotFoundError)).apply(this, arguments));
	  }

	  return NotFoundError;
	}(_es6Error2.default);

	exports.default = NotFoundError;

/***/ },
/* 239 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _asciitree = __webpack_require__(240);

	var _regeneratorRuntime = __webpack_require__(148);

	var _regeneratorRuntime2 = _interopRequireDefault(_regeneratorRuntime);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { return step("next", value); }, function (err) { return step("throw", err); }); } } return step("next"); }); }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	// eslint-disable-line no-unused-vars

	var Middleware = function () {
	  function Middleware() {
	    var name = arguments.length <= 0 || arguments[0] === undefined ? 'Middleware' : arguments[0];

	    _classCallCheck(this, Middleware);

	    this.name = name;
	  }

	  _createClass(Middleware, [{
	    key: 'handle',
	    value: function () {
	      var _ref = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee() {
	        return _regeneratorRuntime2.default.wrap(function _callee$(_context) {
	          while (1) {
	            switch (_context.prev = _context.next) {
	              case 0:
	                throw new Error('A subclass middleware must override the handle function.');

	              case 1:
	              case 'end':
	                return _context.stop();
	            }
	          }
	        }, _callee, this);
	      }));

	      function handle() {
	        return _ref.apply(this, arguments);
	      }

	      return handle;
	    }()
	  }, {
	    key: 'generateTree',
	    value: function generateTree() {
	      var level = arguments.length <= 0 || arguments[0] === undefined ? 0 : arguments[0];

	      var root = {
	        value: this.name,
	        level: level,
	        nodes: []
	      };
	      return root;
	    }
	  }, {
	    key: 'toString',
	    value: function toString() {
	      var root = this.generateTree();
	      return _asciitree.AsciiTree.generate(root);
	    }
	  }]);

	  return Middleware;
	}();

	exports.default = Middleware;

/***/ },
/* 240 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var levels = [];
	var c0 = String.fromCharCode(9500);
	var c1 = String.fromCharCode(9472);
	var c2 = String.fromCharCode(9492);
	var c3 = String.fromCharCode(9474);

	function compose(node, end) {
	  if (node.level === 0) {
	    return node.value;
	  }

	  var ret = '\r\n';
	  var c = end ? c2 : c0;

	  for (var i = 1; i < node.level; i += 1) {
	    ret = '' + ret + (levels[i] ? ' ' : c3);
	    ret = ret + '  ';
	  }

	  return '' + ret + c + c1 + ' ' + node.value;
	}

	var AsciiTree = exports.AsciiTree = function () {
	  function AsciiTree() {
	    _classCallCheck(this, AsciiTree);
	  }

	  _createClass(AsciiTree, null, [{
	    key: 'generate',
	    value: function generate() {
	      var _this = this;

	      var tree = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	      var end = arguments[1];

	      var result = compose(tree, end);

	      if (tree.nodes.length > 0) {
	        (function () {
	          var last = tree.nodes.length - 1;
	          tree.nodes.forEach(function (subTree, index) {
	            levels[subTree.level] = index === last;
	            result += _this.generate(subTree, index === last);
	          });
	        })();
	      }

	      return result;
	    }
	  }]);

	  return AsciiTree;
	}();

/***/ },
/* 241 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // eslint-disable-line no-unused-vars


	var _errors = __webpack_require__(237);

	var _webstorage = __webpack_require__(242);

	var _indexeddb = __webpack_require__(285);

	var _indexeddb2 = _interopRequireDefault(_indexeddb);

	var _websql = __webpack_require__(350);

	var _websql2 = _interopRequireDefault(_websql);

	var _titaniumdb = __webpack_require__(353);

	var _titaniumdb2 = _interopRequireDefault(_titaniumdb);

	var _memory = __webpack_require__(354);

	var _memory2 = _interopRequireDefault(_memory);

	var _promise = __webpack_require__(286);

	var _promise2 = _interopRequireDefault(_promise);

	var _promiseQueue = __webpack_require__(356);

	var _promiseQueue2 = _interopRequireDefault(_promiseQueue);

	var _regeneratorRuntime = __webpack_require__(148);

	var _regeneratorRuntime2 = _interopRequireDefault(_regeneratorRuntime);

	var _isString = __webpack_require__(217);

	var _isString2 = _interopRequireDefault(_isString);

	var _isArray = __webpack_require__(35);

	var _isArray2 = _interopRequireDefault(_isArray);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new _promise2.default(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return _promise2.default.resolve(value).then(function (value) { return step("next", value); }, function (err) { return step("throw", err); }); } } return step("next"); }); }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var idAttribute = process && process.env && process.env.KINVEY_ID_ATTRIBUTE || undefined || '_id';
	var kmdAttribute = process && process.env && process.env.KINVEY_KMD_ATTRIBUTE || undefined || '_kmd';
	_promiseQueue2.default.configure(_promise2.default);
	var queue = new _promiseQueue2.default(1, Infinity);

	/**
	 * Enum for Storage Adapters.
	 */
	var StorageAdapter = {
	  IndexedDB: 'IndexedDB',
	  LocalStorage: 'LocalStorage',
	  Memory: 'Memory',
	  SessionStorage: 'SessionStorage',
	  TitaniumDB: 'TitaniumDB',
	  WebSQL: 'WebSQL'
	};
	Object.freeze(StorageAdapter);

	var Storage = function () {
	  function Storage(name) {
	    var _this = this;

	    var adapters = arguments.length <= 1 || arguments[1] === undefined ? [StorageAdapter.TitaniumDB, StorageAdapter.WebSQL, StorageAdapter.IndexedDB, StorageAdapter.LocalStorage, StorageAdapter.SessionStorage, StorageAdapter.Memory] : arguments[1];

	    _classCallCheck(this, Storage);

	    if (!name) {
	      throw new Error('Unable to create a Storage instance without a name.');
	    }

	    if (!(0, _isString2.default)(name)) {
	      throw new Error('The name is not a string. A name must be a string to create a Storage instance.');
	    }

	    if (!(0, _isArray2.default)(adapters)) {
	      adapters = [adapters];
	    }

	    adapters.some(function (adapter) {
	      switch (adapter) {
	        case StorageAdapter.IndexedDB:
	          if (_indexeddb2.default.isSupported()) {
	            _this.adapter = new _indexeddb2.default(name);
	            return true;
	          }

	          break;
	        case StorageAdapter.LocalStorage:
	          if (_webstorage.LocalStorage.isSupported()) {
	            _this.adapter = new _webstorage.LocalStorage(name);
	            return true;
	          }

	          break;
	        case StorageAdapter.SessionStorage:
	          if (_webstorage.SessionStorage.isSupported()) {
	            _this.adapter = new _webstorage.SessionStorage(name);
	            return true;
	          }

	          break;
	        case StorageAdapter.TitaniumDB:
	          if (_titaniumdb2.default.isSupported()) {
	            _this.adapter = new _titaniumdb2.default(name);
	            return true;
	          }

	          break;
	        case StorageAdapter.WebSQL:
	          if (_websql2.default.isSupported()) {
	            _this.adapter = new _websql2.default(name);
	            return true;
	          }

	          break;
	        case StorageAdapter.Memory:
	          if (_memory2.default.isSupported()) {
	            _this.adapter = new _memory2.default(name);
	            return true;
	          }

	          break;
	        default:
	        // Log.warn(`The ${adapter} adapter is is not recognized.`);
	      }

	      return false;
	    });
	  }

	  _createClass(Storage, [{
	    key: 'generateObjectId',
	    value: function generateObjectId() {
	      var length = arguments.length <= 0 || arguments[0] === undefined ? 24 : arguments[0];

	      var chars = 'abcdef0123456789';
	      var objectId = '';

	      for (var i = 0, j = chars.length; i < length; i += 1) {
	        var pos = Math.floor(Math.random() * j);
	        objectId += chars.substring(pos, pos + 1);
	      }

	      return objectId;
	    }
	  }, {
	    key: 'find',
	    value: function () {
	      var _ref = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee(collection) {
	        var entities;
	        return _regeneratorRuntime2.default.wrap(function _callee$(_context) {
	          while (1) {
	            switch (_context.prev = _context.next) {
	              case 0:
	                _context.prev = 0;
	                _context.next = 3;
	                return this.adapter.find(collection);

	              case 3:
	                entities = _context.sent;

	                if (entities) {
	                  _context.next = 6;
	                  break;
	                }

	                return _context.abrupt('return', []);

	              case 6:
	                return _context.abrupt('return', entities);

	              case 9:
	                _context.prev = 9;
	                _context.t0 = _context['catch'](0);

	                if (!(_context.t0 instanceof _errors.NotFoundError)) {
	                  _context.next = 13;
	                  break;
	                }

	                return _context.abrupt('return', []);

	              case 13:
	                throw _context.t0;

	              case 14:
	              case 'end':
	                return _context.stop();
	            }
	          }
	        }, _callee, this, [[0, 9]]);
	      }));

	      function find(_x3) {
	        return _ref.apply(this, arguments);
	      }

	      return find;
	    }()
	  }, {
	    key: 'findById',
	    value: function () {
	      var _ref2 = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee2(collection, id) {
	        return _regeneratorRuntime2.default.wrap(function _callee2$(_context2) {
	          while (1) {
	            switch (_context2.prev = _context2.next) {
	              case 0:
	                if ((0, _isString2.default)(id)) {
	                  _context2.next = 2;
	                  break;
	                }

	                throw new Error('id must be a string', id);

	              case 2:
	                return _context2.abrupt('return', this.adapter.findById(collection, id));

	              case 3:
	              case 'end':
	                return _context2.stop();
	            }
	          }
	        }, _callee2, this);
	      }));

	      function findById(_x4, _x5) {
	        return _ref2.apply(this, arguments);
	      }

	      return findById;
	    }()

	    // async group(collection, aggregation) {
	    //   const entities = await this.find(collection);

	    //   if (!(aggregation instanceof Aggregation)) {
	    //     aggregation = new Aggregation(result(aggregation, 'toJSON', aggregation));
	    //   }

	    //   if (entities.length > 0 && aggregation) {
	    //     return aggregation.process(entities);
	    //   }

	    //   return null;
	    // }

	  }, {
	    key: 'save',
	    value: function save(collection) {
	      var _this2 = this;

	      var entities = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];

	      return queue.add(_asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee3() {
	        var singular;
	        return _regeneratorRuntime2.default.wrap(function _callee3$(_context3) {
	          while (1) {
	            switch (_context3.prev = _context3.next) {
	              case 0:
	                singular = false;

	                if (entities) {
	                  _context3.next = 3;
	                  break;
	                }

	                return _context3.abrupt('return', null);

	              case 3:

	                if (!(0, _isArray2.default)(entities)) {
	                  singular = true;
	                  entities = [entities];
	                }

	                entities = entities.map(function (entity) {
	                  var id = entity[idAttribute];
	                  var kmd = entity[kmdAttribute] || {};

	                  if (!id) {
	                    id = _this2.generateObjectId();
	                    kmd.local = true;
	                  }

	                  entity[idAttribute] = id;
	                  entity[kmdAttribute] = kmd;
	                  return entity;
	                });

	                _context3.next = 7;
	                return _this2.adapter.save(collection, entities);

	              case 7:
	                entities = _context3.sent;

	                if (!(singular && entities.length > 0)) {
	                  _context3.next = 10;
	                  break;
	                }

	                return _context3.abrupt('return', entities[0]);

	              case 10:
	                return _context3.abrupt('return', entities);

	              case 11:
	              case 'end':
	                return _context3.stop();
	            }
	          }
	        }, _callee3, _this2);
	      })));
	    }
	  }, {
	    key: 'remove',
	    value: function () {
	      var _ref4 = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee4(collection) {
	        var _this3 = this;

	        var entities = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];
	        var responses;
	        return _regeneratorRuntime2.default.wrap(function _callee4$(_context4) {
	          while (1) {
	            switch (_context4.prev = _context4.next) {
	              case 0:
	                _context4.next = 2;
	                return _promise2.default.all(entities.map(function (entity) {
	                  return _this3.removeById(collection, entity[idAttribute]);
	                }));

	              case 2:
	                responses = _context4.sent;
	                return _context4.abrupt('return', responses.reduce(function (entities, entity) {
	                  entities.push(entity);
	                  return entities;
	                }, []));

	              case 4:
	              case 'end':
	                return _context4.stop();
	            }
	          }
	        }, _callee4, this);
	      }));

	      function remove(_x7, _x8) {
	        return _ref4.apply(this, arguments);
	      }

	      return remove;
	    }()
	  }, {
	    key: 'removeById',
	    value: function removeById(collection, id) {
	      var _this4 = this;

	      return queue.add(function () {
	        if (!id) {
	          return undefined;
	        }

	        if (!(0, _isString2.default)(id)) {
	          throw new Error('id must be a string', id);
	        }

	        return _this4.adapter.removeById(collection, id);
	      });
	    }
	  }, {
	    key: 'clear',
	    value: function clear() {
	      var _this5 = this;

	      return queue.add(function () {
	        return _this5.adapter.clear();
	      });
	    }
	  }]);

	  return Storage;
	}();

	exports.default = Storage;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 242 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, global) {'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.SessionStorage = exports.LocalStorage = undefined;

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // eslint-disable-line no-unused-vars


	var _errors = __webpack_require__(237);

	var _regeneratorRuntime = __webpack_require__(148);

	var _regeneratorRuntime2 = _interopRequireDefault(_regeneratorRuntime);

	var _keyBy = __webpack_require__(243);

	var _keyBy2 = _interopRequireDefault(_keyBy);

	var _merge = __webpack_require__(247);

	var _merge2 = _interopRequireDefault(_merge);

	var _values = __webpack_require__(279);

	var _values2 = _interopRequireDefault(_values);

	var _forEach = __webpack_require__(19);

	var _forEach2 = _interopRequireDefault(_forEach);

	var _findIndex = __webpack_require__(282);

	var _findIndex2 = _interopRequireDefault(_findIndex);

	var _find = __webpack_require__(283);

	var _find2 = _interopRequireDefault(_find);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { return step("next", value); }, function (err) { return step("throw", err); }); } } return step("next"); }); }; }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var idAttribute = process && process.env && process.env.KINVEY_ID_ATTRIBUTE || undefined || '_id';
	var masterCollectionName = 'master';

	var WebStorage = function () {
	  function WebStorage() {
	    var name = arguments.length <= 0 || arguments[0] === undefined ? 'kinvey' : arguments[0];

	    _classCallCheck(this, WebStorage);

	    this.name = name;
	  }

	  _createClass(WebStorage, [{
	    key: 'masterCollectionName',
	    get: function get() {
	      return this.name + '_' + masterCollectionName;
	    }
	  }]);

	  return WebStorage;
	}();

	exports.default = WebStorage;

	var LocalStorage = exports.LocalStorage = function (_WebStorage) {
	  _inherits(LocalStorage, _WebStorage);

	  function LocalStorage(name) {
	    _classCallCheck(this, LocalStorage);

	    var _this = _possibleConstructorReturn(this, (LocalStorage.__proto__ || Object.getPrototypeOf(LocalStorage)).call(this, name));

	    global.localStorage.setItem(_this.masterCollectionName, JSON.stringify([]));
	    return _this;
	  }

	  _createClass(LocalStorage, [{
	    key: 'find',
	    value: function () {
	      var _ref = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee(collection) {
	        var entities;
	        return _regeneratorRuntime2.default.wrap(function _callee$(_context) {
	          while (1) {
	            switch (_context.prev = _context.next) {
	              case 0:
	                entities = global.localStorage.getItem('' + this.name + collection);

	                if (!entities) {
	                  _context.next = 3;
	                  break;
	                }

	                return _context.abrupt('return', JSON.parse(entities));

	              case 3:
	                return _context.abrupt('return', entities);

	              case 4:
	              case 'end':
	                return _context.stop();
	            }
	          }
	        }, _callee, this);
	      }));

	      function find(_x2) {
	        return _ref.apply(this, arguments);
	      }

	      return find;
	    }()
	  }, {
	    key: 'findById',
	    value: function () {
	      var _ref2 = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee2(collection, id) {
	        var entities, entity;
	        return _regeneratorRuntime2.default.wrap(function _callee2$(_context2) {
	          while (1) {
	            switch (_context2.prev = _context2.next) {
	              case 0:
	                _context2.next = 2;
	                return this.find(collection);

	              case 2:
	                entities = _context2.sent;
	                entity = (0, _find2.default)(entities, function (entity) {
	                  return entity[idAttribute] === id;
	                });

	                if (entity) {
	                  _context2.next = 6;
	                  break;
	                }

	                throw new _errors.NotFoundError('An entity with _id = ' + id + ' was not found in the ' + collection + (' collection on the ' + this.name + ' localstorage database.'));

	              case 6:
	                return _context2.abrupt('return', entity);

	              case 7:
	              case 'end':
	                return _context2.stop();
	            }
	          }
	        }, _callee2, this);
	      }));

	      function findById(_x3, _x4) {
	        return _ref2.apply(this, arguments);
	      }

	      return findById;
	    }()
	  }, {
	    key: 'save',
	    value: function () {
	      var _ref3 = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee3(collection, entities) {
	        var collections, existingEntities, existingEntitiesById, entitiesById, existingEntityIds;
	        return _regeneratorRuntime2.default.wrap(function _callee3$(_context3) {
	          while (1) {
	            switch (_context3.prev = _context3.next) {
	              case 0:
	                _context3.next = 2;
	                return this.find(this.masterCollectionName);

	              case 2:
	                collections = _context3.sent;


	                if ((0, _findIndex2.default)(collections, collection) === -1) {
	                  collections.push(collection);
	                  global.localStorage.setItem(this.masterCollectionName, JSON.stringify(collections));
	                }

	                _context3.next = 6;
	                return this.find(collection);

	              case 6:
	                existingEntities = _context3.sent;
	                existingEntitiesById = (0, _keyBy2.default)(existingEntities, idAttribute);
	                entitiesById = (0, _keyBy2.default)(entities, idAttribute);
	                existingEntityIds = Object.keys(existingEntitiesById);


	                (0, _forEach2.default)(existingEntityIds, function (id) {
	                  var existingEntity = existingEntitiesById[id];
	                  var entity = entitiesById[id];

	                  if (entity) {
	                    entitiesById[id] = (0, _merge2.default)(existingEntity, entity);
	                  }
	                });

	                global.localStorage.setItem('' + this.name + collection, JSON.stringify((0, _values2.default)(entitiesById)));
	                return _context3.abrupt('return', entities);

	              case 13:
	              case 'end':
	                return _context3.stop();
	            }
	          }
	        }, _callee3, this);
	      }));

	      function save(_x5, _x6) {
	        return _ref3.apply(this, arguments);
	      }

	      return save;
	    }()
	  }, {
	    key: 'removeById',
	    value: function () {
	      var _ref4 = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee4(collection, id) {
	        var entities, entitiesById, entity;
	        return _regeneratorRuntime2.default.wrap(function _callee4$(_context4) {
	          while (1) {
	            switch (_context4.prev = _context4.next) {
	              case 0:
	                _context4.next = 2;
	                return this.find(collection);

	              case 2:
	                entities = _context4.sent;
	                entitiesById = (0, _keyBy2.default)(entities, idAttribute);
	                entity = entitiesById[id];

	                if (entity) {
	                  _context4.next = 7;
	                  break;
	                }

	                throw new _errors.NotFoundError('An entity with _id = ' + id + ' was not found in the ' + collection + ' ' + ('collection on the ' + this.name + ' memory database.'));

	              case 7:

	                delete entitiesById[id];
	                _context4.next = 10;
	                return this.save(collection, (0, _values2.default)(entitiesById));

	              case 10:
	                return _context4.abrupt('return', entity);

	              case 11:
	              case 'end':
	                return _context4.stop();
	            }
	          }
	        }, _callee4, this);
	      }));

	      function removeById(_x7, _x8) {
	        return _ref4.apply(this, arguments);
	      }

	      return removeById;
	    }()
	  }, {
	    key: 'clear',
	    value: function () {
	      var _ref5 = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee5() {
	        var _this2 = this;

	        var collections;
	        return _regeneratorRuntime2.default.wrap(function _callee5$(_context5) {
	          while (1) {
	            switch (_context5.prev = _context5.next) {
	              case 0:
	                _context5.next = 2;
	                return this.find(this.masterCollectionName);

	              case 2:
	                collections = _context5.sent;


	                (0, _forEach2.default)(collections, function (collection) {
	                  global.localStorage.removeItem('' + _this2.name + collection);
	                });

	                global.localStorage.setItem(this.masterCollectionName, JSON.stringify([]));

	              case 5:
	              case 'end':
	                return _context5.stop();
	            }
	          }
	        }, _callee5, this);
	      }));

	      function clear() {
	        return _ref5.apply(this, arguments);
	      }

	      return clear;
	    }()
	  }], [{
	    key: 'isSupported',
	    value: function isSupported() {
	      if (global.localStorage) {
	        var item = 'testLocalStorageSupport';
	        try {
	          global.localStorage.setItem(item, item);
	          global.localStorage.removeItem(item);
	          return true;
	        } catch (e) {
	          return false;
	        }
	      }

	      return false;
	    }
	  }]);

	  return LocalStorage;
	}(WebStorage);

	var SessionStorage = exports.SessionStorage = function (_WebStorage2) {
	  _inherits(SessionStorage, _WebStorage2);

	  function SessionStorage(name) {
	    _classCallCheck(this, SessionStorage);

	    var _this3 = _possibleConstructorReturn(this, (SessionStorage.__proto__ || Object.getPrototypeOf(SessionStorage)).call(this, name));

	    global.sessionStorage.setItem(_this3.masterCollectionName, JSON.stringify([]));
	    return _this3;
	  }

	  _createClass(SessionStorage, [{
	    key: 'find',
	    value: function () {
	      var _ref6 = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee6(collection) {
	        var entities;
	        return _regeneratorRuntime2.default.wrap(function _callee6$(_context6) {
	          while (1) {
	            switch (_context6.prev = _context6.next) {
	              case 0:
	                entities = global.sessionStorage.getItem('' + this.name + collection);

	                if (!entities) {
	                  _context6.next = 3;
	                  break;
	                }

	                return _context6.abrupt('return', JSON.parse(entities));

	              case 3:
	                return _context6.abrupt('return', entities);

	              case 4:
	              case 'end':
	                return _context6.stop();
	            }
	          }
	        }, _callee6, this);
	      }));

	      function find(_x9) {
	        return _ref6.apply(this, arguments);
	      }

	      return find;
	    }()
	  }, {
	    key: 'findById',
	    value: function () {
	      var _ref7 = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee7(collection, id) {
	        var entities, entity;
	        return _regeneratorRuntime2.default.wrap(function _callee7$(_context7) {
	          while (1) {
	            switch (_context7.prev = _context7.next) {
	              case 0:
	                _context7.next = 2;
	                return this.find(collection);

	              case 2:
	                entities = _context7.sent;
	                entity = (0, _find2.default)(entities, function (entity) {
	                  return entity[idAttribute] === id;
	                });

	                if (entity) {
	                  _context7.next = 6;
	                  break;
	                }

	                throw new _errors.NotFoundError('An entity with _id = ' + id + ' was not found in the ' + collection + (' collection on the ' + this.name + ' localstorage database.'));

	              case 6:
	                return _context7.abrupt('return', entity);

	              case 7:
	              case 'end':
	                return _context7.stop();
	            }
	          }
	        }, _callee7, this);
	      }));

	      function findById(_x10, _x11) {
	        return _ref7.apply(this, arguments);
	      }

	      return findById;
	    }()
	  }, {
	    key: 'save',
	    value: function () {
	      var _ref8 = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee8(collection, entities) {
	        var collections, existingEntities, existingEntitiesById, entitiesById, existingEntityIds;
	        return _regeneratorRuntime2.default.wrap(function _callee8$(_context8) {
	          while (1) {
	            switch (_context8.prev = _context8.next) {
	              case 0:
	                _context8.next = 2;
	                return this.find(this.masterCollectionName);

	              case 2:
	                collections = _context8.sent;


	                if ((0, _findIndex2.default)(collections, collection) === -1) {
	                  collections.push(collection);
	                  global.sessionStorage.setItem(this.masterCollectionName, JSON.stringify(collections));
	                }

	                _context8.next = 6;
	                return this.find(collection);

	              case 6:
	                existingEntities = _context8.sent;
	                existingEntitiesById = (0, _keyBy2.default)(existingEntities, idAttribute);
	                entitiesById = (0, _keyBy2.default)(entities, idAttribute);
	                existingEntityIds = Object.keys(existingEntitiesById);


	                (0, _forEach2.default)(existingEntityIds, function (id) {
	                  var existingEntity = existingEntitiesById[id];
	                  var entity = entitiesById[id];

	                  if (entity) {
	                    entitiesById[id] = (0, _merge2.default)(existingEntity, entity);
	                  }
	                });

	                global.sessionStorage.setItem('' + this.name + collection, JSON.stringify((0, _values2.default)(entitiesById)));
	                return _context8.abrupt('return', entities);

	              case 13:
	              case 'end':
	                return _context8.stop();
	            }
	          }
	        }, _callee8, this);
	      }));

	      function save(_x12, _x13) {
	        return _ref8.apply(this, arguments);
	      }

	      return save;
	    }()
	  }, {
	    key: 'removeById',
	    value: function () {
	      var _ref9 = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee9(collection, id) {
	        var entities, entitiesById, entity;
	        return _regeneratorRuntime2.default.wrap(function _callee9$(_context9) {
	          while (1) {
	            switch (_context9.prev = _context9.next) {
	              case 0:
	                _context9.next = 2;
	                return this.find(collection);

	              case 2:
	                entities = _context9.sent;
	                entitiesById = (0, _keyBy2.default)(entities, idAttribute);
	                entity = entitiesById[id];

	                if (entity) {
	                  _context9.next = 7;
	                  break;
	                }

	                throw new _errors.NotFoundError('An entity with _id = ' + id + ' was not found in the ' + collection + ' ' + ('collection on the ' + this.name + ' memory database.'));

	              case 7:

	                delete entitiesById[id];
	                global.sessionStorage.setItem('' + this.name + collection, JSON.stringify((0, _values2.default)(entitiesById)));

	                return _context9.abrupt('return', entity);

	              case 10:
	              case 'end':
	                return _context9.stop();
	            }
	          }
	        }, _callee9, this);
	      }));

	      function removeById(_x14, _x15) {
	        return _ref9.apply(this, arguments);
	      }

	      return removeById;
	    }()
	  }, {
	    key: 'clear',
	    value: function () {
	      var _ref10 = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee10() {
	        var _this4 = this;

	        var collections;
	        return _regeneratorRuntime2.default.wrap(function _callee10$(_context10) {
	          while (1) {
	            switch (_context10.prev = _context10.next) {
	              case 0:
	                _context10.next = 2;
	                return this.find(this.masterCollectionName);

	              case 2:
	                collections = _context10.sent;


	                (0, _forEach2.default)(collections, function (collection) {
	                  global.sessionStorage.removeItem('' + _this4.name + collection);
	                });

	                global.sessionStorage.setItem(this.masterCollectionName, JSON.stringify([]));

	              case 5:
	              case 'end':
	                return _context10.stop();
	            }
	          }
	        }, _callee10, this);
	      }));

	      function clear() {
	        return _ref10.apply(this, arguments);
	      }

	      return clear;
	    }()
	  }], [{
	    key: 'isSupported',
	    value: function isSupported() {
	      if (global.sessionStorage) {
	        var item = 'testSessionStorageSupport';
	        try {
	          global.sessionStorage.setItem(item, item);
	          global.sessionStorage.removeItem(item);
	          return true;
	        } catch (e) {
	          return false;
	        }
	      }

	      return false;
	    }
	  }]);

	  return SessionStorage;
	}(WebStorage);
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4), (function() { return this; }())))

/***/ },
/* 243 */
/***/ function(module, exports, __webpack_require__) {

	var baseAssignValue = __webpack_require__(213),
	    createAggregator = __webpack_require__(244);

	/**
	 * Creates an object composed of keys generated from the results of running
	 * each element of `collection` thru `iteratee`. The corresponding value of
	 * each key is the last element responsible for generating the key. The
	 * iteratee is invoked with one argument: (value).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Collection
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function} [iteratee=_.identity]
	 *  The iteratee to transform keys.
	 * @returns {Object} Returns the composed aggregate object.
	 * @example
	 *
	 * var array = [
	 *   { 'dir': 'left', 'code': 97 },
	 *   { 'dir': 'right', 'code': 100 }
	 * ];
	 *
	 * _.keyBy(array, function(o) {
	 *   return String.fromCharCode(o.code);
	 * });
	 * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
	 *
	 * _.keyBy(array, 'dir');
	 * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
	 */
	var keyBy = createAggregator(function(result, value, key) {
	  baseAssignValue(result, key, value);
	});

	module.exports = keyBy;


/***/ },
/* 244 */
/***/ function(module, exports, __webpack_require__) {

	var arrayAggregator = __webpack_require__(245),
	    baseAggregator = __webpack_require__(246),
	    baseIteratee = __webpack_require__(42),
	    isArray = __webpack_require__(35);

	/**
	 * Creates a function like `_.groupBy`.
	 *
	 * @private
	 * @param {Function} setter The function to set accumulator values.
	 * @param {Function} [initializer] The accumulator object initializer.
	 * @returns {Function} Returns the new aggregator function.
	 */
	function createAggregator(setter, initializer) {
	  return function(collection, iteratee) {
	    var func = isArray(collection) ? arrayAggregator : baseAggregator,
	        accumulator = initializer ? initializer() : {};

	    return func(collection, setter, baseIteratee(iteratee, 2), accumulator);
	  };
	}

	module.exports = createAggregator;


/***/ },
/* 245 */
/***/ function(module, exports) {

	/**
	 * A specialized version of `baseAggregator` for arrays.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} setter The function to set `accumulator` values.
	 * @param {Function} iteratee The iteratee to transform keys.
	 * @param {Object} accumulator The initial aggregated object.
	 * @returns {Function} Returns `accumulator`.
	 */
	function arrayAggregator(array, setter, iteratee, accumulator) {
	  var index = -1,
	      length = array ? array.length : 0;

	  while (++index < length) {
	    var value = array[index];
	    setter(accumulator, value, iteratee(value), array);
	  }
	  return accumulator;
	}

	module.exports = arrayAggregator;


/***/ },
/* 246 */
/***/ function(module, exports, __webpack_require__) {

	var baseEach = __webpack_require__(21);

	/**
	 * Aggregates elements of `collection` on `accumulator` with keys transformed
	 * by `iteratee` and values set by `setter`.
	 *
	 * @private
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function} setter The function to set `accumulator` values.
	 * @param {Function} iteratee The iteratee to transform keys.
	 * @param {Object} accumulator The initial aggregated object.
	 * @returns {Function} Returns `accumulator`.
	 */
	function baseAggregator(collection, setter, iteratee, accumulator) {
	  baseEach(collection, function(value, key, collection) {
	    setter(accumulator, value, iteratee(value), collection);
	  });
	  return accumulator;
	}

	module.exports = baseAggregator;


/***/ },
/* 247 */
/***/ function(module, exports, __webpack_require__) {

	var baseMerge = __webpack_require__(248),
	    createAssigner = __webpack_require__(215);

	/**
	 * This method is like `_.assign` except that it recursively merges own and
	 * inherited enumerable string keyed properties of source objects into the
	 * destination object. Source properties that resolve to `undefined` are
	 * skipped if a destination value exists. Array and plain object properties
	 * are merged recursively. Other objects and value types are overridden by
	 * assignment. Source objects are applied from left to right. Subsequent
	 * sources overwrite property assignments of previous sources.
	 *
	 * **Note:** This method mutates `object`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.5.0
	 * @category Object
	 * @param {Object} object The destination object.
	 * @param {...Object} [sources] The source objects.
	 * @returns {Object} Returns `object`.
	 * @example
	 *
	 * var object = {
	 *   'a': [{ 'b': 2 }, { 'd': 4 }]
	 * };
	 *
	 * var other = {
	 *   'a': [{ 'c': 3 }, { 'e': 5 }]
	 * };
	 *
	 * _.merge(object, other);
	 * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
	 */
	var merge = createAssigner(function(object, source, srcIndex) {
	  baseMerge(object, source, srcIndex);
	});

	module.exports = merge;


/***/ },
/* 248 */
/***/ function(module, exports, __webpack_require__) {

	var Stack = __webpack_require__(45),
	    arrayEach = __webpack_require__(20),
	    assignMergeValue = __webpack_require__(249),
	    baseKeysIn = __webpack_require__(250),
	    baseMergeDeep = __webpack_require__(252),
	    isArray = __webpack_require__(35),
	    isObject = __webpack_require__(32),
	    isTypedArray = __webpack_require__(103);

	/**
	 * The base implementation of `_.merge` without support for multiple sources.
	 *
	 * @private
	 * @param {Object} object The destination object.
	 * @param {Object} source The source object.
	 * @param {number} srcIndex The index of `source`.
	 * @param {Function} [customizer] The function to customize merged values.
	 * @param {Object} [stack] Tracks traversed source values and their merged
	 *  counterparts.
	 */
	function baseMerge(object, source, srcIndex, customizer, stack) {
	  if (object === source) {
	    return;
	  }
	  if (!(isArray(source) || isTypedArray(source))) {
	    var props = baseKeysIn(source);
	  }
	  arrayEach(props || source, function(srcValue, key) {
	    if (props) {
	      key = srcValue;
	      srcValue = source[key];
	    }
	    if (isObject(srcValue)) {
	      stack || (stack = new Stack);
	      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
	    }
	    else {
	      var newValue = customizer
	        ? customizer(object[key], srcValue, (key + ''), object, source, stack)
	        : undefined;

	      if (newValue === undefined) {
	        newValue = srcValue;
	      }
	      assignMergeValue(object, key, newValue);
	    }
	  });
	}

	module.exports = baseMerge;


/***/ },
/* 249 */
/***/ function(module, exports, __webpack_require__) {

	var baseAssignValue = __webpack_require__(213),
	    eq = __webpack_require__(50);

	/**
	 * This function is like `assignValue` except that it doesn't assign
	 * `undefined` values.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {string} key The key of the property to assign.
	 * @param {*} value The value to assign.
	 */
	function assignMergeValue(object, key, value) {
	  if ((value !== undefined && !eq(object[key], value)) ||
	      (typeof key == 'number' && value === undefined && !(key in object))) {
	    baseAssignValue(object, key, value);
	  }
	}

	module.exports = assignMergeValue;


/***/ },
/* 250 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(32),
	    isPrototype = __webpack_require__(38),
	    nativeKeysIn = __webpack_require__(251);

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function baseKeysIn(object) {
	  if (!isObject(object)) {
	    return nativeKeysIn(object);
	  }
	  var isProto = isPrototype(object),
	      result = [];

	  for (var key in object) {
	    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	module.exports = baseKeysIn;


/***/ },
/* 251 */
/***/ function(module, exports) {

	/**
	 * This function is like
	 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	 * except that it includes inherited enumerable properties.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function nativeKeysIn(object) {
	  var result = [];
	  if (object != null) {
	    for (var key in Object(object)) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	module.exports = nativeKeysIn;


/***/ },
/* 252 */
/***/ function(module, exports, __webpack_require__) {

	var assignMergeValue = __webpack_require__(249),
	    baseClone = __webpack_require__(253),
	    copyArray = __webpack_require__(181),
	    isArguments = __webpack_require__(28),
	    isArray = __webpack_require__(35),
	    isArrayLikeObject = __webpack_require__(29),
	    isFunction = __webpack_require__(31),
	    isObject = __webpack_require__(32),
	    isPlainObject = __webpack_require__(224),
	    isTypedArray = __webpack_require__(103),
	    toPlainObject = __webpack_require__(277);

	/**
	 * A specialized version of `baseMerge` for arrays and objects which performs
	 * deep merges and tracks traversed objects enabling objects with circular
	 * references to be merged.
	 *
	 * @private
	 * @param {Object} object The destination object.
	 * @param {Object} source The source object.
	 * @param {string} key The key of the value to merge.
	 * @param {number} srcIndex The index of `source`.
	 * @param {Function} mergeFunc The function to merge values.
	 * @param {Function} [customizer] The function to customize assigned values.
	 * @param {Object} [stack] Tracks traversed source values and their merged
	 *  counterparts.
	 */
	function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
	  var objValue = object[key],
	      srcValue = source[key],
	      stacked = stack.get(srcValue);

	  if (stacked) {
	    assignMergeValue(object, key, stacked);
	    return;
	  }
	  var newValue = customizer
	    ? customizer(objValue, srcValue, (key + ''), object, source, stack)
	    : undefined;

	  var isCommon = newValue === undefined;

	  if (isCommon) {
	    newValue = srcValue;
	    if (isArray(srcValue) || isTypedArray(srcValue)) {
	      if (isArray(objValue)) {
	        newValue = objValue;
	      }
	      else if (isArrayLikeObject(objValue)) {
	        newValue = copyArray(objValue);
	      }
	      else {
	        isCommon = false;
	        newValue = baseClone(srcValue, true);
	      }
	    }
	    else if (isPlainObject(srcValue) || isArguments(srcValue)) {
	      if (isArguments(objValue)) {
	        newValue = toPlainObject(objValue);
	      }
	      else if (!isObject(objValue) || (srcIndex && isFunction(objValue))) {
	        isCommon = false;
	        newValue = baseClone(srcValue, true);
	      }
	      else {
	        newValue = objValue;
	      }
	    }
	    else {
	      isCommon = false;
	    }
	  }
	  if (isCommon) {
	    // Recursively merge objects and arrays (susceptible to call stack limits).
	    stack.set(srcValue, newValue);
	    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
	    stack['delete'](srcValue);
	  }
	  assignMergeValue(object, key, newValue);
	}

	module.exports = baseMergeDeep;


/***/ },
/* 253 */
/***/ function(module, exports, __webpack_require__) {

	var Stack = __webpack_require__(45),
	    arrayEach = __webpack_require__(20),
	    assignValue = __webpack_require__(212),
	    baseAssign = __webpack_require__(254),
	    cloneBuffer = __webpack_require__(255),
	    copyArray = __webpack_require__(181),
	    copySymbols = __webpack_require__(256),
	    getAllKeys = __webpack_require__(259),
	    getTag = __webpack_require__(97),
	    initCloneArray = __webpack_require__(262),
	    initCloneByTag = __webpack_require__(263),
	    initCloneObject = __webpack_require__(274),
	    isArray = __webpack_require__(35),
	    isBuffer = __webpack_require__(275),
	    isObject = __webpack_require__(32),
	    keys = __webpack_require__(25);

	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]',
	    arrayTag = '[object Array]',
	    boolTag = '[object Boolean]',
	    dateTag = '[object Date]',
	    errorTag = '[object Error]',
	    funcTag = '[object Function]',
	    genTag = '[object GeneratorFunction]',
	    mapTag = '[object Map]',
	    numberTag = '[object Number]',
	    objectTag = '[object Object]',
	    regexpTag = '[object RegExp]',
	    setTag = '[object Set]',
	    stringTag = '[object String]',
	    symbolTag = '[object Symbol]',
	    weakMapTag = '[object WeakMap]';

	var arrayBufferTag = '[object ArrayBuffer]',
	    dataViewTag = '[object DataView]',
	    float32Tag = '[object Float32Array]',
	    float64Tag = '[object Float64Array]',
	    int8Tag = '[object Int8Array]',
	    int16Tag = '[object Int16Array]',
	    int32Tag = '[object Int32Array]',
	    uint8Tag = '[object Uint8Array]',
	    uint8ClampedTag = '[object Uint8ClampedArray]',
	    uint16Tag = '[object Uint16Array]',
	    uint32Tag = '[object Uint32Array]';

	/** Used to identify `toStringTag` values supported by `_.clone`. */
	var cloneableTags = {};
	cloneableTags[argsTag] = cloneableTags[arrayTag] =
	cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
	cloneableTags[boolTag] = cloneableTags[dateTag] =
	cloneableTags[float32Tag] = cloneableTags[float64Tag] =
	cloneableTags[int8Tag] = cloneableTags[int16Tag] =
	cloneableTags[int32Tag] = cloneableTags[mapTag] =
	cloneableTags[numberTag] = cloneableTags[objectTag] =
	cloneableTags[regexpTag] = cloneableTags[setTag] =
	cloneableTags[stringTag] = cloneableTags[symbolTag] =
	cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
	cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
	cloneableTags[errorTag] = cloneableTags[funcTag] =
	cloneableTags[weakMapTag] = false;

	/**
	 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
	 * traversed objects.
	 *
	 * @private
	 * @param {*} value The value to clone.
	 * @param {boolean} [isDeep] Specify a deep clone.
	 * @param {boolean} [isFull] Specify a clone including symbols.
	 * @param {Function} [customizer] The function to customize cloning.
	 * @param {string} [key] The key of `value`.
	 * @param {Object} [object] The parent object of `value`.
	 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
	 * @returns {*} Returns the cloned value.
	 */
	function baseClone(value, isDeep, isFull, customizer, key, object, stack) {
	  var result;
	  if (customizer) {
	    result = object ? customizer(value, key, object, stack) : customizer(value);
	  }
	  if (result !== undefined) {
	    return result;
	  }
	  if (!isObject(value)) {
	    return value;
	  }
	  var isArr = isArray(value);
	  if (isArr) {
	    result = initCloneArray(value);
	    if (!isDeep) {
	      return copyArray(value, result);
	    }
	  } else {
	    var tag = getTag(value),
	        isFunc = tag == funcTag || tag == genTag;

	    if (isBuffer(value)) {
	      return cloneBuffer(value, isDeep);
	    }
	    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
	      result = initCloneObject(isFunc ? {} : value);
	      if (!isDeep) {
	        return copySymbols(value, baseAssign(result, value));
	      }
	    } else {
	      if (!cloneableTags[tag]) {
	        return object ? value : {};
	      }
	      result = initCloneByTag(value, tag, baseClone, isDeep);
	    }
	  }
	  // Check for circular references and return its corresponding clone.
	  stack || (stack = new Stack);
	  var stacked = stack.get(value);
	  if (stacked) {
	    return stacked;
	  }
	  stack.set(value, result);

	  if (!isArr) {
	    var props = isFull ? getAllKeys(value) : keys(value);
	  }
	  arrayEach(props || value, function(subValue, key) {
	    if (props) {
	      key = subValue;
	      subValue = value[key];
	    }
	    // Recursively populate clone (susceptible to call stack limits).
	    assignValue(result, key, baseClone(subValue, isDeep, isFull, customizer, key, value, stack));
	  });
	  return result;
	}

	module.exports = baseClone;


/***/ },
/* 254 */
/***/ function(module, exports, __webpack_require__) {

	var copyObject = __webpack_require__(214),
	    keys = __webpack_require__(25);

	/**
	 * The base implementation of `_.assign` without support for multiple sources
	 * or `customizer` functions.
	 *
	 * @private
	 * @param {Object} object The destination object.
	 * @param {Object} source The source object.
	 * @returns {Object} Returns `object`.
	 */
	function baseAssign(object, source) {
	  return object && copyObject(source, keys(source), object);
	}

	module.exports = baseAssign;


/***/ },
/* 255 */
/***/ function(module, exports) {

	/**
	 * Creates a clone of  `buffer`.
	 *
	 * @private
	 * @param {Buffer} buffer The buffer to clone.
	 * @param {boolean} [isDeep] Specify a deep clone.
	 * @returns {Buffer} Returns the cloned buffer.
	 */
	function cloneBuffer(buffer, isDeep) {
	  if (isDeep) {
	    return buffer.slice();
	  }
	  var result = new buffer.constructor(buffer.length);
	  buffer.copy(result);
	  return result;
	}

	module.exports = cloneBuffer;


/***/ },
/* 256 */
/***/ function(module, exports, __webpack_require__) {

	var copyObject = __webpack_require__(214),
	    getSymbols = __webpack_require__(257);

	/**
	 * Copies own symbol properties of `source` to `object`.
	 *
	 * @private
	 * @param {Object} source The object to copy symbols from.
	 * @param {Object} [object={}] The object to copy symbols to.
	 * @returns {Object} Returns `object`.
	 */
	function copySymbols(source, object) {
	  return copyObject(source, getSymbols(source), object);
	}

	module.exports = copySymbols;


/***/ },
/* 257 */
/***/ function(module, exports, __webpack_require__) {

	var overArg = __webpack_require__(40),
	    stubArray = __webpack_require__(258);

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeGetSymbols = Object.getOwnPropertySymbols;

	/**
	 * Creates an array of the own enumerable symbol properties of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of symbols.
	 */
	var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;

	module.exports = getSymbols;


/***/ },
/* 258 */
/***/ function(module, exports) {

	/**
	 * This method returns a new empty array.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.13.0
	 * @category Util
	 * @returns {Array} Returns the new empty array.
	 * @example
	 *
	 * var arrays = _.times(2, _.stubArray);
	 *
	 * console.log(arrays);
	 * // => [[], []]
	 *
	 * console.log(arrays[0] === arrays[1]);
	 * // => false
	 */
	function stubArray() {
	  return [];
	}

	module.exports = stubArray;


/***/ },
/* 259 */
/***/ function(module, exports, __webpack_require__) {

	var baseGetAllKeys = __webpack_require__(260),
	    getSymbols = __webpack_require__(257),
	    keys = __webpack_require__(25);

	/**
	 * Creates an array of own enumerable property names and symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names and symbols.
	 */
	function getAllKeys(object) {
	  return baseGetAllKeys(object, keys, getSymbols);
	}

	module.exports = getAllKeys;


/***/ },
/* 260 */
/***/ function(module, exports, __webpack_require__) {

	var arrayPush = __webpack_require__(261),
	    isArray = __webpack_require__(35);

	/**
	 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
	 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
	 * symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Function} keysFunc The function to get the keys of `object`.
	 * @param {Function} symbolsFunc The function to get the symbols of `object`.
	 * @returns {Array} Returns the array of property names and symbols.
	 */
	function baseGetAllKeys(object, keysFunc, symbolsFunc) {
	  var result = keysFunc(object);
	  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
	}

	module.exports = baseGetAllKeys;


/***/ },
/* 261 */
/***/ function(module, exports) {

	/**
	 * Appends the elements of `values` to `array`.
	 *
	 * @private
	 * @param {Array} array The array to modify.
	 * @param {Array} values The values to append.
	 * @returns {Array} Returns `array`.
	 */
	function arrayPush(array, values) {
	  var index = -1,
	      length = values.length,
	      offset = array.length;

	  while (++index < length) {
	    array[offset + index] = values[index];
	  }
	  return array;
	}

	module.exports = arrayPush;


/***/ },
/* 262 */
/***/ function(module, exports) {

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Initializes an array clone.
	 *
	 * @private
	 * @param {Array} array The array to clone.
	 * @returns {Array} Returns the initialized clone.
	 */
	function initCloneArray(array) {
	  var length = array.length,
	      result = array.constructor(length);

	  // Add properties assigned by `RegExp#exec`.
	  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
	    result.index = array.index;
	    result.input = array.input;
	  }
	  return result;
	}

	module.exports = initCloneArray;


/***/ },
/* 263 */
/***/ function(module, exports, __webpack_require__) {

	var cloneArrayBuffer = __webpack_require__(264),
	    cloneDataView = __webpack_require__(265),
	    cloneMap = __webpack_require__(266),
	    cloneRegExp = __webpack_require__(269),
	    cloneSet = __webpack_require__(270),
	    cloneSymbol = __webpack_require__(272),
	    cloneTypedArray = __webpack_require__(273);

	/** `Object#toString` result references. */
	var boolTag = '[object Boolean]',
	    dateTag = '[object Date]',
	    mapTag = '[object Map]',
	    numberTag = '[object Number]',
	    regexpTag = '[object RegExp]',
	    setTag = '[object Set]',
	    stringTag = '[object String]',
	    symbolTag = '[object Symbol]';

	var arrayBufferTag = '[object ArrayBuffer]',
	    dataViewTag = '[object DataView]',
	    float32Tag = '[object Float32Array]',
	    float64Tag = '[object Float64Array]',
	    int8Tag = '[object Int8Array]',
	    int16Tag = '[object Int16Array]',
	    int32Tag = '[object Int32Array]',
	    uint8Tag = '[object Uint8Array]',
	    uint8ClampedTag = '[object Uint8ClampedArray]',
	    uint16Tag = '[object Uint16Array]',
	    uint32Tag = '[object Uint32Array]';

	/**
	 * Initializes an object clone based on its `toStringTag`.
	 *
	 * **Note:** This function only supports cloning values with tags of
	 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
	 *
	 * @private
	 * @param {Object} object The object to clone.
	 * @param {string} tag The `toStringTag` of the object to clone.
	 * @param {Function} cloneFunc The function to clone values.
	 * @param {boolean} [isDeep] Specify a deep clone.
	 * @returns {Object} Returns the initialized clone.
	 */
	function initCloneByTag(object, tag, cloneFunc, isDeep) {
	  var Ctor = object.constructor;
	  switch (tag) {
	    case arrayBufferTag:
	      return cloneArrayBuffer(object);

	    case boolTag:
	    case dateTag:
	      return new Ctor(+object);

	    case dataViewTag:
	      return cloneDataView(object, isDeep);

	    case float32Tag: case float64Tag:
	    case int8Tag: case int16Tag: case int32Tag:
	    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
	      return cloneTypedArray(object, isDeep);

	    case mapTag:
	      return cloneMap(object, isDeep, cloneFunc);

	    case numberTag:
	    case stringTag:
	      return new Ctor(object);

	    case regexpTag:
	      return cloneRegExp(object);

	    case setTag:
	      return cloneSet(object, isDeep, cloneFunc);

	    case symbolTag:
	      return cloneSymbol(object);
	  }
	}

	module.exports = initCloneByTag;


/***/ },
/* 264 */
/***/ function(module, exports, __webpack_require__) {

	var Uint8Array = __webpack_require__(93);

	/**
	 * Creates a clone of `arrayBuffer`.
	 *
	 * @private
	 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
	 * @returns {ArrayBuffer} Returns the cloned array buffer.
	 */
	function cloneArrayBuffer(arrayBuffer) {
	  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
	  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
	  return result;
	}

	module.exports = cloneArrayBuffer;


/***/ },
/* 265 */
/***/ function(module, exports, __webpack_require__) {

	var cloneArrayBuffer = __webpack_require__(264);

	/**
	 * Creates a clone of `dataView`.
	 *
	 * @private
	 * @param {Object} dataView The data view to clone.
	 * @param {boolean} [isDeep] Specify a deep clone.
	 * @returns {Object} Returns the cloned data view.
	 */
	function cloneDataView(dataView, isDeep) {
	  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
	  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
	}

	module.exports = cloneDataView;


/***/ },
/* 266 */
/***/ function(module, exports, __webpack_require__) {

	var addMapEntry = __webpack_require__(267),
	    arrayReduce = __webpack_require__(268),
	    mapToArray = __webpack_require__(94);

	/**
	 * Creates a clone of `map`.
	 *
	 * @private
	 * @param {Object} map The map to clone.
	 * @param {Function} cloneFunc The function to clone values.
	 * @param {boolean} [isDeep] Specify a deep clone.
	 * @returns {Object} Returns the cloned map.
	 */
	function cloneMap(map, isDeep, cloneFunc) {
	  var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);
	  return arrayReduce(array, addMapEntry, new map.constructor);
	}

	module.exports = cloneMap;


/***/ },
/* 267 */
/***/ function(module, exports) {

	/**
	 * Adds the key-value `pair` to `map`.
	 *
	 * @private
	 * @param {Object} map The map to modify.
	 * @param {Array} pair The key-value pair to add.
	 * @returns {Object} Returns `map`.
	 */
	function addMapEntry(map, pair) {
	  // Don't return `map.set` because it's not chainable in IE 11.
	  map.set(pair[0], pair[1]);
	  return map;
	}

	module.exports = addMapEntry;


/***/ },
/* 268 */
/***/ function(module, exports) {

	/**
	 * A specialized version of `_.reduce` for arrays without support for
	 * iteratee shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @param {*} [accumulator] The initial value.
	 * @param {boolean} [initAccum] Specify using the first element of `array` as
	 *  the initial value.
	 * @returns {*} Returns the accumulated value.
	 */
	function arrayReduce(array, iteratee, accumulator, initAccum) {
	  var index = -1,
	      length = array ? array.length : 0;

	  if (initAccum && length) {
	    accumulator = array[++index];
	  }
	  while (++index < length) {
	    accumulator = iteratee(accumulator, array[index], index, array);
	  }
	  return accumulator;
	}

	module.exports = arrayReduce;


/***/ },
/* 269 */
/***/ function(module, exports) {

	/** Used to match `RegExp` flags from their coerced string values. */
	var reFlags = /\w*$/;

	/**
	 * Creates a clone of `regexp`.
	 *
	 * @private
	 * @param {Object} regexp The regexp to clone.
	 * @returns {Object} Returns the cloned regexp.
	 */
	function cloneRegExp(regexp) {
	  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
	  result.lastIndex = regexp.lastIndex;
	  return result;
	}

	module.exports = cloneRegExp;


/***/ },
/* 270 */
/***/ function(module, exports, __webpack_require__) {

	var addSetEntry = __webpack_require__(271),
	    arrayReduce = __webpack_require__(268),
	    setToArray = __webpack_require__(95);

	/**
	 * Creates a clone of `set`.
	 *
	 * @private
	 * @param {Object} set The set to clone.
	 * @param {Function} cloneFunc The function to clone values.
	 * @param {boolean} [isDeep] Specify a deep clone.
	 * @returns {Object} Returns the cloned set.
	 */
	function cloneSet(set, isDeep, cloneFunc) {
	  var array = isDeep ? cloneFunc(setToArray(set), true) : setToArray(set);
	  return arrayReduce(array, addSetEntry, new set.constructor);
	}

	module.exports = cloneSet;


/***/ },
/* 271 */
/***/ function(module, exports) {

	/**
	 * Adds `value` to `set`.
	 *
	 * @private
	 * @param {Object} set The set to modify.
	 * @param {*} value The value to add.
	 * @returns {Object} Returns `set`.
	 */
	function addSetEntry(set, value) {
	  // Don't return `set.add` because it's not chainable in IE 11.
	  set.add(value);
	  return set;
	}

	module.exports = addSetEntry;


/***/ },
/* 272 */
/***/ function(module, exports, __webpack_require__) {

	var Symbol = __webpack_require__(92);

	/** Used to convert symbols to primitives and strings. */
	var symbolProto = Symbol ? Symbol.prototype : undefined,
	    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

	/**
	 * Creates a clone of the `symbol` object.
	 *
	 * @private
	 * @param {Object} symbol The symbol object to clone.
	 * @returns {Object} Returns the cloned symbol object.
	 */
	function cloneSymbol(symbol) {
	  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
	}

	module.exports = cloneSymbol;


/***/ },
/* 273 */
/***/ function(module, exports, __webpack_require__) {

	var cloneArrayBuffer = __webpack_require__(264);

	/**
	 * Creates a clone of `typedArray`.
	 *
	 * @private
	 * @param {Object} typedArray The typed array to clone.
	 * @param {boolean} [isDeep] Specify a deep clone.
	 * @returns {Object} Returns the cloned typed array.
	 */
	function cloneTypedArray(typedArray, isDeep) {
	  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
	  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
	}

	module.exports = cloneTypedArray;


/***/ },
/* 274 */
/***/ function(module, exports, __webpack_require__) {

	var baseCreate = __webpack_require__(164),
	    getPrototype = __webpack_require__(225),
	    isPrototype = __webpack_require__(38);

	/**
	 * Initializes an object clone.
	 *
	 * @private
	 * @param {Object} object The object to clone.
	 * @returns {Object} Returns the initialized clone.
	 */
	function initCloneObject(object) {
	  return (typeof object.constructor == 'function' && !isPrototype(object))
	    ? baseCreate(getPrototype(object))
	    : {};
	}

	module.exports = initCloneObject;


/***/ },
/* 275 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {var root = __webpack_require__(64),
	    stubFalse = __webpack_require__(276);

	/** Detect free variable `exports`. */
	var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

	/** Detect free variable `module`. */
	var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

	/** Detect the popular CommonJS extension `module.exports`. */
	var moduleExports = freeModule && freeModule.exports === freeExports;

	/** Built-in value references. */
	var Buffer = moduleExports ? root.Buffer : undefined;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

	/**
	 * Checks if `value` is a buffer.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.3.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
	 * @example
	 *
	 * _.isBuffer(new Buffer(2));
	 * // => true
	 *
	 * _.isBuffer(new Uint8Array(2));
	 * // => false
	 */
	var isBuffer = nativeIsBuffer || stubFalse;

	module.exports = isBuffer;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(107)(module)))

/***/ },
/* 276 */
/***/ function(module, exports) {

	/**
	 * This method returns `false`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.13.0
	 * @category Util
	 * @returns {boolean} Returns `false`.
	 * @example
	 *
	 * _.times(2, _.stubFalse);
	 * // => [false, false]
	 */
	function stubFalse() {
	  return false;
	}

	module.exports = stubFalse;


/***/ },
/* 277 */
/***/ function(module, exports, __webpack_require__) {

	var copyObject = __webpack_require__(214),
	    keysIn = __webpack_require__(278);

	/**
	 * Converts `value` to a plain object flattening inherited enumerable string
	 * keyed properties of `value` to own properties of the plain object.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Lang
	 * @param {*} value The value to convert.
	 * @returns {Object} Returns the converted plain object.
	 * @example
	 *
	 * function Foo() {
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.assign({ 'a': 1 }, new Foo);
	 * // => { 'a': 1, 'b': 2 }
	 *
	 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
	 * // => { 'a': 1, 'b': 2, 'c': 3 }
	 */
	function toPlainObject(value) {
	  return copyObject(value, keysIn(value));
	}

	module.exports = toPlainObject;


/***/ },
/* 278 */
/***/ function(module, exports, __webpack_require__) {

	var arrayLikeKeys = __webpack_require__(26),
	    baseKeysIn = __webpack_require__(250),
	    isArrayLike = __webpack_require__(30);

	/**
	 * Creates an array of the own and inherited enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keysIn(new Foo);
	 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
	 */
	function keysIn(object) {
	  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
	}

	module.exports = keysIn;


/***/ },
/* 279 */
/***/ function(module, exports, __webpack_require__) {

	var baseValues = __webpack_require__(280),
	    keys = __webpack_require__(25);

	/**
	 * Creates an array of the own enumerable string keyed property values of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property values.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.values(new Foo);
	 * // => [1, 2] (iteration order is not guaranteed)
	 *
	 * _.values('hi');
	 * // => ['h', 'i']
	 */
	function values(object) {
	  return object ? baseValues(object, keys(object)) : [];
	}

	module.exports = values;


/***/ },
/* 280 */
/***/ function(module, exports, __webpack_require__) {

	var arrayMap = __webpack_require__(281);

	/**
	 * The base implementation of `_.values` and `_.valuesIn` which creates an
	 * array of `object` property values corresponding to the property names
	 * of `props`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Array} props The property names to get values for.
	 * @returns {Object} Returns the array of property values.
	 */
	function baseValues(object, props) {
	  return arrayMap(props, function(key) {
	    return object[key];
	  });
	}

	module.exports = baseValues;


/***/ },
/* 281 */
/***/ function(module, exports) {

	/**
	 * A specialized version of `_.map` for arrays without support for iteratee
	 * shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the new mapped array.
	 */
	function arrayMap(array, iteratee) {
	  var index = -1,
	      length = array ? array.length : 0,
	      result = Array(length);

	  while (++index < length) {
	    result[index] = iteratee(array[index], index, array);
	  }
	  return result;
	}

	module.exports = arrayMap;


/***/ },
/* 282 */
/***/ function(module, exports, __webpack_require__) {

	var baseFindIndex = __webpack_require__(189),
	    baseIteratee = __webpack_require__(42),
	    toInteger = __webpack_require__(197);

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeMax = Math.max;

	/**
	 * This method is like `_.find` except that it returns the index of the first
	 * element `predicate` returns truthy for instead of the element itself.
	 *
	 * @static
	 * @memberOf _
	 * @since 1.1.0
	 * @category Array
	 * @param {Array} array The array to inspect.
	 * @param {Function} [predicate=_.identity]
	 *  The function invoked per iteration.
	 * @param {number} [fromIndex=0] The index to search from.
	 * @returns {number} Returns the index of the found element, else `-1`.
	 * @example
	 *
	 * var users = [
	 *   { 'user': 'barney',  'active': false },
	 *   { 'user': 'fred',    'active': false },
	 *   { 'user': 'pebbles', 'active': true }
	 * ];
	 *
	 * _.findIndex(users, function(o) { return o.user == 'barney'; });
	 * // => 0
	 *
	 * // The `_.matches` iteratee shorthand.
	 * _.findIndex(users, { 'user': 'fred', 'active': false });
	 * // => 1
	 *
	 * // The `_.matchesProperty` iteratee shorthand.
	 * _.findIndex(users, ['active', false]);
	 * // => 0
	 *
	 * // The `_.property` iteratee shorthand.
	 * _.findIndex(users, 'active');
	 * // => 2
	 */
	function findIndex(array, predicate, fromIndex) {
	  var length = array ? array.length : 0;
	  if (!length) {
	    return -1;
	  }
	  var index = fromIndex == null ? 0 : toInteger(fromIndex);
	  if (index < 0) {
	    index = nativeMax(length + index, 0);
	  }
	  return baseFindIndex(array, baseIteratee(predicate, 3), index);
	}

	module.exports = findIndex;


/***/ },
/* 283 */
/***/ function(module, exports, __webpack_require__) {

	var createFind = __webpack_require__(284),
	    findIndex = __webpack_require__(282);

	/**
	 * Iterates over elements of `collection`, returning the first element
	 * `predicate` returns truthy for. The predicate is invoked with three
	 * arguments: (value, index|key, collection).
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Collection
	 * @param {Array|Object} collection The collection to inspect.
	 * @param {Function} [predicate=_.identity]
	 *  The function invoked per iteration.
	 * @param {number} [fromIndex=0] The index to search from.
	 * @returns {*} Returns the matched element, else `undefined`.
	 * @example
	 *
	 * var users = [
	 *   { 'user': 'barney',  'age': 36, 'active': true },
	 *   { 'user': 'fred',    'age': 40, 'active': false },
	 *   { 'user': 'pebbles', 'age': 1,  'active': true }
	 * ];
	 *
	 * _.find(users, function(o) { return o.age < 40; });
	 * // => object for 'barney'
	 *
	 * // The `_.matches` iteratee shorthand.
	 * _.find(users, { 'age': 1, 'active': true });
	 * // => object for 'pebbles'
	 *
	 * // The `_.matchesProperty` iteratee shorthand.
	 * _.find(users, ['active', false]);
	 * // => object for 'fred'
	 *
	 * // The `_.property` iteratee shorthand.
	 * _.find(users, 'active');
	 * // => object for 'barney'
	 */
	var find = createFind(findIndex);

	module.exports = find;


/***/ },
/* 284 */
/***/ function(module, exports, __webpack_require__) {

	var baseIteratee = __webpack_require__(42),
	    isArrayLike = __webpack_require__(30),
	    keys = __webpack_require__(25);

	/**
	 * Creates a `_.find` or `_.findLast` function.
	 *
	 * @private
	 * @param {Function} findIndexFunc The function to find the collection index.
	 * @returns {Function} Returns the new find function.
	 */
	function createFind(findIndexFunc) {
	  return function(collection, predicate, fromIndex) {
	    var iterable = Object(collection);
	    if (!isArrayLike(collection)) {
	      var iteratee = baseIteratee(predicate, 3);
	      collection = keys(collection);
	      predicate = function(key) { return iteratee(iterable[key], key, iterable); };
	    }
	    var index = findIndexFunc(collection, predicate, fromIndex);
	    return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;
	  };
	}

	module.exports = createFind;


/***/ },
/* 285 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // eslint-disable-line no-unused-vars


	var _errors = __webpack_require__(237);

	var _promise = __webpack_require__(286);

	var _promise2 = _interopRequireDefault(_promise);

	var _regeneratorRuntime = __webpack_require__(148);

	var _regeneratorRuntime2 = _interopRequireDefault(_regeneratorRuntime);

	var _forEach = __webpack_require__(19);

	var _forEach2 = _interopRequireDefault(_forEach);

	var _isString = __webpack_require__(217);

	var _isString2 = _interopRequireDefault(_isString);

	var _isArray = __webpack_require__(35);

	var _isArray2 = _interopRequireDefault(_isArray);

	var _isFunction = __webpack_require__(31);

	var _isFunction2 = _interopRequireDefault(_isFunction);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new _promise2.default(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return _promise2.default.resolve(value).then(function (value) { return step("next", value); }, function (err) { return step("throw", err); }); } } return step("next"); }); }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var dbCache = {};

	var TransactionMode = {
	  ReadWrite: 'readwrite',
	  ReadOnly: 'readonly'
	};
	Object.freeze(TransactionMode);

	var IndexedDB = function () {
	  function IndexedDB(name) {
	    _classCallCheck(this, IndexedDB);

	    if (!name) {
	      throw new Error('A name is required to use the IndexedDB adapter.', name);
	    }

	    if (!(0, _isString2.default)(name)) {
	      throw new Error('The name must be a string to use the IndexedDB adapter', name);
	    }

	    this.name = name;
	    this.inTransaction = false;
	    this.queue = [];
	  }

	  _createClass(IndexedDB, [{
	    key: 'openTransaction',
	    value: function openTransaction(collection) {
	      var write = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];
	      var success = arguments[2];

	      var _this = this;

	      var error = arguments[3];
	      var force = arguments.length <= 4 || arguments[4] === undefined ? false : arguments[4];

	      var indexedDB = global.indexedDB || global.webkitIndexedDB || global.mozIndexedDB || global.msIndexedDB;
	      var db = dbCache[this.name];

	      if (db) {
	        var containsCollection = (0, _isFunction2.default)(db.objectStoreNames.contains) ? db.objectStoreNames.contains(collection) : db.objectStoreNames.indexOf(collection) !== -1;

	        if (containsCollection) {
	          try {
	            var mode = write ? TransactionMode.ReadWrite : TransactionMode.ReadOnly;
	            var txn = db.transaction(collection, mode);

	            if (txn) {
	              return success(txn);
	            }

	            throw new Error('Unable to open a transaction for ' + collection + (' collection on the ' + this.name + ' IndexedDB database.'));
	          } catch (err) {
	            return error(err);
	          }
	        } else if (!write) {
	          return error(new _errors.NotFoundError('The ' + collection + ' collection was not found on' + (' the ' + this.name + ' IndexedDB database.')));
	        }
	      }

	      if (!force && this.inTransaction) {
	        return this.queue.push(function () {
	          _this.openTransaction(collection, write, success, error);
	        });
	      }

	      // Switch flag
	      this.inTransaction = true;
	      var request = void 0;

	      if (db) {
	        var version = db.version + 1;
	        db.close();
	        request = indexedDB.open(this.name, version);
	      } else {
	        request = indexedDB.open(this.name);
	      }

	      // If the database is opened with an higher version than its current, the
	      // `upgradeneeded` event is fired. Save the handle to the database, and
	      // create the collection.
	      request.onupgradeneeded = function (e) {
	        db = e.target.result;
	        dbCache[_this.name] = db;

	        if (write) {
	          db.createObjectStore(collection, { keyPath: '_id' });
	        }
	      };

	      // The `success` event is fired after `upgradeneeded` terminates.
	      // Save the handle to the database.
	      request.onsuccess = function (e) {
	        db = e.target.result;
	        dbCache[_this.name] = db;

	        // If a second instance of the same IndexedDB database performs an
	        // upgrade operation, the `versionchange` event is fired. Then, close the
	        // database to allow the external upgrade to proceed.
	        db.onversionchange = function () {
	          if (db) {
	            db.close();
	            db = null;
	            dbCache[_this.name] = null;
	          }
	        };

	        // Try to obtain the collection handle by recursing. Append the handlers
	        // to empty the queue upon success and failure. Set the `force` flag so
	        // all but the current transaction remain queued.
	        var wrap = function wrap(done) {
	          var callbackFn = function callbackFn(arg) {
	            done(arg);

	            // Switch flag
	            _this.inTransaction = false;

	            // The database handle has been established, we can now safely empty
	            // the queue. The queue must be emptied before invoking the concurrent
	            // operations to avoid infinite recursion.
	            if (_this.queue.length > 0) {
	              var pending = _this.queue;
	              _this.queue = [];
	              (0, _forEach2.default)(pending, function (fn) {
	                fn.call(_this);
	              });
	            }
	          };
	          return callbackFn;
	        };

	        return _this.openTransaction(collection, write, wrap(success), wrap(error), true);
	      };

	      request.onblocked = function () {
	        error(new Error('The ' + _this.name + ' IndexedDB database version can\'t be upgraded' + ' because the database is already open.'));
	      };

	      request.onerror = function (e) {
	        error(new Error('Unable to open the ' + _this.name + ' IndexedDB database.' + (' ' + e.target.error.message + '.')));
	      };

	      return request;
	    }
	  }, {
	    key: 'find',
	    value: function () {
	      var _ref = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee(collection) {
	        var _this2 = this;

	        return _regeneratorRuntime2.default.wrap(function _callee$(_context) {
	          while (1) {
	            switch (_context.prev = _context.next) {
	              case 0:
	                return _context.abrupt('return', new _promise2.default(function (resolve, reject) {
	                  _this2.openTransaction(collection, false, function (txn) {
	                    var store = txn.objectStore(collection);
	                    var request = store.openCursor();
	                    var entities = [];

	                    request.onsuccess = function (e) {
	                      var cursor = e.target.result;

	                      if (cursor) {
	                        entities.push(cursor.value);
	                        return cursor.continue();
	                      }

	                      return resolve(entities);
	                    };

	                    request.onerror = function (e) {
	                      reject(e);
	                    };
	                  }, reject);
	                }));

	              case 1:
	              case 'end':
	                return _context.stop();
	            }
	          }
	        }, _callee, this);
	      }));

	      function find(_x3) {
	        return _ref.apply(this, arguments);
	      }

	      return find;
	    }()
	  }, {
	    key: 'findById',
	    value: function () {
	      var _ref2 = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee2(collection, id) {
	        var _this3 = this;

	        return _regeneratorRuntime2.default.wrap(function _callee2$(_context2) {
	          while (1) {
	            switch (_context2.prev = _context2.next) {
	              case 0:
	                return _context2.abrupt('return', new _promise2.default(function (resolve, reject) {
	                  _this3.openTransaction(collection, false, function (txn) {
	                    var store = txn.objectStore(collection);
	                    var request = store.get(id);

	                    request.onsuccess = function (e) {
	                      var entity = e.target.result;

	                      if (entity) {
	                        resolve(entity);
	                      } else {
	                        reject(new _errors.NotFoundError('An entity with _id = ' + id + ' was not found in the ' + collection + (' collection on the ' + _this3.name + ' IndexedDB database.')));
	                      }
	                    };

	                    request.onerror = function () {
	                      reject(new _errors.NotFoundError('An entity with _id = ' + id + ' was not found in the ' + collection + (' collection on the ' + _this3.name + ' IndexedDB database.')));
	                    };
	                  }, reject);
	                }));

	              case 1:
	              case 'end':
	                return _context2.stop();
	            }
	          }
	        }, _callee2, this);
	      }));

	      function findById(_x4, _x5) {
	        return _ref2.apply(this, arguments);
	      }

	      return findById;
	    }()
	  }, {
	    key: 'save',
	    value: function () {
	      var _ref3 = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee3(collection, entities) {
	        var _this4 = this;

	        var singular;
	        return _regeneratorRuntime2.default.wrap(function _callee3$(_context3) {
	          while (1) {
	            switch (_context3.prev = _context3.next) {
	              case 0:
	                singular = false;


	                if (!(0, _isArray2.default)(entities)) {
	                  singular = true;
	                  entities = [entities];
	                }

	                if (!(entities.length === 0)) {
	                  _context3.next = 4;
	                  break;
	                }

	                return _context3.abrupt('return', null);

	              case 4:
	                return _context3.abrupt('return', new _promise2.default(function (resolve, reject) {
	                  _this4.openTransaction(collection, true, function (txn) {
	                    var store = txn.objectStore(collection);

	                    (0, _forEach2.default)(entities, function (entity) {
	                      store.put(entity);
	                    });

	                    txn.oncomplete = function () {
	                      resolve(singular ? entities[0] : entities);
	                    };

	                    txn.onerror = function (e) {
	                      reject(new Error('An error occurred while saving the entities to the ' + collection + (' collection on the ' + _this4.name + ' IndexedDB database. ' + e.target.error.message + '.')));
	                    };
	                  }, reject);
	                }));

	              case 5:
	              case 'end':
	                return _context3.stop();
	            }
	          }
	        }, _callee3, this);
	      }));

	      function save(_x6, _x7) {
	        return _ref3.apply(this, arguments);
	      }

	      return save;
	    }()
	  }, {
	    key: 'removeById',
	    value: function () {
	      var _ref4 = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee4(collection, id) {
	        var _this5 = this;

	        return _regeneratorRuntime2.default.wrap(function _callee4$(_context4) {
	          while (1) {
	            switch (_context4.prev = _context4.next) {
	              case 0:
	                return _context4.abrupt('return', new _promise2.default(function (resolve, reject) {
	                  _this5.openTransaction(collection, true, function (txn) {
	                    var store = txn.objectStore(collection);
	                    var request = store.get(id);
	                    store.delete(id);

	                    txn.oncomplete = function () {
	                      var entity = request.result;

	                      if (entity) {
	                        resolve(entity);
	                      } else {
	                        reject(new _errors.NotFoundError('An entity with id = ' + id + ' was not found in the ' + collection + (' collection on the ' + _this5.name + ' IndexedDB database.')));
	                      }
	                    };

	                    txn.onerror = function () {
	                      reject(new _errors.NotFoundError('An entity with id = ' + id + ' was not found in the ' + collection + (' collection on the ' + _this5.name + ' IndexedDB database.')));
	                    };
	                  }, reject);
	                }));

	              case 1:
	              case 'end':
	                return _context4.stop();
	            }
	          }
	        }, _callee4, this);
	      }));

	      function removeById(_x8, _x9) {
	        return _ref4.apply(this, arguments);
	      }

	      return removeById;
	    }()
	  }, {
	    key: 'clear',
	    value: function () {
	      var _ref5 = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee5() {
	        var _this6 = this;

	        return _regeneratorRuntime2.default.wrap(function _callee5$(_context5) {
	          while (1) {
	            switch (_context5.prev = _context5.next) {
	              case 0:
	                return _context5.abrupt('return', new _promise2.default(function (resolve, reject) {
	                  var indexedDB = global.indexedDB || global.webkitIndexedDB || global.mozIndexedDB || global.msIndexedDB;
	                  var request = indexedDB.deleteDatabase(_this6.name);

	                  request.onsuccess = function () {
	                    dbCache = {};
	                    resolve();
	                  };

	                  request.onerror = function (e) {
	                    reject(new Error('An error occurred while clearing the ' + _this6.name + ' IndexedDB database.' + (' ' + e.target.error.message + '.')));
	                  };
	                }));

	              case 1:
	              case 'end':
	                return _context5.stop();
	            }
	          }
	        }, _callee5, this);
	      }));

	      function clear() {
	        return _ref5.apply(this, arguments);
	      }

	      return clear;
	    }()
	  }], [{
	    key: 'isSupported',
	    value: function isSupported() {
	      var indexedDB = global.indexedDB || global.webkitIndexedDB || global.mozIndexedDB || global.msIndexedDB;
	      return !!indexedDB;
	    }
	  }]);

	  return IndexedDB;
	}();

	exports.default = IndexedDB;
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 286 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(287);
	__webpack_require__(307);
	__webpack_require__(333);
	__webpack_require__(337);
	module.exports = __webpack_require__(306).Promise;

/***/ },
/* 287 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 19.1.3.6 Object.prototype.toString()
	var classof = __webpack_require__(288)
	  , test    = {};
	test[__webpack_require__(290)('toStringTag')] = 'z';
	if(test + '' != '[object z]'){
	  __webpack_require__(294)(Object.prototype, 'toString', function toString(){
	    return '[object ' + classof(this) + ']';
	  }, true);
	}

/***/ },
/* 288 */
/***/ function(module, exports, __webpack_require__) {

	// getting tag from 19.1.3.6 Object.prototype.toString()
	var cof = __webpack_require__(289)
	  , TAG = __webpack_require__(290)('toStringTag')
	  // ES3 wrong here
	  , ARG = cof(function(){ return arguments; }()) == 'Arguments';

	// fallback for IE11 Script Access Denied error
	var tryGet = function(it, key){
	  try {
	    return it[key];
	  } catch(e){ /* empty */ }
	};

	module.exports = function(it){
	  var O, T, B;
	  return it === undefined ? 'Undefined' : it === null ? 'Null'
	    // @@toStringTag case
	    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
	    // builtinTag case
	    : ARG ? cof(O)
	    // ES3 arguments fallback
	    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
	};

/***/ },
/* 289 */
/***/ function(module, exports) {

	var toString = {}.toString;

	module.exports = function(it){
	  return toString.call(it).slice(8, -1);
	};

/***/ },
/* 290 */
/***/ function(module, exports, __webpack_require__) {

	var store      = __webpack_require__(291)('wks')
	  , uid        = __webpack_require__(293)
	  , Symbol     = __webpack_require__(292).Symbol
	  , USE_SYMBOL = typeof Symbol == 'function';

	var $exports = module.exports = function(name){
	  return store[name] || (store[name] =
	    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
	};

	$exports.store = store;

/***/ },
/* 291 */
/***/ function(module, exports, __webpack_require__) {

	var global = __webpack_require__(292)
	  , SHARED = '__core-js_shared__'
	  , store  = global[SHARED] || (global[SHARED] = {});
	module.exports = function(key){
	  return store[key] || (store[key] = {});
	};

/***/ },
/* 292 */
/***/ function(module, exports) {

	// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
	var global = module.exports = typeof window != 'undefined' && window.Math == Math
	  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
	if(typeof __g == 'number')__g = global; // eslint-disable-line no-undef

/***/ },
/* 293 */
/***/ function(module, exports) {

	var id = 0
	  , px = Math.random();
	module.exports = function(key){
	  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
	};

/***/ },
/* 294 */
/***/ function(module, exports, __webpack_require__) {

	var global    = __webpack_require__(292)
	  , hide      = __webpack_require__(295)
	  , has       = __webpack_require__(305)
	  , SRC       = __webpack_require__(293)('src')
	  , TO_STRING = 'toString'
	  , $toString = Function[TO_STRING]
	  , TPL       = ('' + $toString).split(TO_STRING);

	__webpack_require__(306).inspectSource = function(it){
	  return $toString.call(it);
	};

	(module.exports = function(O, key, val, safe){
	  var isFunction = typeof val == 'function';
	  if(isFunction)has(val, 'name') || hide(val, 'name', key);
	  if(O[key] === val)return;
	  if(isFunction)has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
	  if(O === global){
	    O[key] = val;
	  } else {
	    if(!safe){
	      delete O[key];
	      hide(O, key, val);
	    } else {
	      if(O[key])O[key] = val;
	      else hide(O, key, val);
	    }
	  }
	// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
	})(Function.prototype, TO_STRING, function toString(){
	  return typeof this == 'function' && this[SRC] || $toString.call(this);
	});

/***/ },
/* 295 */
/***/ function(module, exports, __webpack_require__) {

	var dP         = __webpack_require__(296)
	  , createDesc = __webpack_require__(304);
	module.exports = __webpack_require__(300) ? function(object, key, value){
	  return dP.f(object, key, createDesc(1, value));
	} : function(object, key, value){
	  object[key] = value;
	  return object;
	};

/***/ },
/* 296 */
/***/ function(module, exports, __webpack_require__) {

	var anObject       = __webpack_require__(297)
	  , IE8_DOM_DEFINE = __webpack_require__(299)
	  , toPrimitive    = __webpack_require__(303)
	  , dP             = Object.defineProperty;

	exports.f = __webpack_require__(300) ? Object.defineProperty : function defineProperty(O, P, Attributes){
	  anObject(O);
	  P = toPrimitive(P, true);
	  anObject(Attributes);
	  if(IE8_DOM_DEFINE)try {
	    return dP(O, P, Attributes);
	  } catch(e){ /* empty */ }
	  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');
	  if('value' in Attributes)O[P] = Attributes.value;
	  return O;
	};

/***/ },
/* 297 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(298);
	module.exports = function(it){
	  if(!isObject(it))throw TypeError(it + ' is not an object!');
	  return it;
	};

/***/ },
/* 298 */
/***/ function(module, exports) {

	module.exports = function(it){
	  return typeof it === 'object' ? it !== null : typeof it === 'function';
	};

/***/ },
/* 299 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = !__webpack_require__(300) && !__webpack_require__(301)(function(){
	  return Object.defineProperty(__webpack_require__(302)('div'), 'a', {get: function(){ return 7; }}).a != 7;
	});

/***/ },
/* 300 */
/***/ function(module, exports, __webpack_require__) {

	// Thank's IE8 for his funny defineProperty
	module.exports = !__webpack_require__(301)(function(){
	  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;
	});

/***/ },
/* 301 */
/***/ function(module, exports) {

	module.exports = function(exec){
	  try {
	    return !!exec();
	  } catch(e){
	    return true;
	  }
	};

/***/ },
/* 302 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(298)
	  , document = __webpack_require__(292).document
	  // in old IE typeof document.createElement is 'object'
	  , is = isObject(document) && isObject(document.createElement);
	module.exports = function(it){
	  return is ? document.createElement(it) : {};
	};

/***/ },
/* 303 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.1 ToPrimitive(input [, PreferredType])
	var isObject = __webpack_require__(298);
	// instead of the ES6 spec version, we didn't implement @@toPrimitive case
	// and the second argument - flag - preferred type is a string
	module.exports = function(it, S){
	  if(!isObject(it))return it;
	  var fn, val;
	  if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
	  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;
	  if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
	  throw TypeError("Can't convert object to primitive value");
	};

/***/ },
/* 304 */
/***/ function(module, exports) {

	module.exports = function(bitmap, value){
	  return {
	    enumerable  : !(bitmap & 1),
	    configurable: !(bitmap & 2),
	    writable    : !(bitmap & 4),
	    value       : value
	  };
	};

/***/ },
/* 305 */
/***/ function(module, exports) {

	var hasOwnProperty = {}.hasOwnProperty;
	module.exports = function(it, key){
	  return hasOwnProperty.call(it, key);
	};

/***/ },
/* 306 */
/***/ function(module, exports) {

	var core = module.exports = {version: '2.4.0'};
	if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef

/***/ },
/* 307 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $at  = __webpack_require__(308)(true);

	// 21.1.3.27 String.prototype[@@iterator]()
	__webpack_require__(311)(String, 'String', function(iterated){
	  this._t = String(iterated); // target
	  this._i = 0;                // next index
	// 21.1.5.2.1 %StringIteratorPrototype%.next()
	}, function(){
	  var O     = this._t
	    , index = this._i
	    , point;
	  if(index >= O.length)return {value: undefined, done: true};
	  point = $at(O, index);
	  this._i += point.length;
	  return {value: point, done: false};
	});

/***/ },
/* 308 */
/***/ function(module, exports, __webpack_require__) {

	var toInteger = __webpack_require__(309)
	  , defined   = __webpack_require__(310);
	// true  -> String#at
	// false -> String#codePointAt
	module.exports = function(TO_STRING){
	  return function(that, pos){
	    var s = String(defined(that))
	      , i = toInteger(pos)
	      , l = s.length
	      , a, b;
	    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;
	    a = s.charCodeAt(i);
	    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
	      ? TO_STRING ? s.charAt(i) : a
	      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
	  };
	};

/***/ },
/* 309 */
/***/ function(module, exports) {

	// 7.1.4 ToInteger
	var ceil  = Math.ceil
	  , floor = Math.floor;
	module.exports = function(it){
	  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
	};

/***/ },
/* 310 */
/***/ function(module, exports) {

	// 7.2.1 RequireObjectCoercible(argument)
	module.exports = function(it){
	  if(it == undefined)throw TypeError("Can't call method on  " + it);
	  return it;
	};

/***/ },
/* 311 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var LIBRARY        = __webpack_require__(312)
	  , $export        = __webpack_require__(313)
	  , redefine       = __webpack_require__(294)
	  , hide           = __webpack_require__(295)
	  , has            = __webpack_require__(305)
	  , Iterators      = __webpack_require__(316)
	  , $iterCreate    = __webpack_require__(317)
	  , setToStringTag = __webpack_require__(330)
	  , getPrototypeOf = __webpack_require__(331)
	  , ITERATOR       = __webpack_require__(290)('iterator')
	  , BUGGY          = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`
	  , FF_ITERATOR    = '@@iterator'
	  , KEYS           = 'keys'
	  , VALUES         = 'values';

	var returnThis = function(){ return this; };

	module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){
	  $iterCreate(Constructor, NAME, next);
	  var getMethod = function(kind){
	    if(!BUGGY && kind in proto)return proto[kind];
	    switch(kind){
	      case KEYS: return function keys(){ return new Constructor(this, kind); };
	      case VALUES: return function values(){ return new Constructor(this, kind); };
	    } return function entries(){ return new Constructor(this, kind); };
	  };
	  var TAG        = NAME + ' Iterator'
	    , DEF_VALUES = DEFAULT == VALUES
	    , VALUES_BUG = false
	    , proto      = Base.prototype
	    , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]
	    , $default   = $native || getMethod(DEFAULT)
	    , $entries   = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined
	    , $anyNative = NAME == 'Array' ? proto.entries || $native : $native
	    , methods, key, IteratorPrototype;
	  // Fix native
	  if($anyNative){
	    IteratorPrototype = getPrototypeOf($anyNative.call(new Base));
	    if(IteratorPrototype !== Object.prototype){
	      // Set @@toStringTag to native iterators
	      setToStringTag(IteratorPrototype, TAG, true);
	      // fix for some old engines
	      if(!LIBRARY && !has(IteratorPrototype, ITERATOR))hide(IteratorPrototype, ITERATOR, returnThis);
	    }
	  }
	  // fix Array#{values, @@iterator}.name in V8 / FF
	  if(DEF_VALUES && $native && $native.name !== VALUES){
	    VALUES_BUG = true;
	    $default = function values(){ return $native.call(this); };
	  }
	  // Define iterator
	  if((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){
	    hide(proto, ITERATOR, $default);
	  }
	  // Plug for library
	  Iterators[NAME] = $default;
	  Iterators[TAG]  = returnThis;
	  if(DEFAULT){
	    methods = {
	      values:  DEF_VALUES ? $default : getMethod(VALUES),
	      keys:    IS_SET     ? $default : getMethod(KEYS),
	      entries: $entries
	    };
	    if(FORCED)for(key in methods){
	      if(!(key in proto))redefine(proto, key, methods[key]);
	    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
	  }
	  return methods;
	};

/***/ },
/* 312 */
/***/ function(module, exports) {

	module.exports = false;

/***/ },
/* 313 */
/***/ function(module, exports, __webpack_require__) {

	var global    = __webpack_require__(292)
	  , core      = __webpack_require__(306)
	  , hide      = __webpack_require__(295)
	  , redefine  = __webpack_require__(294)
	  , ctx       = __webpack_require__(314)
	  , PROTOTYPE = 'prototype';

	var $export = function(type, name, source){
	  var IS_FORCED = type & $export.F
	    , IS_GLOBAL = type & $export.G
	    , IS_STATIC = type & $export.S
	    , IS_PROTO  = type & $export.P
	    , IS_BIND   = type & $export.B
	    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE]
	    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})
	    , expProto  = exports[PROTOTYPE] || (exports[PROTOTYPE] = {})
	    , key, own, out, exp;
	  if(IS_GLOBAL)source = name;
	  for(key in source){
	    // contains in native
	    own = !IS_FORCED && target && target[key] !== undefined;
	    // export native or passed
	    out = (own ? target : source)[key];
	    // bind timers to global for call from export context
	    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
	    // extend global
	    if(target)redefine(target, key, out, type & $export.U);
	    // export
	    if(exports[key] != out)hide(exports, key, exp);
	    if(IS_PROTO && expProto[key] != out)expProto[key] = out;
	  }
	};
	global.core = core;
	// type bitmap
	$export.F = 1;   // forced
	$export.G = 2;   // global
	$export.S = 4;   // static
	$export.P = 8;   // proto
	$export.B = 16;  // bind
	$export.W = 32;  // wrap
	$export.U = 64;  // safe
	$export.R = 128; // real proto method for `library` 
	module.exports = $export;

/***/ },
/* 314 */
/***/ function(module, exports, __webpack_require__) {

	// optional / simple context binding
	var aFunction = __webpack_require__(315);
	module.exports = function(fn, that, length){
	  aFunction(fn);
	  if(that === undefined)return fn;
	  switch(length){
	    case 1: return function(a){
	      return fn.call(that, a);
	    };
	    case 2: return function(a, b){
	      return fn.call(that, a, b);
	    };
	    case 3: return function(a, b, c){
	      return fn.call(that, a, b, c);
	    };
	  }
	  return function(/* ...args */){
	    return fn.apply(that, arguments);
	  };
	};

/***/ },
/* 315 */
/***/ function(module, exports) {

	module.exports = function(it){
	  if(typeof it != 'function')throw TypeError(it + ' is not a function!');
	  return it;
	};

/***/ },
/* 316 */
/***/ function(module, exports) {

	module.exports = {};

/***/ },
/* 317 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var create         = __webpack_require__(318)
	  , descriptor     = __webpack_require__(304)
	  , setToStringTag = __webpack_require__(330)
	  , IteratorPrototype = {};

	// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
	__webpack_require__(295)(IteratorPrototype, __webpack_require__(290)('iterator'), function(){ return this; });

	module.exports = function(Constructor, NAME, next){
	  Constructor.prototype = create(IteratorPrototype, {next: descriptor(1, next)});
	  setToStringTag(Constructor, NAME + ' Iterator');
	};

/***/ },
/* 318 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
	var anObject    = __webpack_require__(297)
	  , dPs         = __webpack_require__(319)
	  , enumBugKeys = __webpack_require__(328)
	  , IE_PROTO    = __webpack_require__(327)('IE_PROTO')
	  , Empty       = function(){ /* empty */ }
	  , PROTOTYPE   = 'prototype';

	// Create object with fake `null` prototype: use iframe Object with cleared prototype
	var createDict = function(){
	  // Thrash, waste and sodomy: IE GC bug
	  var iframe = __webpack_require__(302)('iframe')
	    , i      = enumBugKeys.length
	    , lt     = '<'
	    , gt     = '>'
	    , iframeDocument;
	  iframe.style.display = 'none';
	  __webpack_require__(329).appendChild(iframe);
	  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
	  // createDict = iframe.contentWindow.Object;
	  // html.removeChild(iframe);
	  iframeDocument = iframe.contentWindow.document;
	  iframeDocument.open();
	  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
	  iframeDocument.close();
	  createDict = iframeDocument.F;
	  while(i--)delete createDict[PROTOTYPE][enumBugKeys[i]];
	  return createDict();
	};

	module.exports = Object.create || function create(O, Properties){
	  var result;
	  if(O !== null){
	    Empty[PROTOTYPE] = anObject(O);
	    result = new Empty;
	    Empty[PROTOTYPE] = null;
	    // add "__proto__" for Object.getPrototypeOf polyfill
	    result[IE_PROTO] = O;
	  } else result = createDict();
	  return Properties === undefined ? result : dPs(result, Properties);
	};


/***/ },
/* 319 */
/***/ function(module, exports, __webpack_require__) {

	var dP       = __webpack_require__(296)
	  , anObject = __webpack_require__(297)
	  , getKeys  = __webpack_require__(320);

	module.exports = __webpack_require__(300) ? Object.defineProperties : function defineProperties(O, Properties){
	  anObject(O);
	  var keys   = getKeys(Properties)
	    , length = keys.length
	    , i = 0
	    , P;
	  while(length > i)dP.f(O, P = keys[i++], Properties[P]);
	  return O;
	};

/***/ },
/* 320 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.14 / 15.2.3.14 Object.keys(O)
	var $keys       = __webpack_require__(321)
	  , enumBugKeys = __webpack_require__(328);

	module.exports = Object.keys || function keys(O){
	  return $keys(O, enumBugKeys);
	};

/***/ },
/* 321 */
/***/ function(module, exports, __webpack_require__) {

	var has          = __webpack_require__(305)
	  , toIObject    = __webpack_require__(322)
	  , arrayIndexOf = __webpack_require__(324)(false)
	  , IE_PROTO     = __webpack_require__(327)('IE_PROTO');

	module.exports = function(object, names){
	  var O      = toIObject(object)
	    , i      = 0
	    , result = []
	    , key;
	  for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);
	  // Don't enum bug & hidden keys
	  while(names.length > i)if(has(O, key = names[i++])){
	    ~arrayIndexOf(result, key) || result.push(key);
	  }
	  return result;
	};

/***/ },
/* 322 */
/***/ function(module, exports, __webpack_require__) {

	// to indexed object, toObject with fallback for non-array-like ES3 strings
	var IObject = __webpack_require__(323)
	  , defined = __webpack_require__(310);
	module.exports = function(it){
	  return IObject(defined(it));
	};

/***/ },
/* 323 */
/***/ function(module, exports, __webpack_require__) {

	// fallback for non-array-like ES3 and non-enumerable old V8 strings
	var cof = __webpack_require__(289);
	module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){
	  return cof(it) == 'String' ? it.split('') : Object(it);
	};

/***/ },
/* 324 */
/***/ function(module, exports, __webpack_require__) {

	// false -> Array#indexOf
	// true  -> Array#includes
	var toIObject = __webpack_require__(322)
	  , toLength  = __webpack_require__(325)
	  , toIndex   = __webpack_require__(326);
	module.exports = function(IS_INCLUDES){
	  return function($this, el, fromIndex){
	    var O      = toIObject($this)
	      , length = toLength(O.length)
	      , index  = toIndex(fromIndex, length)
	      , value;
	    // Array#includes uses SameValueZero equality algorithm
	    if(IS_INCLUDES && el != el)while(length > index){
	      value = O[index++];
	      if(value != value)return true;
	    // Array#toIndex ignores holes, Array#includes - not
	    } else for(;length > index; index++)if(IS_INCLUDES || index in O){
	      if(O[index] === el)return IS_INCLUDES || index || 0;
	    } return !IS_INCLUDES && -1;
	  };
	};

/***/ },
/* 325 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.15 ToLength
	var toInteger = __webpack_require__(309)
	  , min       = Math.min;
	module.exports = function(it){
	  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
	};

/***/ },
/* 326 */
/***/ function(module, exports, __webpack_require__) {

	var toInteger = __webpack_require__(309)
	  , max       = Math.max
	  , min       = Math.min;
	module.exports = function(index, length){
	  index = toInteger(index);
	  return index < 0 ? max(index + length, 0) : min(index, length);
	};

/***/ },
/* 327 */
/***/ function(module, exports, __webpack_require__) {

	var shared = __webpack_require__(291)('keys')
	  , uid    = __webpack_require__(293);
	module.exports = function(key){
	  return shared[key] || (shared[key] = uid(key));
	};

/***/ },
/* 328 */
/***/ function(module, exports) {

	// IE 8- don't enum bug keys
	module.exports = (
	  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
	).split(',');

/***/ },
/* 329 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(292).document && document.documentElement;

/***/ },
/* 330 */
/***/ function(module, exports, __webpack_require__) {

	var def = __webpack_require__(296).f
	  , has = __webpack_require__(305)
	  , TAG = __webpack_require__(290)('toStringTag');

	module.exports = function(it, tag, stat){
	  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});
	};

/***/ },
/* 331 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
	var has         = __webpack_require__(305)
	  , toObject    = __webpack_require__(332)
	  , IE_PROTO    = __webpack_require__(327)('IE_PROTO')
	  , ObjectProto = Object.prototype;

	module.exports = Object.getPrototypeOf || function(O){
	  O = toObject(O);
	  if(has(O, IE_PROTO))return O[IE_PROTO];
	  if(typeof O.constructor == 'function' && O instanceof O.constructor){
	    return O.constructor.prototype;
	  } return O instanceof Object ? ObjectProto : null;
	};

/***/ },
/* 332 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.13 ToObject(argument)
	var defined = __webpack_require__(310);
	module.exports = function(it){
	  return Object(defined(it));
	};

/***/ },
/* 333 */
/***/ function(module, exports, __webpack_require__) {

	var $iterators    = __webpack_require__(334)
	  , redefine      = __webpack_require__(294)
	  , global        = __webpack_require__(292)
	  , hide          = __webpack_require__(295)
	  , Iterators     = __webpack_require__(316)
	  , wks           = __webpack_require__(290)
	  , ITERATOR      = wks('iterator')
	  , TO_STRING_TAG = wks('toStringTag')
	  , ArrayValues   = Iterators.Array;

	for(var collections = ['NodeList', 'DOMTokenList', 'MediaList', 'StyleSheetList', 'CSSRuleList'], i = 0; i < 5; i++){
	  var NAME       = collections[i]
	    , Collection = global[NAME]
	    , proto      = Collection && Collection.prototype
	    , key;
	  if(proto){
	    if(!proto[ITERATOR])hide(proto, ITERATOR, ArrayValues);
	    if(!proto[TO_STRING_TAG])hide(proto, TO_STRING_TAG, NAME);
	    Iterators[NAME] = ArrayValues;
	    for(key in $iterators)if(!proto[key])redefine(proto, key, $iterators[key], true);
	  }
	}

/***/ },
/* 334 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var addToUnscopables = __webpack_require__(335)
	  , step             = __webpack_require__(336)
	  , Iterators        = __webpack_require__(316)
	  , toIObject        = __webpack_require__(322);

	// 22.1.3.4 Array.prototype.entries()
	// 22.1.3.13 Array.prototype.keys()
	// 22.1.3.29 Array.prototype.values()
	// 22.1.3.30 Array.prototype[@@iterator]()
	module.exports = __webpack_require__(311)(Array, 'Array', function(iterated, kind){
	  this._t = toIObject(iterated); // target
	  this._i = 0;                   // next index
	  this._k = kind;                // kind
	// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
	}, function(){
	  var O     = this._t
	    , kind  = this._k
	    , index = this._i++;
	  if(!O || index >= O.length){
	    this._t = undefined;
	    return step(1);
	  }
	  if(kind == 'keys'  )return step(0, index);
	  if(kind == 'values')return step(0, O[index]);
	  return step(0, [index, O[index]]);
	}, 'values');

	// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
	Iterators.Arguments = Iterators.Array;

	addToUnscopables('keys');
	addToUnscopables('values');
	addToUnscopables('entries');

/***/ },
/* 335 */
/***/ function(module, exports, __webpack_require__) {

	// 22.1.3.31 Array.prototype[@@unscopables]
	var UNSCOPABLES = __webpack_require__(290)('unscopables')
	  , ArrayProto  = Array.prototype;
	if(ArrayProto[UNSCOPABLES] == undefined)__webpack_require__(295)(ArrayProto, UNSCOPABLES, {});
	module.exports = function(key){
	  ArrayProto[UNSCOPABLES][key] = true;
	};

/***/ },
/* 336 */
/***/ function(module, exports) {

	module.exports = function(done, value){
	  return {value: value, done: !!done};
	};

/***/ },
/* 337 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var LIBRARY            = __webpack_require__(312)
	  , global             = __webpack_require__(292)
	  , ctx                = __webpack_require__(314)
	  , classof            = __webpack_require__(288)
	  , $export            = __webpack_require__(313)
	  , isObject           = __webpack_require__(298)
	  , aFunction          = __webpack_require__(315)
	  , anInstance         = __webpack_require__(338)
	  , forOf              = __webpack_require__(339)
	  , speciesConstructor = __webpack_require__(343)
	  , task               = __webpack_require__(344).set
	  , microtask          = __webpack_require__(346)()
	  , PROMISE            = 'Promise'
	  , TypeError          = global.TypeError
	  , process            = global.process
	  , $Promise           = global[PROMISE]
	  , process            = global.process
	  , isNode             = classof(process) == 'process'
	  , empty              = function(){ /* empty */ }
	  , Internal, GenericPromiseCapability, Wrapper;

	var USE_NATIVE = !!function(){
	  try {
	    // correct subclassing with @@species support
	    var promise     = $Promise.resolve(1)
	      , FakePromise = (promise.constructor = {})[__webpack_require__(290)('species')] = function(exec){ exec(empty, empty); };
	    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
	    return (isNode || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise;
	  } catch(e){ /* empty */ }
	}();

	// helpers
	var sameConstructor = function(a, b){
	  // with library wrapper special case
	  return a === b || a === $Promise && b === Wrapper;
	};
	var isThenable = function(it){
	  var then;
	  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
	};
	var newPromiseCapability = function(C){
	  return sameConstructor($Promise, C)
	    ? new PromiseCapability(C)
	    : new GenericPromiseCapability(C);
	};
	var PromiseCapability = GenericPromiseCapability = function(C){
	  var resolve, reject;
	  this.promise = new C(function($$resolve, $$reject){
	    if(resolve !== undefined || reject !== undefined)throw TypeError('Bad Promise constructor');
	    resolve = $$resolve;
	    reject  = $$reject;
	  });
	  this.resolve = aFunction(resolve);
	  this.reject  = aFunction(reject);
	};
	var perform = function(exec){
	  try {
	    exec();
	  } catch(e){
	    return {error: e};
	  }
	};
	var notify = function(promise, isReject){
	  if(promise._n)return;
	  promise._n = true;
	  var chain = promise._c;
	  microtask(function(){
	    var value = promise._v
	      , ok    = promise._s == 1
	      , i     = 0;
	    var run = function(reaction){
	      var handler = ok ? reaction.ok : reaction.fail
	        , resolve = reaction.resolve
	        , reject  = reaction.reject
	        , domain  = reaction.domain
	        , result, then;
	      try {
	        if(handler){
	          if(!ok){
	            if(promise._h == 2)onHandleUnhandled(promise);
	            promise._h = 1;
	          }
	          if(handler === true)result = value;
	          else {
	            if(domain)domain.enter();
	            result = handler(value);
	            if(domain)domain.exit();
	          }
	          if(result === reaction.promise){
	            reject(TypeError('Promise-chain cycle'));
	          } else if(then = isThenable(result)){
	            then.call(result, resolve, reject);
	          } else resolve(result);
	        } else reject(value);
	      } catch(e){
	        reject(e);
	      }
	    };
	    while(chain.length > i)run(chain[i++]); // variable length - can't use forEach
	    promise._c = [];
	    promise._n = false;
	    if(isReject && !promise._h)onUnhandled(promise);
	  });
	};
	var onUnhandled = function(promise){
	  task.call(global, function(){
	    var value = promise._v
	      , abrupt, handler, console;
	    if(isUnhandled(promise)){
	      abrupt = perform(function(){
	        if(isNode){
	          process.emit('unhandledRejection', value, promise);
	        } else if(handler = global.onunhandledrejection){
	          handler({promise: promise, reason: value});
	        } else if((console = global.console) && console.error){
	          console.error('Unhandled promise rejection', value);
	        }
	      });
	      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
	      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
	    } promise._a = undefined;
	    if(abrupt)throw abrupt.error;
	  });
	};
	var isUnhandled = function(promise){
	  if(promise._h == 1)return false;
	  var chain = promise._a || promise._c
	    , i     = 0
	    , reaction;
	  while(chain.length > i){
	    reaction = chain[i++];
	    if(reaction.fail || !isUnhandled(reaction.promise))return false;
	  } return true;
	};
	var onHandleUnhandled = function(promise){
	  task.call(global, function(){
	    var handler;
	    if(isNode){
	      process.emit('rejectionHandled', promise);
	    } else if(handler = global.onrejectionhandled){
	      handler({promise: promise, reason: promise._v});
	    }
	  });
	};
	var $reject = function(value){
	  var promise = this;
	  if(promise._d)return;
	  promise._d = true;
	  promise = promise._w || promise; // unwrap
	  promise._v = value;
	  promise._s = 2;
	  if(!promise._a)promise._a = promise._c.slice();
	  notify(promise, true);
	};
	var $resolve = function(value){
	  var promise = this
	    , then;
	  if(promise._d)return;
	  promise._d = true;
	  promise = promise._w || promise; // unwrap
	  try {
	    if(promise === value)throw TypeError("Promise can't be resolved itself");
	    if(then = isThenable(value)){
	      microtask(function(){
	        var wrapper = {_w: promise, _d: false}; // wrap
	        try {
	          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
	        } catch(e){
	          $reject.call(wrapper, e);
	        }
	      });
	    } else {
	      promise._v = value;
	      promise._s = 1;
	      notify(promise, false);
	    }
	  } catch(e){
	    $reject.call({_w: promise, _d: false}, e); // wrap
	  }
	};

	// constructor polyfill
	if(!USE_NATIVE){
	  // 25.4.3.1 Promise(executor)
	  $Promise = function Promise(executor){
	    anInstance(this, $Promise, PROMISE, '_h');
	    aFunction(executor);
	    Internal.call(this);
	    try {
	      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
	    } catch(err){
	      $reject.call(this, err);
	    }
	  };
	  Internal = function Promise(executor){
	    this._c = [];             // <- awaiting reactions
	    this._a = undefined;      // <- checked in isUnhandled reactions
	    this._s = 0;              // <- state
	    this._d = false;          // <- done
	    this._v = undefined;      // <- value
	    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
	    this._n = false;          // <- notify
	  };
	  Internal.prototype = __webpack_require__(347)($Promise.prototype, {
	    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
	    then: function then(onFulfilled, onRejected){
	      var reaction    = newPromiseCapability(speciesConstructor(this, $Promise));
	      reaction.ok     = typeof onFulfilled == 'function' ? onFulfilled : true;
	      reaction.fail   = typeof onRejected == 'function' && onRejected;
	      reaction.domain = isNode ? process.domain : undefined;
	      this._c.push(reaction);
	      if(this._a)this._a.push(reaction);
	      if(this._s)notify(this, false);
	      return reaction.promise;
	    },
	    // 25.4.5.1 Promise.prototype.catch(onRejected)
	    'catch': function(onRejected){
	      return this.then(undefined, onRejected);
	    }
	  });
	  PromiseCapability = function(){
	    var promise  = new Internal;
	    this.promise = promise;
	    this.resolve = ctx($resolve, promise, 1);
	    this.reject  = ctx($reject, promise, 1);
	  };
	}

	$export($export.G + $export.W + $export.F * !USE_NATIVE, {Promise: $Promise});
	__webpack_require__(330)($Promise, PROMISE);
	__webpack_require__(348)(PROMISE);
	Wrapper = __webpack_require__(306)[PROMISE];

	// statics
	$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
	  // 25.4.4.5 Promise.reject(r)
	  reject: function reject(r){
	    var capability = newPromiseCapability(this)
	      , $$reject   = capability.reject;
	    $$reject(r);
	    return capability.promise;
	  }
	});
	$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
	  // 25.4.4.6 Promise.resolve(x)
	  resolve: function resolve(x){
	    // instanceof instead of internal slot check because we should fix it without replacement native Promise core
	    if(x instanceof $Promise && sameConstructor(x.constructor, this))return x;
	    var capability = newPromiseCapability(this)
	      , $$resolve  = capability.resolve;
	    $$resolve(x);
	    return capability.promise;
	  }
	});
	$export($export.S + $export.F * !(USE_NATIVE && __webpack_require__(349)(function(iter){
	  $Promise.all(iter)['catch'](empty);
	})), PROMISE, {
	  // 25.4.4.1 Promise.all(iterable)
	  all: function all(iterable){
	    var C          = this
	      , capability = newPromiseCapability(C)
	      , resolve    = capability.resolve
	      , reject     = capability.reject;
	    var abrupt = perform(function(){
	      var values    = []
	        , index     = 0
	        , remaining = 1;
	      forOf(iterable, false, function(promise){
	        var $index        = index++
	          , alreadyCalled = false;
	        values.push(undefined);
	        remaining++;
	        C.resolve(promise).then(function(value){
	          if(alreadyCalled)return;
	          alreadyCalled  = true;
	          values[$index] = value;
	          --remaining || resolve(values);
	        }, reject);
	      });
	      --remaining || resolve(values);
	    });
	    if(abrupt)reject(abrupt.error);
	    return capability.promise;
	  },
	  // 25.4.4.4 Promise.race(iterable)
	  race: function race(iterable){
	    var C          = this
	      , capability = newPromiseCapability(C)
	      , reject     = capability.reject;
	    var abrupt = perform(function(){
	      forOf(iterable, false, function(promise){
	        C.resolve(promise).then(capability.resolve, reject);
	      });
	    });
	    if(abrupt)reject(abrupt.error);
	    return capability.promise;
	  }
	});

/***/ },
/* 338 */
/***/ function(module, exports) {

	module.exports = function(it, Constructor, name, forbiddenField){
	  if(!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)){
	    throw TypeError(name + ': incorrect invocation!');
	  } return it;
	};

/***/ },
/* 339 */
/***/ function(module, exports, __webpack_require__) {

	var ctx         = __webpack_require__(314)
	  , call        = __webpack_require__(340)
	  , isArrayIter = __webpack_require__(341)
	  , anObject    = __webpack_require__(297)
	  , toLength    = __webpack_require__(325)
	  , getIterFn   = __webpack_require__(342)
	  , BREAK       = {}
	  , RETURN      = {};
	var exports = module.exports = function(iterable, entries, fn, that, ITERATOR){
	  var iterFn = ITERATOR ? function(){ return iterable; } : getIterFn(iterable)
	    , f      = ctx(fn, that, entries ? 2 : 1)
	    , index  = 0
	    , length, step, iterator, result;
	  if(typeof iterFn != 'function')throw TypeError(iterable + ' is not iterable!');
	  // fast case for arrays with default iterator
	  if(isArrayIter(iterFn))for(length = toLength(iterable.length); length > index; index++){
	    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
	    if(result === BREAK || result === RETURN)return result;
	  } else for(iterator = iterFn.call(iterable); !(step = iterator.next()).done; ){
	    result = call(iterator, f, step.value, entries);
	    if(result === BREAK || result === RETURN)return result;
	  }
	};
	exports.BREAK  = BREAK;
	exports.RETURN = RETURN;

/***/ },
/* 340 */
/***/ function(module, exports, __webpack_require__) {

	// call something on iterator step with safe closing on error
	var anObject = __webpack_require__(297);
	module.exports = function(iterator, fn, value, entries){
	  try {
	    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
	  // 7.4.6 IteratorClose(iterator, completion)
	  } catch(e){
	    var ret = iterator['return'];
	    if(ret !== undefined)anObject(ret.call(iterator));
	    throw e;
	  }
	};

/***/ },
/* 341 */
/***/ function(module, exports, __webpack_require__) {

	// check on default Array iterator
	var Iterators  = __webpack_require__(316)
	  , ITERATOR   = __webpack_require__(290)('iterator')
	  , ArrayProto = Array.prototype;

	module.exports = function(it){
	  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
	};

/***/ },
/* 342 */
/***/ function(module, exports, __webpack_require__) {

	var classof   = __webpack_require__(288)
	  , ITERATOR  = __webpack_require__(290)('iterator')
	  , Iterators = __webpack_require__(316);
	module.exports = __webpack_require__(306).getIteratorMethod = function(it){
	  if(it != undefined)return it[ITERATOR]
	    || it['@@iterator']
	    || Iterators[classof(it)];
	};

/***/ },
/* 343 */
/***/ function(module, exports, __webpack_require__) {

	// 7.3.20 SpeciesConstructor(O, defaultConstructor)
	var anObject  = __webpack_require__(297)
	  , aFunction = __webpack_require__(315)
	  , SPECIES   = __webpack_require__(290)('species');
	module.exports = function(O, D){
	  var C = anObject(O).constructor, S;
	  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
	};

/***/ },
/* 344 */
/***/ function(module, exports, __webpack_require__) {

	var ctx                = __webpack_require__(314)
	  , invoke             = __webpack_require__(345)
	  , html               = __webpack_require__(329)
	  , cel                = __webpack_require__(302)
	  , global             = __webpack_require__(292)
	  , process            = global.process
	  , setTask            = global.setImmediate
	  , clearTask          = global.clearImmediate
	  , MessageChannel     = global.MessageChannel
	  , counter            = 0
	  , queue              = {}
	  , ONREADYSTATECHANGE = 'onreadystatechange'
	  , defer, channel, port;
	var run = function(){
	  var id = +this;
	  if(queue.hasOwnProperty(id)){
	    var fn = queue[id];
	    delete queue[id];
	    fn();
	  }
	};
	var listener = function(event){
	  run.call(event.data);
	};
	// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
	if(!setTask || !clearTask){
	  setTask = function setImmediate(fn){
	    var args = [], i = 1;
	    while(arguments.length > i)args.push(arguments[i++]);
	    queue[++counter] = function(){
	      invoke(typeof fn == 'function' ? fn : Function(fn), args);
	    };
	    defer(counter);
	    return counter;
	  };
	  clearTask = function clearImmediate(id){
	    delete queue[id];
	  };
	  // Node.js 0.8-
	  if(__webpack_require__(289)(process) == 'process'){
	    defer = function(id){
	      process.nextTick(ctx(run, id, 1));
	    };
	  // Browsers with MessageChannel, includes WebWorkers
	  } else if(MessageChannel){
	    channel = new MessageChannel;
	    port    = channel.port2;
	    channel.port1.onmessage = listener;
	    defer = ctx(port.postMessage, port, 1);
	  // Browsers with postMessage, skip WebWorkers
	  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
	  } else if(global.addEventListener && typeof postMessage == 'function' && !global.importScripts){
	    defer = function(id){
	      global.postMessage(id + '', '*');
	    };
	    global.addEventListener('message', listener, false);
	  // IE8-
	  } else if(ONREADYSTATECHANGE in cel('script')){
	    defer = function(id){
	      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function(){
	        html.removeChild(this);
	        run.call(id);
	      };
	    };
	  // Rest old browsers
	  } else {
	    defer = function(id){
	      setTimeout(ctx(run, id, 1), 0);
	    };
	  }
	}
	module.exports = {
	  set:   setTask,
	  clear: clearTask
	};

/***/ },
/* 345 */
/***/ function(module, exports) {

	// fast apply, http://jsperf.lnkit.com/fast-apply/5
	module.exports = function(fn, args, that){
	  var un = that === undefined;
	  switch(args.length){
	    case 0: return un ? fn()
	                      : fn.call(that);
	    case 1: return un ? fn(args[0])
	                      : fn.call(that, args[0]);
	    case 2: return un ? fn(args[0], args[1])
	                      : fn.call(that, args[0], args[1]);
	    case 3: return un ? fn(args[0], args[1], args[2])
	                      : fn.call(that, args[0], args[1], args[2]);
	    case 4: return un ? fn(args[0], args[1], args[2], args[3])
	                      : fn.call(that, args[0], args[1], args[2], args[3]);
	  } return              fn.apply(that, args);
	};

/***/ },
/* 346 */
/***/ function(module, exports, __webpack_require__) {

	var global    = __webpack_require__(292)
	  , macrotask = __webpack_require__(344).set
	  , Observer  = global.MutationObserver || global.WebKitMutationObserver
	  , process   = global.process
	  , Promise   = global.Promise
	  , isNode    = __webpack_require__(289)(process) == 'process';

	module.exports = function(){
	  var head, last, notify;

	  var flush = function(){
	    var parent, fn;
	    if(isNode && (parent = process.domain))parent.exit();
	    while(head){
	      fn   = head.fn;
	      head = head.next;
	      try {
	        fn();
	      } catch(e){
	        if(head)notify();
	        else last = undefined;
	        throw e;
	      }
	    } last = undefined;
	    if(parent)parent.enter();
	  };

	  // Node.js
	  if(isNode){
	    notify = function(){
	      process.nextTick(flush);
	    };
	  // browsers with MutationObserver
	  } else if(Observer){
	    var toggle = true
	      , node   = document.createTextNode('');
	    new Observer(flush).observe(node, {characterData: true}); // eslint-disable-line no-new
	    notify = function(){
	      node.data = toggle = !toggle;
	    };
	  // environments with maybe non-completely correct, but existent Promise
	  } else if(Promise && Promise.resolve){
	    var promise = Promise.resolve();
	    notify = function(){
	      promise.then(flush);
	    };
	  // for other environments - macrotask based on:
	  // - setImmediate
	  // - MessageChannel
	  // - window.postMessag
	  // - onreadystatechange
	  // - setTimeout
	  } else {
	    notify = function(){
	      // strange IE + webpack dev server bug - use .call(global)
	      macrotask.call(global, flush);
	    };
	  }

	  return function(fn){
	    var task = {fn: fn, next: undefined};
	    if(last)last.next = task;
	    if(!head){
	      head = task;
	      notify();
	    } last = task;
	  };
	};

/***/ },
/* 347 */
/***/ function(module, exports, __webpack_require__) {

	var redefine = __webpack_require__(294);
	module.exports = function(target, src, safe){
	  for(var key in src)redefine(target, key, src[key], safe);
	  return target;
	};

/***/ },
/* 348 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var global      = __webpack_require__(292)
	  , dP          = __webpack_require__(296)
	  , DESCRIPTORS = __webpack_require__(300)
	  , SPECIES     = __webpack_require__(290)('species');

	module.exports = function(KEY){
	  var C = global[KEY];
	  if(DESCRIPTORS && C && !C[SPECIES])dP.f(C, SPECIES, {
	    configurable: true,
	    get: function(){ return this; }
	  });
	};

/***/ },
/* 349 */
/***/ function(module, exports, __webpack_require__) {

	var ITERATOR     = __webpack_require__(290)('iterator')
	  , SAFE_CLOSING = false;

	try {
	  var riter = [7][ITERATOR]();
	  riter['return'] = function(){ SAFE_CLOSING = true; };
	  Array.from(riter, function(){ throw 2; });
	} catch(e){ /* empty */ }

	module.exports = function(exec, skipClosing){
	  if(!skipClosing && !SAFE_CLOSING)return false;
	  var safe = false;
	  try {
	    var arr  = [7]
	      , iter = arr[ITERATOR]();
	    iter.next = function(){ return {done: safe = true}; };
	    arr[ITERATOR] = function(){ return iter; };
	    exec(arr);
	  } catch(e){ /* empty */ }
	  return safe;
	};

/***/ },
/* 350 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, global) {'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // eslint-disable-line no-unused-vars


	var _errors = __webpack_require__(237);

	var _promise = __webpack_require__(286);

	var _promise2 = _interopRequireDefault(_promise);

	var _regeneratorRuntime = __webpack_require__(148);

	var _regeneratorRuntime2 = _interopRequireDefault(_regeneratorRuntime);

	var _map = __webpack_require__(351);

	var _map2 = _interopRequireDefault(_map);

	var _forEach = __webpack_require__(19);

	var _forEach2 = _interopRequireDefault(_forEach);

	var _isArray = __webpack_require__(35);

	var _isArray2 = _interopRequireDefault(_isArray);

	var _isFunction = __webpack_require__(31);

	var _isFunction2 = _interopRequireDefault(_isFunction);

	var _isString = __webpack_require__(217);

	var _isString2 = _interopRequireDefault(_isString);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new _promise2.default(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return _promise2.default.resolve(value).then(function (value) { return step("next", value); }, function (err) { return step("throw", err); }); } } return step("next"); }); }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var idAttribute = process && process.env && process.env.KINVEY_ID_ATTRIBUTE || undefined || '_id';
	var masterCollectionName = 'sqlite_master';
	var size = 5 * 1000 * 1000; // Database size in bytes
	var dbCache = {};

	var WebSQL = function () {
	  function WebSQL() {
	    var name = arguments.length <= 0 || arguments[0] === undefined ? 'kinvey' : arguments[0];

	    _classCallCheck(this, WebSQL);

	    this.name = name;
	  }

	  _createClass(WebSQL, [{
	    key: 'openDatabase',
	    value: function openDatabase() {
	      var db = dbCache[this.name];

	      if (!db) {
	        db = global.openDatabase(this.name, 1, '', size);
	        dbCache[this.name] = db;
	      }

	      return db;
	    }
	  }, {
	    key: 'openTransaction',
	    value: function openTransaction(collection, query, parameters) {
	      var _this = this;

	      var write = arguments.length <= 3 || arguments[3] === undefined ? false : arguments[3];

	      var db = this.openDatabase();
	      var escapedCollection = '"' + collection + '"';
	      var isMaster = collection === masterCollectionName;
	      var isMulti = (0, _isArray2.default)(query);
	      query = isMulti ? query : [[query, parameters]];

	      var promise = new _promise2.default(function (resolve, reject) {
	        var writeTxn = write || !(0, _isFunction2.default)(db.readTransaction);
	        db[writeTxn ? 'transaction' : 'readTransaction'](function (tx) {
	          if (write && !isMaster) {
	            tx.executeSql('CREATE TABLE IF NOT EXISTS ' + escapedCollection + ' ' + '(key BLOB PRIMARY KEY NOT NULL, value BLOB NOT NULL)');
	          }

	          var pending = query.length;
	          var responses = [];

	          if (pending === 0) {
	            resolve(isMulti ? responses : responses.shift());
	          } else {
	            (0, _forEach2.default)(query, function (parts) {
	              var sql = parts[0].replace('#{collection}', escapedCollection);

	              tx.executeSql(sql, parts[1], function (_, resultSet) {
	                var response = {
	                  rowCount: resultSet.rowsAffected,
	                  result: []
	                };

	                if (resultSet.rows.length) {
	                  for (var i = 0, len = resultSet.rows.length; i < len; i += 1) {
	                    try {
	                      var value = resultSet.rows.item(i).value;
	                      var entity = isMaster ? value : JSON.parse(value);
	                      response.result.push(entity);
	                    } catch (error) {
	                      // Catch the error
	                    }
	                  }
	                }

	                responses.push(response);
	                pending -= 1;

	                if (pending === 0) {
	                  resolve(isMulti ? responses : responses.shift());
	                }
	              });
	            });
	          }
	        }, function (error) {
	          error = (0, _isString2.default)(error) ? error : error.message;

	          if (error && error.indexOf('no such table') === -1) {
	            return reject(new _errors.NotFoundError('The ' + collection + ' collection was not found on' + (' the ' + _this.name + ' WebSQL database.')));
	          }

	          var query = 'SELECT name AS value from #{collection} WHERE type = ? AND name = ?';
	          var parameters = ['table', collection];

	          return _this.openTransaction(masterCollectionName, query, parameters).then(function (response) {
	            if (response.result.length === 0) {
	              return reject(new _errors.NotFoundError('The ' + collection + ' collection was not found on' + (' the ' + _this.name + ' WebSQL database.')));
	            }

	            return reject(new Error('Unable to open a transaction for the ' + collection + (' collection on the ' + _this.name + ' WebSQL database.')));
	          }).catch(function (error) {
	            reject(new Error('Unable to open a transaction for the ' + collection + (' collection on the ' + _this.name + ' WebSQL database.'), error));
	          });
	        });
	      });

	      return promise;
	    }
	  }, {
	    key: 'find',
	    value: function () {
	      var _ref = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee(collection) {
	        var sql, response;
	        return _regeneratorRuntime2.default.wrap(function _callee$(_context) {
	          while (1) {
	            switch (_context.prev = _context.next) {
	              case 0:
	                sql = 'SELECT value FROM #{collection}';
	                _context.next = 3;
	                return this.openTransaction(collection, sql, []);

	              case 3:
	                response = _context.sent;
	                return _context.abrupt('return', response.result);

	              case 5:
	              case 'end':
	                return _context.stop();
	            }
	          }
	        }, _callee, this);
	      }));

	      function find(_x3) {
	        return _ref.apply(this, arguments);
	      }

	      return find;
	    }()
	  }, {
	    key: 'findById',
	    value: function () {
	      var _ref2 = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee2(collection, id) {
	        var sql, response, entities;
	        return _regeneratorRuntime2.default.wrap(function _callee2$(_context2) {
	          while (1) {
	            switch (_context2.prev = _context2.next) {
	              case 0:
	                sql = 'SELECT value FROM #{collection} WHERE key = ?';
	                _context2.next = 3;
	                return this.openTransaction(collection, sql, [id]);

	              case 3:
	                response = _context2.sent;
	                entities = response.result;

	                if (!(entities.length === 0)) {
	                  _context2.next = 7;
	                  break;
	                }

	                throw new _errors.NotFoundError('An entity with _id = ' + id + ' was not found in the ' + collection + (' collection on the ' + this.name + ' WebSQL database.'));

	              case 7:
	                return _context2.abrupt('return', entities[0]);

	              case 8:
	              case 'end':
	                return _context2.stop();
	            }
	          }
	        }, _callee2, this);
	      }));

	      function findById(_x4, _x5) {
	        return _ref2.apply(this, arguments);
	      }

	      return findById;
	    }()
	  }, {
	    key: 'save',
	    value: function () {
	      var _ref3 = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee3(collection, entities) {
	        var queries;
	        return _regeneratorRuntime2.default.wrap(function _callee3$(_context3) {
	          while (1) {
	            switch (_context3.prev = _context3.next) {
	              case 0:
	                queries = [];

	                entities = (0, _map2.default)(entities, function (entity) {
	                  queries.push(['REPLACE INTO #{collection} (key, value) VALUES (?, ?)', [entity[idAttribute], JSON.stringify(entity)]]);

	                  return entity;
	                });

	                _context3.next = 4;
	                return this.openTransaction(collection, queries, null, true);

	              case 4:
	                return _context3.abrupt('return', entities);

	              case 5:
	              case 'end':
	                return _context3.stop();
	            }
	          }
	        }, _callee3, this);
	      }));

	      function save(_x6, _x7) {
	        return _ref3.apply(this, arguments);
	      }

	      return save;
	    }()
	  }, {
	    key: 'removeById',
	    value: function () {
	      var _ref4 = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee4(collection, id) {
	        var queries, response, entities, count;
	        return _regeneratorRuntime2.default.wrap(function _callee4$(_context4) {
	          while (1) {
	            switch (_context4.prev = _context4.next) {
	              case 0:
	                queries = [['SELECT value FROM #{collection} WHERE key = ?', [id]], ['DELETE FROM #{collection} WHERE key = ?', [id]]];
	                _context4.next = 3;
	                return this.openTransaction(collection, queries, null, true);

	              case 3:
	                response = _context4.sent;
	                entities = response[0].result;
	                count = response[1].rowCount;

	                count = count || entities.length;

	                if (!(count === 0)) {
	                  _context4.next = 9;
	                  break;
	                }

	                throw new _errors.NotFoundError('An entity with _id = ' + id + ' was not found in the ' + collection + (' collection on the ' + this.name + ' WebSQL database.'));

	              case 9:
	                return _context4.abrupt('return', entities[0]);

	              case 10:
	              case 'end':
	                return _context4.stop();
	            }
	          }
	        }, _callee4, this);
	      }));

	      function removeById(_x8, _x9) {
	        return _ref4.apply(this, arguments);
	      }

	      return removeById;
	    }()
	  }, {
	    key: 'clear',
	    value: function () {
	      var _ref5 = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee5() {
	        var response, tables, queries;
	        return _regeneratorRuntime2.default.wrap(function _callee5$(_context5) {
	          while (1) {
	            switch (_context5.prev = _context5.next) {
	              case 0:
	                _context5.next = 2;
	                return this.openTransaction(masterCollectionName, 'SELECT name AS value FROM #{collection} WHERE type = ?', ['table'], false);

	              case 2:
	                response = _context5.sent;
	                tables = response.result;

	                // If there are no tables, return.

	                if (!(tables.length === 0)) {
	                  _context5.next = 6;
	                  break;
	                }

	                return _context5.abrupt('return', null);

	              case 6:

	                // Drop all tables. Filter tables first to avoid attempting to delete
	                // system tables (which will fail).
	                queries = tables.filter(function (table) {
	                  return (/^[a-zA-Z0-9\-]{1,128}/.test(table)
	                  );
	                }).map(function (table) {
	                  return ['DROP TABLE IF EXISTS \'' + table + '\''];
	                });
	                _context5.next = 9;
	                return this.openTransaction(masterCollectionName, queries, null, true);

	              case 9:
	                dbCache = {};
	                return _context5.abrupt('return', null);

	              case 11:
	              case 'end':
	                return _context5.stop();
	            }
	          }
	        }, _callee5, this);
	      }));

	      function clear() {
	        return _ref5.apply(this, arguments);
	      }

	      return clear;
	    }()
	  }], [{
	    key: 'isSupported',
	    value: function isSupported() {
	      return !!global.openDatabase;
	    }
	  }]);

	  return WebSQL;
	}();

	exports.default = WebSQL;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4), (function() { return this; }())))

/***/ },
/* 351 */
/***/ function(module, exports, __webpack_require__) {

	var arrayMap = __webpack_require__(281),
	    baseIteratee = __webpack_require__(42),
	    baseMap = __webpack_require__(352),
	    isArray = __webpack_require__(35);

	/**
	 * Creates an array of values by running each element in `collection` thru
	 * `iteratee`. The iteratee is invoked with three arguments:
	 * (value, index|key, collection).
	 *
	 * Many lodash methods are guarded to work as iteratees for methods like
	 * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
	 *
	 * The guarded methods are:
	 * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
	 * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
	 * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
	 * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Collection
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	 * @returns {Array} Returns the new mapped array.
	 * @example
	 *
	 * function square(n) {
	 *   return n * n;
	 * }
	 *
	 * _.map([4, 8], square);
	 * // => [16, 64]
	 *
	 * _.map({ 'a': 4, 'b': 8 }, square);
	 * // => [16, 64] (iteration order is not guaranteed)
	 *
	 * var users = [
	 *   { 'user': 'barney' },
	 *   { 'user': 'fred' }
	 * ];
	 *
	 * // The `_.property` iteratee shorthand.
	 * _.map(users, 'user');
	 * // => ['barney', 'fred']
	 */
	function map(collection, iteratee) {
	  var func = isArray(collection) ? arrayMap : baseMap;
	  return func(collection, baseIteratee(iteratee, 3));
	}

	module.exports = map;


/***/ },
/* 352 */
/***/ function(module, exports, __webpack_require__) {

	var baseEach = __webpack_require__(21),
	    isArrayLike = __webpack_require__(30);

	/**
	 * The base implementation of `_.map` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the new mapped array.
	 */
	function baseMap(collection, iteratee) {
	  var index = -1,
	      result = isArrayLike(collection) ? Array(collection.length) : [];

	  baseEach(collection, function(value, key, collection) {
	    result[++index] = iteratee(value, key, collection);
	  });
	  return result;
	}

	module.exports = baseMap;


/***/ },
/* 353 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process) {'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // eslint-disable-line no-unused-vars


	var _errors = __webpack_require__(237);

	var _regeneratorRuntime = __webpack_require__(148);

	var _regeneratorRuntime2 = _interopRequireDefault(_regeneratorRuntime);

	var _map = __webpack_require__(351);

	var _map2 = _interopRequireDefault(_map);

	var _isArray = __webpack_require__(35);

	var _isArray2 = _interopRequireDefault(_isArray);

	var _isFunction = __webpack_require__(31);

	var _isFunction2 = _interopRequireDefault(_isFunction);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { return step("next", value); }, function (err) { return step("throw", err); }); } } return step("next"); }); }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var Titanium = global.Titanium;
	var idAttribute = process && process.env && process.env.KINVEY_ID_ATTRIBUTE || undefined || '_id';

	var TitaniumDB = function () {
	  function TitaniumDB() {
	    var name = arguments.length <= 0 || arguments[0] === undefined ? 'kinvey' : arguments[0];

	    _classCallCheck(this, TitaniumDB);

	    this.name = name;
	  }

	  _createClass(TitaniumDB, [{
	    key: 'execute',
	    value: function () {
	      var _ref = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee(collection, query, parameters) {
	        var _this = this;

	        var escapedCollection, isMulti, response;
	        return _regeneratorRuntime2.default.wrap(function _callee$(_context) {
	          while (1) {
	            switch (_context.prev = _context.next) {
	              case 0:
	                escapedCollection = '"' + collection + '"';
	                isMulti = (0, _isArray2.default)(query);

	                query = isMulti ? query : [[query, parameters]];

	                _context.prev = 3;

	                if (!this.db) {
	                  this.db = Titanium.Database.open(this.name);
	                }

	                // Start a transaction
	                this.db.execute('BEGIN TRANSACTION');

	                // Create the table if it does not exist yet
	                this.db.execute('CREATE TABLE IF NOT EXISTS ' + escapedCollection + ' ' + '(key BLOB PRIMARY KEY NOT NULL, value BLOB NOT NULL)');

	                // Execute queries
	                response = (0, _map2.default)(query, function (parts) {
	                  var sql = parts[0].replace('#{collection}', escapedCollection);
	                  var cursor = _this.db.execute(sql, parts[1]);
	                  var response = { rowCount: _this.db.getRowsAffected(), result: null };

	                  if (cursor) {
	                    response.result = [];

	                    while (cursor.isValidRow()) {
	                      var entity = JSON.parse(cursor.fieldByName('value'));
	                      response.result.push(entity);
	                      cursor.next();
	                    }

	                    cursor.close();
	                  }

	                  return response;
	                });

	                // Commit the transaction

	                this.db.execute('COMMIT TRANSACTION');

	                return _context.abrupt('return', isMulti ? response : response.shift());

	              case 12:
	                _context.prev = 12;
	                _context.t0 = _context['catch'](3);
	                throw new Error(_context.t0.message);

	              case 15:
	              case 'end':
	                return _context.stop();
	            }
	          }
	        }, _callee, this, [[3, 12]]);
	      }));

	      function execute(_x2, _x3, _x4) {
	        return _ref.apply(this, arguments);
	      }

	      return execute;
	    }()
	  }, {
	    key: 'find',
	    value: function find(collection) {
	      var sql = 'SELECT value FROM #{collection}';
	      var promise = this.execute(collection, sql, []).then(function (response) {
	        return response.result;
	      }).catch(function (error) {
	        if (error instanceof _errors.NotFoundError) {
	          return [];
	        }

	        throw error;
	      });
	      return promise;
	    }
	  }, {
	    key: 'findById',
	    value: function findById(collection, id) {
	      var _this2 = this;

	      var sql = 'SELECT value FROM #{collection} WHERE key = ?';
	      var promise = this.execute(collection, sql, [id]).then(function (response) {
	        var entities = response.result;

	        if (entities.length === 0) {
	          throw new _errors.NotFoundError('An entity with _id = ' + id + ' was not found in the ' + collection + ' ' + ('collection on the ' + _this2.name + ' webSQL database.'));
	        }

	        return entities[0];
	      });
	      return promise;
	    }
	  }, {
	    key: 'save',
	    value: function save(collection, entities) {
	      var queries = [];
	      entities = (0, _map2.default)(entities, function (entity) {
	        queries.push(['INSERT OR REPLACE INTO #{collection} (key, value) VALUES (?, ?)', [entity[idAttribute], JSON.stringify(entity)]]);

	        return entity;
	      });

	      var promise = this.execute(collection, queries, null).then(function () {
	        return entities;
	      });
	      return promise;
	    }
	  }, {
	    key: 'removeById',
	    value: function removeById(collection, id) {
	      var _this3 = this;

	      var promise = this.execute(collection, [['SELECT value FROM #{collection} WHERE key = ?', [id]], ['DELETE FROM #{collection} WHERE key = ?', [id]]], null).then(function (response) {
	        var entities = response[0].result;
	        var count = response[1].rowCount || entities.length;

	        if (count === 0) {
	          throw new _errors.NotFoundError('An entity with _id = ' + id + ' was not found in the ' + collection + ' ' + ('collection on the ' + _this3.name + ' webSQL database.'));
	        }

	        return {
	          count: 1,
	          entities: entities
	        };
	      });

	      return promise;
	    }
	  }, {
	    key: 'clear',
	    value: function () {
	      var _ref2 = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee2() {
	        return _regeneratorRuntime2.default.wrap(function _callee2$(_context2) {
	          while (1) {
	            switch (_context2.prev = _context2.next) {
	              case 0:
	                if (!this.db) {
	                  this.db = Titanium.Database.open(this.name);
	                }

	                if (!(0, _isFunction2.default)(this.db.remove)) {
	                  _context2.next = 4;
	                  break;
	                }

	                // Android
	                this.db.remove();
	                return _context2.abrupt('return', null);

	              case 4:
	                if (!(this.db.file && this.db.file.deleteFile())) {
	                  _context2.next = 6;
	                  break;
	                }

	                return _context2.abrupt('return', null);

	              case 6:
	                throw new Error('The mechanism to delete the database is not implemented for this platform.');

	              case 7:
	              case 'end':
	                return _context2.stop();
	            }
	          }
	        }, _callee2, this);
	      }));

	      function clear() {
	        return _ref2.apply(this, arguments);
	      }

	      return clear;
	    }()
	  }], [{
	    key: 'isSupported',
	    value: function isSupported() {
	      return typeof Titanium !== 'undefined' && typeof Titanium.Database !== 'undefined';
	    }
	  }]);

	  return TitaniumDB;
	}();

	exports.default = TitaniumDB;
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(4)))

/***/ },
/* 354 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // eslint-disable-line no-unused-vars


	var _fastMemoryCache = __webpack_require__(355);

	var _fastMemoryCache2 = _interopRequireDefault(_fastMemoryCache);

	var _regeneratorRuntime = __webpack_require__(148);

	var _regeneratorRuntime2 = _interopRequireDefault(_regeneratorRuntime);

	var _keyBy = __webpack_require__(243);

	var _keyBy2 = _interopRequireDefault(_keyBy);

	var _forEach = __webpack_require__(19);

	var _forEach2 = _interopRequireDefault(_forEach);

	var _values = __webpack_require__(279);

	var _values2 = _interopRequireDefault(_values);

	var _find = __webpack_require__(283);

	var _find2 = _interopRequireDefault(_find);

	var _errors = __webpack_require__(237);

	var _isString = __webpack_require__(217);

	var _isString2 = _interopRequireDefault(_isString);

	var _isArray = __webpack_require__(35);

	var _isArray2 = _interopRequireDefault(_isArray);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { return step("next", value); }, function (err) { return step("throw", err); }); } } return step("next"); }); }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var idAttribute = process && process.env && process.env.KINVEY_ID_ATTRIBUTE || undefined || '_id';
	var caches = {};

	var Memory = function () {
	  function Memory(name) {
	    _classCallCheck(this, Memory);

	    if (!name) {
	      throw new Error('A name for the collection is required to use the memory persistence adapter.', name);
	    }

	    if (!(0, _isString2.default)(name)) {
	      throw new Error('The name of the collection must be a string to use the memory persistence adapter', name);
	    }

	    this.name = name;
	    this.cache = caches[name];

	    if (!this.cache) {
	      this.cache = new _fastMemoryCache2.default();
	      caches[name] = this.cache;
	    }
	  }

	  _createClass(Memory, [{
	    key: 'find',
	    value: function () {
	      var _ref = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee(collection) {
	        var entities;
	        return _regeneratorRuntime2.default.wrap(function _callee$(_context) {
	          while (1) {
	            switch (_context.prev = _context.next) {
	              case 0:
	                entities = this.cache.get(collection);

	                if (!entities) {
	                  _context.next = 3;
	                  break;
	                }

	                return _context.abrupt('return', JSON.parse(entities));

	              case 3:
	                return _context.abrupt('return', []);

	              case 4:
	              case 'end':
	                return _context.stop();
	            }
	          }
	        }, _callee, this);
	      }));

	      function find(_x) {
	        return _ref.apply(this, arguments);
	      }

	      return find;
	    }()
	  }, {
	    key: 'findById',
	    value: function () {
	      var _ref2 = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee2(collection, id) {
	        var entities, entity;
	        return _regeneratorRuntime2.default.wrap(function _callee2$(_context2) {
	          while (1) {
	            switch (_context2.prev = _context2.next) {
	              case 0:
	                _context2.next = 2;
	                return this.find(collection);

	              case 2:
	                entities = _context2.sent;
	                entity = (0, _find2.default)(entities, function (entity) {
	                  return entity[idAttribute] === id;
	                });

	                if (entity) {
	                  _context2.next = 6;
	                  break;
	                }

	                throw new _errors.NotFoundError('An entity with _id = ' + id + ' was not found in the ' + collection + (' collection on the ' + this.name + ' memory database.'));

	              case 6:
	                return _context2.abrupt('return', entity);

	              case 7:
	              case 'end':
	                return _context2.stop();
	            }
	          }
	        }, _callee2, this);
	      }));

	      function findById(_x2, _x3) {
	        return _ref2.apply(this, arguments);
	      }

	      return findById;
	    }()
	  }, {
	    key: 'save',
	    value: function () {
	      var _ref3 = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee3(collection, entities) {
	        var singular, existingEntities, entityIds;
	        return _regeneratorRuntime2.default.wrap(function _callee3$(_context3) {
	          while (1) {
	            switch (_context3.prev = _context3.next) {
	              case 0:
	                singular = false;


	                if (!(0, _isArray2.default)(entities)) {
	                  entities = [entities];
	                  singular = true;
	                }

	                if (!(entities.length === 0)) {
	                  _context3.next = 4;
	                  break;
	                }

	                return _context3.abrupt('return', entities);

	              case 4:
	                _context3.next = 6;
	                return this.find(collection);

	              case 6:
	                existingEntities = _context3.sent;

	                existingEntities = (0, _keyBy2.default)(existingEntities, idAttribute);
	                entities = (0, _keyBy2.default)(entities, idAttribute);
	                entityIds = Object.keys(entities);


	                (0, _forEach2.default)(entityIds, function (id) {
	                  existingEntities[id] = entities[id];
	                });

	                this.cache.set(collection, JSON.stringify((0, _values2.default)(existingEntities)));

	                entities = (0, _values2.default)(entities);
	                return _context3.abrupt('return', singular ? entities[0] : entities);

	              case 14:
	              case 'end':
	                return _context3.stop();
	            }
	          }
	        }, _callee3, this);
	      }));

	      function save(_x4, _x5) {
	        return _ref3.apply(this, arguments);
	      }

	      return save;
	    }()
	  }, {
	    key: 'removeById',
	    value: function () {
	      var _ref4 = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee4(collection, id) {
	        var entities, entity;
	        return _regeneratorRuntime2.default.wrap(function _callee4$(_context4) {
	          while (1) {
	            switch (_context4.prev = _context4.next) {
	              case 0:
	                _context4.next = 2;
	                return this.find(collection);

	              case 2:
	                entities = _context4.sent;

	                entities = (0, _keyBy2.default)(entities, idAttribute);
	                entity = entities[id];

	                if (entity) {
	                  _context4.next = 7;
	                  break;
	                }

	                throw new _errors.NotFoundError('An entity with _id = ' + id + ' was not found in the ' + collection + (' collection on the ' + this.name + ' memory database.'));

	              case 7:

	                delete entities[id];
	                this.cache.set(collection, JSON.stringify((0, _values2.default)(entities)));

	                return _context4.abrupt('return', entity);

	              case 10:
	              case 'end':
	                return _context4.stop();
	            }
	          }
	        }, _callee4, this);
	      }));

	      function removeById(_x6, _x7) {
	        return _ref4.apply(this, arguments);
	      }

	      return removeById;
	    }()
	  }, {
	    key: 'clear',
	    value: function () {
	      var _ref5 = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee5() {
	        return _regeneratorRuntime2.default.wrap(function _callee5$(_context5) {
	          while (1) {
	            switch (_context5.prev = _context5.next) {
	              case 0:
	                this.cache.clear();
	                return _context5.abrupt('return', null);

	              case 2:
	              case 'end':
	                return _context5.stop();
	            }
	          }
	        }, _callee5, this);
	      }));

	      function clear() {
	        return _ref5.apply(this, arguments);
	      }

	      return clear;
	    }()
	  }], [{
	    key: 'isSupported',
	    value: function isSupported() {
	      return true;
	    }
	  }]);

	  return Memory;
	}();

	exports.default = Memory;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 355 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * Provides in-memory cache.
	 *
	 * @name MemoryCache
	 * @constructor
	 */
	function MemoryCache() {
	    this._cache = createMap();
	    this._timeouts = createMap();
	}

	/**
	 * Returns cache value for the specified key.
	 *
	 * @param {String} key
	 * @returns {*} Value or `undefined` if value does not exist.
	 */
	MemoryCache.prototype.get = function (key) {
	    return this._cache[key];
	};

	/**
	 * Assigns value for the specified key.
	 *
	 * @param {String} key
	 * @param {*} value
	 * @param {Number} [expireTime=0] The length of time in seconds. After this time has expired, the
	 *      value will be automatically deleted. 0 means that time never expire.
	 */
	MemoryCache.prototype.set = function (key, value, expireTime) {
	    this.delete(key);
	    this._cache[key] = value;
	    if (expireTime) {
	        this._timeouts[key] = setTimeout(this.delete.bind(this, key), expireTime * 1000);
	    }
	};

	/**
	 * Deletes value for the specified key.
	 *
	 * @param {String} key
	 */
	MemoryCache.prototype.delete = function (key) {
	    delete this._cache[key];
	    if (key in this._timeouts) {
	        clearTimeout(this._timeouts[key]);
	        delete this._timeouts[key];
	    }
	};

	/**
	 * Clears the whole cache storage.
	 */
	MemoryCache.prototype.clear = function () {
	    this._cache = createMap();
	    for (var key in this._timeouts) {
	        clearTimeout(this._timeouts[key]);
	    }
	    this._timeouts = createMap();
	};

	/**
	 * Creates a new object without a prototype. This object is useful for lookup without having to
	 * guard against prototypically inherited properties via hasOwnProperty.
	 *
	 * @returns {Object}
	 */
	function createMap() {
	    return Object.create(null);
	}

	module.exports = MemoryCache;


/***/ },
/* 356 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {module.exports = process.env.PROMISE_QUEUE_COVERAGE ?
	    __webpack_require__(357) :
	    __webpack_require__(358);

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 357 */
/***/ function(module, exports) {

	

/***/ },
/* 358 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/* global define, Promise */
	(function (root, factory) {
	    'use strict';
	    if (typeof module === 'object' && module.exports && "function" === 'function') {
	        // CommonJS
	        module.exports = factory();
	    } else if (true) {
	        // AMD. Register as an anonymous module.
	        !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else {
	        // Browser globals
	        root.Queue = factory();
	    }
	})
	(this, function () {
	    'use strict';

	    /**
	     * @return {Object}
	     */
	    var LocalPromise = typeof Promise !== 'undefined' ? Promise : function () {
	        return {
	            then: function () {
	                throw new Error('Queue.configure() before use Queue');
	            }
	        };
	    };

	    var noop = function () {};

	    /**
	     * @param {*} value
	     * @returns {LocalPromise}
	     */
	    var resolveWith = function (value) {
	        if (value && typeof value.then === 'function') {
	            return value;
	        }

	        return new LocalPromise(function (resolve) {
	            resolve(value);
	        });
	    };

	    /**
	     * It limits concurrently executed promises
	     *
	     * @param {Number} [maxPendingPromises=Infinity] max number of concurrently executed promises
	     * @param {Number} [maxQueuedPromises=Infinity]  max number of queued promises
	     * @constructor
	     *
	     * @example
	     *
	     * var queue = new Queue(1);
	     *
	     * queue.add(function () {
	     *     // resolve of this promise will resume next request
	     *     return downloadTarballFromGithub(url, file);
	     * })
	     * .then(function (file) {
	     *     doStuffWith(file);
	     * });
	     *
	     * queue.add(function () {
	     *     return downloadTarballFromGithub(url, file);
	     * })
	     * // This request will be paused
	     * .then(function (file) {
	     *     doStuffWith(file);
	     * });
	     */
	    function Queue(maxPendingPromises, maxQueuedPromises) {
	        this.pendingPromises = 0;
	        this.maxPendingPromises = typeof maxPendingPromises !== 'undefined' ? maxPendingPromises : Infinity;
	        this.maxQueuedPromises = typeof maxQueuedPromises !== 'undefined' ? maxQueuedPromises : Infinity;
	        this.queue = [];
	    }

	    /**
	     * Defines promise promiseFactory
	     * @param {Function} GlobalPromise
	     */
	    Queue.configure = function (GlobalPromise) {
	        LocalPromise = GlobalPromise;
	    };

	    /**
	     * @param {Function} promiseGenerator
	     * @return {LocalPromise}
	     */
	    Queue.prototype.add = function (promiseGenerator) {
	        var self = this;
	        return new LocalPromise(function (resolve, reject, notify) {
	            // Do not queue to much promises
	            if (self.queue.length >= self.maxQueuedPromises) {
	                reject(new Error('Queue limit reached'));
	                return;
	            }

	            // Add to queue
	            self.queue.push({
	                promiseGenerator: promiseGenerator,
	                resolve: resolve,
	                reject: reject,
	                notify: notify || noop
	            });

	            self._dequeue();
	        });
	    };

	    /**
	     * Number of simultaneously running promises (which are resolving)
	     *
	     * @return {number}
	     */
	    Queue.prototype.getPendingLength = function () {
	        return this.pendingPromises;
	    };

	    /**
	     * Number of queued promises (which are waiting)
	     *
	     * @return {number}
	     */
	    Queue.prototype.getQueueLength = function () {
	        return this.queue.length;
	    };

	    /**
	     * @returns {boolean} true if first item removed from queue
	     * @private
	     */
	    Queue.prototype._dequeue = function () {
	        var self = this;
	        if (this.pendingPromises >= this.maxPendingPromises) {
	            return false;
	        }

	        // Remove from queue
	        var item = this.queue.shift();
	        if (!item) {
	            return false;
	        }

	        try {
	            this.pendingPromises++;

	            resolveWith(item.promiseGenerator())
	            // Forward all stuff
	                .then(function (value) {
	                    // It is not pending now
	                    self.pendingPromises--;
	                    // It should pass values
	                    item.resolve(value);
	                    self._dequeue();
	                }, function (err) {
	                    // It is not pending now
	                    self.pendingPromises--;
	                    // It should not mask errors
	                    item.reject(err);
	                    self._dequeue();
	                }, function (message) {
	                    // It should pass notifications
	                    item.notify(message);
	                });
	        } catch (err) {
	            self.pendingPromises--;
	            item.reject(err);
	            self._dequeue();

	        }

	        return true;
	    };

	    return Queue;
	});


/***/ },
/* 359 */
/***/ function(module, exports, __webpack_require__) {

	var getTag = __webpack_require__(97),
	    isArguments = __webpack_require__(28),
	    isArray = __webpack_require__(35),
	    isArrayLike = __webpack_require__(30),
	    isBuffer = __webpack_require__(275),
	    isPrototype = __webpack_require__(38),
	    nativeKeys = __webpack_require__(39);

	/** `Object#toString` result references. */
	var mapTag = '[object Map]',
	    setTag = '[object Set]';

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Checks if `value` is an empty object, collection, map, or set.
	 *
	 * Objects are considered empty if they have no own enumerable string keyed
	 * properties.
	 *
	 * Array-like values such as `arguments` objects, arrays, buffers, strings, or
	 * jQuery-like collections are considered empty if they have a `length` of `0`.
	 * Similarly, maps and sets are considered empty if they have a `size` of `0`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is empty, else `false`.
	 * @example
	 *
	 * _.isEmpty(null);
	 * // => true
	 *
	 * _.isEmpty(true);
	 * // => true
	 *
	 * _.isEmpty(1);
	 * // => true
	 *
	 * _.isEmpty([1, 2, 3]);
	 * // => false
	 *
	 * _.isEmpty({ 'a': 1 });
	 * // => false
	 */
	function isEmpty(value) {
	  if (isArrayLike(value) &&
	      (isArray(value) || typeof value == 'string' ||
	        typeof value.splice == 'function' || isBuffer(value) || isArguments(value))) {
	    return !value.length;
	  }
	  var tag = getTag(value);
	  if (tag == mapTag || tag == setTag) {
	    return !value.size;
	  }
	  if (isPrototype(value)) {
	    return !nativeKeys(value).length;
	  }
	  for (var key in value) {
	    if (hasOwnProperty.call(value, key)) {
	      return false;
	    }
	  }
	  return true;
	}

	module.exports = isEmpty;


/***/ },
/* 360 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _middleware = __webpack_require__(239);

	var _middleware2 = _interopRequireDefault(_middleware);

	var _network = __webpack_require__(361);

	var _network2 = _interopRequireDefault(_network);

	var _regeneratorRuntime = __webpack_require__(148);

	var _regeneratorRuntime2 = _interopRequireDefault(_regeneratorRuntime);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { return step("next", value); }, function (err) { return step("throw", err); }); } } return step("next"); }); }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	// eslint-disable-line no-unused-vars

	var HttpMiddleware = function (_Middleware) {
	  _inherits(HttpMiddleware, _Middleware);

	  function HttpMiddleware() {
	    var name = arguments.length <= 0 || arguments[0] === undefined ? 'Http Middleware' : arguments[0];

	    _classCallCheck(this, HttpMiddleware);

	    return _possibleConstructorReturn(this, (HttpMiddleware.__proto__ || Object.getPrototypeOf(HttpMiddleware)).call(this, name));
	  }

	  _createClass(HttpMiddleware, [{
	    key: 'handle',
	    value: function () {
	      var _ref = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee(request, response) {
	        var http;
	        return _regeneratorRuntime2.default.wrap(function _callee$(_context) {
	          while (1) {
	            switch (_context.prev = _context.next) {
	              case 0:
	                http = new _network2.default();
	                return _context.abrupt('return', http.handle(request, response));

	              case 2:
	              case 'end':
	                return _context.stop();
	            }
	          }
	        }, _callee, this);
	      }));

	      function handle(_x2, _x3) {
	        return _ref.apply(this, arguments);
	      }

	      return handle;
	    }()
	  }]);

	  return HttpMiddleware;
	}(_middleware2.default);

	exports.default = HttpMiddleware;

/***/ },
/* 361 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // eslint-disable-line no-unused-vars


	var _$http = __webpack_require__(362);

	var _node = __webpack_require__(363);

	var _titanium = __webpack_require__(395);

	var _xhr = __webpack_require__(400);

	var _regeneratorRuntime = __webpack_require__(148);

	var _regeneratorRuntime2 = _interopRequireDefault(_regeneratorRuntime);

	var _isArray = __webpack_require__(35);

	var _isArray2 = _interopRequireDefault(_isArray);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { return step("next", value); }, function (err) { return step("throw", err); }); } } return step("next"); }); }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * Enum for Http Adapters.
	 */
	var HttpAdapter = {
	  $Http: '$Http',
	  Node: 'Node',
	  Titanium: 'Titanium',
	  XHR: 'XHR'
	};
	Object.freeze(HttpAdapter);

	var Http = function () {
	  function Http() {
	    var _this = this;

	    var adapters = arguments.length <= 0 || arguments[0] === undefined ? [HttpAdapter.Titanium, HttpAdapter.$Http, HttpAdapter.Node, HttpAdapter.XHR] : arguments[0];

	    _classCallCheck(this, Http);

	    if (!(0, _isArray2.default)(adapters)) {
	      adapters = [adapters];
	    }

	    adapters.some(function (adapter) {
	      switch (adapter) {
	        case HttpAdapter.$Http:
	          if (_$http.$Http.isSupported()) {
	            _this.adapter = new _$http.$Http();
	            return true;
	          }

	          break;
	        case HttpAdapter.Node:
	          if (_node.NodeHttp.isSupported()) {
	            _this.adapter = new _node.NodeHttp();
	            return true;
	          }

	          break;
	        case HttpAdapter.TitaniumHttp:
	          if (_titanium.TitaniumHttp.isSupported()) {
	            _this.adapter = new _titanium.TitaniumHttp();
	            return true;
	          }

	          break;
	        case HttpAdapter.XHR:
	          if (_xhr.XHR.isSupported()) {
	            _this.adapter = new _xhr.XHR();
	            return true;
	          }

	          break;
	        default:
	        // Log.warn(`The ${adapter} adapter is is not recognized.`);
	      }

	      return false;
	    });
	  }

	  _createClass(Http, [{
	    key: 'handle',
	    value: function () {
	      var _ref = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee(request, response) {
	        return _regeneratorRuntime2.default.wrap(function _callee$(_context) {
	          while (1) {
	            switch (_context.prev = _context.next) {
	              case 0:
	                if (!this.adapter) {
	                  _context.next = 2;
	                  break;
	                }

	                return _context.abrupt('return', this.adapter.handle(request, response));

	              case 2:
	                throw new Error('Unable to handle the request. An adapter is not specified.');

	              case 3:
	              case 'end':
	                return _context.stop();
	            }
	          }
	        }, _callee, this);
	      }));

	      function handle(_x2, _x3) {
	        return _ref.apply(this, arguments);
	      }

	      return handle;
	    }()
	  }]);

	  return Http;
	}();

	exports.default = Http;

/***/ },
/* 362 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.$Http = undefined;

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _regeneratorRuntime = __webpack_require__(148);

	var _regeneratorRuntime2 = _interopRequireDefault(_regeneratorRuntime);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { return step("next", value); }, function (err) { return step("throw", err); }); } } return step("next"); }); }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	// eslint-disable-line no-unused-vars
	var angular = void 0;
	var $http = void 0;

	if (typeof window !== 'undefined' && typeof global.angular !== 'undefined') {
	  angular = global.angular;
	  var $injector = angular.injector(['ng']);
	  $http = $injector.get('$http');
	}

	var $Http = exports.$Http = function () {
	  function $Http() {
	    _classCallCheck(this, $Http);
	  }

	  _createClass($Http, [{
	    key: 'handle',
	    value: function () {
	      var _ref = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee(request) {
	        var url, method, headers, body, response;
	        return _regeneratorRuntime2.default.wrap(function _callee$(_context) {
	          while (1) {
	            switch (_context.prev = _context.next) {
	              case 0:
	                url = request.url;
	                method = request.method;
	                headers = request.headers;
	                body = request.body;
	                _context.prev = 4;
	                _context.next = 7;
	                return $http({
	                  url: url,
	                  method: method,
	                  headers: headers,
	                  data: body
	                });

	              case 7:
	                response = _context.sent;
	                return _context.abrupt('return', {
	                  response: {
	                    statusCode: response.status,
	                    headers: response.headers(),
	                    data: response.data
	                  }
	                });

	              case 11:
	                _context.prev = 11;
	                _context.t0 = _context['catch'](4);
	                return _context.abrupt('return', {
	                  response: {
	                    statusCode: _context.t0.status,
	                    headers: _context.t0.headers(),
	                    data: _context.t0.data
	                  }
	                });

	              case 14:
	              case 'end':
	                return _context.stop();
	            }
	          }
	        }, _callee, this, [[4, 11]]);
	      }));

	      function handle(_x) {
	        return _ref.apply(this, arguments);
	      }

	      return handle;
	    }()
	  }], [{
	    key: 'isSupported',
	    value: function isSupported() {
	      return !!angular;
	    }
	  }]);

	  return $Http;
	}();
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 363 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.NodeHttp = undefined;

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _promise = __webpack_require__(286);

	var _promise2 = _interopRequireDefault(_promise);

	var _http = __webpack_require__(368);

	var _http2 = _interopRequireDefault(_http);

	var _https = __webpack_require__(394);

	var _https2 = _interopRequireDefault(_https);

	var _url = __webpack_require__(206);

	var _url2 = _interopRequireDefault(_url);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var NodeHttp = exports.NodeHttp = function () {
	  function NodeHttp() {
	    _classCallCheck(this, NodeHttp);
	  }

	  _createClass(NodeHttp, [{
	    key: 'handle',
	    value: function handle(request) {
	      var promise = new _promise2.default(function (resolve, reject) {
	        var method = request.method;
	        var headers = request.headers;
	        var body = request.body;

	        var path = _url2.default.parse(request.url);
	        var adapter = path.protocol === 'https:' ? _https2.default : _http2.default;
	        // let length = 0;

	        // if (body instanceof Buffer) {
	        //   length = body.length;
	        // } else if (body) {
	        //   length = Buffer.byteLength(body);
	        // }
	        // headers['Content-Length'] = length;

	        var httpRequest = adapter.request({
	          host: path.hostname,
	          path: path.pathname + (path.search ? path.search : ''),
	          port: path.port,
	          method: method,
	          headers: headers
	        }, function (response) {
	          var data = [];

	          // Listen for data
	          response.on('data', function (chunk) {
	            data.push(new Buffer(chunk));
	          });

	          // Listen for request completion
	          response.on('end', function () {
	            resolve({
	              response: {
	                statusCode: response.statusCode,
	                headers: response.headers,
	                data: Buffer.concat(data)
	              }
	            });
	          });
	        });

	        // Listen fro request errors
	        httpRequest.on('error', function (error) {
	          reject(error);
	        });

	        // Initiate request
	        httpRequest.write(body);
	        httpRequest.end();
	      });
	      return promise;
	    }
	  }], [{
	    key: 'isSupported',
	    value: function isSupported() {
	      return ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof window === 'undefined';
	    }
	  }]);

	  return NodeHttp;
	}();
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(364).Buffer))

/***/ },
/* 364 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer, global) {/*!
	 * The buffer module from node.js, for the browser.
	 *
	 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
	 * @license  MIT
	 */
	/* eslint-disable no-proto */

	'use strict'

	var base64 = __webpack_require__(365)
	var ieee754 = __webpack_require__(366)
	var isArray = __webpack_require__(367)

	exports.Buffer = Buffer
	exports.SlowBuffer = SlowBuffer
	exports.INSPECT_MAX_BYTES = 50

	/**
	 * If `Buffer.TYPED_ARRAY_SUPPORT`:
	 *   === true    Use Uint8Array implementation (fastest)
	 *   === false   Use Object implementation (most compatible, even IE6)
	 *
	 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
	 * Opera 11.6+, iOS 4.2+.
	 *
	 * Due to various browser bugs, sometimes the Object implementation will be used even
	 * when the browser supports typed arrays.
	 *
	 * Note:
	 *
	 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
	 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
	 *
	 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
	 *
	 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
	 *     incorrect length in some situations.

	 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
	 * get the Object implementation, which is slower but behaves correctly.
	 */
	Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
	  ? global.TYPED_ARRAY_SUPPORT
	  : typedArraySupport()

	/*
	 * Export kMaxLength after typed array support is determined.
	 */
	exports.kMaxLength = kMaxLength()

	function typedArraySupport () {
	  try {
	    var arr = new Uint8Array(1)
	    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
	    return arr.foo() === 42 && // typed array instances can be augmented
	        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
	        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
	  } catch (e) {
	    return false
	  }
	}

	function kMaxLength () {
	  return Buffer.TYPED_ARRAY_SUPPORT
	    ? 0x7fffffff
	    : 0x3fffffff
	}

	function createBuffer (that, length) {
	  if (kMaxLength() < length) {
	    throw new RangeError('Invalid typed array length')
	  }
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = new Uint8Array(length)
	    that.__proto__ = Buffer.prototype
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    if (that === null) {
	      that = new Buffer(length)
	    }
	    that.length = length
	  }

	  return that
	}

	/**
	 * The Buffer constructor returns instances of `Uint8Array` that have their
	 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
	 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
	 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
	 * returns a single octet.
	 *
	 * The `Uint8Array` prototype remains unmodified.
	 */

	function Buffer (arg, encodingOrOffset, length) {
	  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
	    return new Buffer(arg, encodingOrOffset, length)
	  }

	  // Common case.
	  if (typeof arg === 'number') {
	    if (typeof encodingOrOffset === 'string') {
	      throw new Error(
	        'If encoding is specified then the first argument must be a string'
	      )
	    }
	    return allocUnsafe(this, arg)
	  }
	  return from(this, arg, encodingOrOffset, length)
	}

	Buffer.poolSize = 8192 // not used by this implementation

	// TODO: Legacy, not needed anymore. Remove in next major version.
	Buffer._augment = function (arr) {
	  arr.__proto__ = Buffer.prototype
	  return arr
	}

	function from (that, value, encodingOrOffset, length) {
	  if (typeof value === 'number') {
	    throw new TypeError('"value" argument must not be a number')
	  }

	  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
	    return fromArrayBuffer(that, value, encodingOrOffset, length)
	  }

	  if (typeof value === 'string') {
	    return fromString(that, value, encodingOrOffset)
	  }

	  return fromObject(that, value)
	}

	/**
	 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
	 * if value is a number.
	 * Buffer.from(str[, encoding])
	 * Buffer.from(array)
	 * Buffer.from(buffer)
	 * Buffer.from(arrayBuffer[, byteOffset[, length]])
	 **/
	Buffer.from = function (value, encodingOrOffset, length) {
	  return from(null, value, encodingOrOffset, length)
	}

	if (Buffer.TYPED_ARRAY_SUPPORT) {
	  Buffer.prototype.__proto__ = Uint8Array.prototype
	  Buffer.__proto__ = Uint8Array
	  if (typeof Symbol !== 'undefined' && Symbol.species &&
	      Buffer[Symbol.species] === Buffer) {
	    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
	    Object.defineProperty(Buffer, Symbol.species, {
	      value: null,
	      configurable: true
	    })
	  }
	}

	function assertSize (size) {
	  if (typeof size !== 'number') {
	    throw new TypeError('"size" argument must be a number')
	  } else if (size < 0) {
	    throw new RangeError('"size" argument must not be negative')
	  }
	}

	function alloc (that, size, fill, encoding) {
	  assertSize(size)
	  if (size <= 0) {
	    return createBuffer(that, size)
	  }
	  if (fill !== undefined) {
	    // Only pay attention to encoding if it's a string. This
	    // prevents accidentally sending in a number that would
	    // be interpretted as a start offset.
	    return typeof encoding === 'string'
	      ? createBuffer(that, size).fill(fill, encoding)
	      : createBuffer(that, size).fill(fill)
	  }
	  return createBuffer(that, size)
	}

	/**
	 * Creates a new filled Buffer instance.
	 * alloc(size[, fill[, encoding]])
	 **/
	Buffer.alloc = function (size, fill, encoding) {
	  return alloc(null, size, fill, encoding)
	}

	function allocUnsafe (that, size) {
	  assertSize(size)
	  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) {
	    for (var i = 0; i < size; ++i) {
	      that[i] = 0
	    }
	  }
	  return that
	}

	/**
	 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
	 * */
	Buffer.allocUnsafe = function (size) {
	  return allocUnsafe(null, size)
	}
	/**
	 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
	 */
	Buffer.allocUnsafeSlow = function (size) {
	  return allocUnsafe(null, size)
	}

	function fromString (that, string, encoding) {
	  if (typeof encoding !== 'string' || encoding === '') {
	    encoding = 'utf8'
	  }

	  if (!Buffer.isEncoding(encoding)) {
	    throw new TypeError('"encoding" must be a valid string encoding')
	  }

	  var length = byteLength(string, encoding) | 0
	  that = createBuffer(that, length)

	  var actual = that.write(string, encoding)

	  if (actual !== length) {
	    // Writing a hex string, for example, that contains invalid characters will
	    // cause everything after the first invalid character to be ignored. (e.g.
	    // 'abxxcd' will be treated as 'ab')
	    that = that.slice(0, actual)
	  }

	  return that
	}

	function fromArrayLike (that, array) {
	  var length = array.length < 0 ? 0 : checked(array.length) | 0
	  that = createBuffer(that, length)
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}

	function fromArrayBuffer (that, array, byteOffset, length) {
	  array.byteLength // this throws if `array` is not a valid ArrayBuffer

	  if (byteOffset < 0 || array.byteLength < byteOffset) {
	    throw new RangeError('\'offset\' is out of bounds')
	  }

	  if (array.byteLength < byteOffset + (length || 0)) {
	    throw new RangeError('\'length\' is out of bounds')
	  }

	  if (byteOffset === undefined && length === undefined) {
	    array = new Uint8Array(array)
	  } else if (length === undefined) {
	    array = new Uint8Array(array, byteOffset)
	  } else {
	    array = new Uint8Array(array, byteOffset, length)
	  }

	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = array
	    that.__proto__ = Buffer.prototype
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    that = fromArrayLike(that, array)
	  }
	  return that
	}

	function fromObject (that, obj) {
	  if (Buffer.isBuffer(obj)) {
	    var len = checked(obj.length) | 0
	    that = createBuffer(that, len)

	    if (that.length === 0) {
	      return that
	    }

	    obj.copy(that, 0, 0, len)
	    return that
	  }

	  if (obj) {
	    if ((typeof ArrayBuffer !== 'undefined' &&
	        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
	      if (typeof obj.length !== 'number' || isnan(obj.length)) {
	        return createBuffer(that, 0)
	      }
	      return fromArrayLike(that, obj)
	    }

	    if (obj.type === 'Buffer' && isArray(obj.data)) {
	      return fromArrayLike(that, obj.data)
	    }
	  }

	  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
	}

	function checked (length) {
	  // Note: cannot use `length < kMaxLength()` here because that fails when
	  // length is NaN (which is otherwise coerced to zero.)
	  if (length >= kMaxLength()) {
	    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
	                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
	  }
	  return length | 0
	}

	function SlowBuffer (length) {
	  if (+length != length) { // eslint-disable-line eqeqeq
	    length = 0
	  }
	  return Buffer.alloc(+length)
	}

	Buffer.isBuffer = function isBuffer (b) {
	  return !!(b != null && b._isBuffer)
	}

	Buffer.compare = function compare (a, b) {
	  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
	    throw new TypeError('Arguments must be Buffers')
	  }

	  if (a === b) return 0

	  var x = a.length
	  var y = b.length

	  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
	    if (a[i] !== b[i]) {
	      x = a[i]
	      y = b[i]
	      break
	    }
	  }

	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	}

	Buffer.isEncoding = function isEncoding (encoding) {
	  switch (String(encoding).toLowerCase()) {
	    case 'hex':
	    case 'utf8':
	    case 'utf-8':
	    case 'ascii':
	    case 'latin1':
	    case 'binary':
	    case 'base64':
	    case 'ucs2':
	    case 'ucs-2':
	    case 'utf16le':
	    case 'utf-16le':
	      return true
	    default:
	      return false
	  }
	}

	Buffer.concat = function concat (list, length) {
	  if (!isArray(list)) {
	    throw new TypeError('"list" argument must be an Array of Buffers')
	  }

	  if (list.length === 0) {
	    return Buffer.alloc(0)
	  }

	  var i
	  if (length === undefined) {
	    length = 0
	    for (i = 0; i < list.length; ++i) {
	      length += list[i].length
	    }
	  }

	  var buffer = Buffer.allocUnsafe(length)
	  var pos = 0
	  for (i = 0; i < list.length; ++i) {
	    var buf = list[i]
	    if (!Buffer.isBuffer(buf)) {
	      throw new TypeError('"list" argument must be an Array of Buffers')
	    }
	    buf.copy(buffer, pos)
	    pos += buf.length
	  }
	  return buffer
	}

	function byteLength (string, encoding) {
	  if (Buffer.isBuffer(string)) {
	    return string.length
	  }
	  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
	      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
	    return string.byteLength
	  }
	  if (typeof string !== 'string') {
	    string = '' + string
	  }

	  var len = string.length
	  if (len === 0) return 0

	  // Use a for loop to avoid recursion
	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'ascii':
	      case 'latin1':
	      case 'binary':
	        return len
	      case 'utf8':
	      case 'utf-8':
	      case undefined:
	        return utf8ToBytes(string).length
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return len * 2
	      case 'hex':
	        return len >>> 1
	      case 'base64':
	        return base64ToBytes(string).length
	      default:
	        if (loweredCase) return utf8ToBytes(string).length // assume utf8
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	Buffer.byteLength = byteLength

	function slowToString (encoding, start, end) {
	  var loweredCase = false

	  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
	  // property of a typed array.

	  // This behaves neither like String nor Uint8Array in that we set start/end
	  // to their upper/lower bounds if the value passed is out of range.
	  // undefined is handled specially as per ECMA-262 6th Edition,
	  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
	  if (start === undefined || start < 0) {
	    start = 0
	  }
	  // Return early if start > this.length. Done here to prevent potential uint32
	  // coercion fail below.
	  if (start > this.length) {
	    return ''
	  }

	  if (end === undefined || end > this.length) {
	    end = this.length
	  }

	  if (end <= 0) {
	    return ''
	  }

	  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
	  end >>>= 0
	  start >>>= 0

	  if (end <= start) {
	    return ''
	  }

	  if (!encoding) encoding = 'utf8'

	  while (true) {
	    switch (encoding) {
	      case 'hex':
	        return hexSlice(this, start, end)

	      case 'utf8':
	      case 'utf-8':
	        return utf8Slice(this, start, end)

	      case 'ascii':
	        return asciiSlice(this, start, end)

	      case 'latin1':
	      case 'binary':
	        return latin1Slice(this, start, end)

	      case 'base64':
	        return base64Slice(this, start, end)

	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return utf16leSlice(this, start, end)

	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = (encoding + '').toLowerCase()
	        loweredCase = true
	    }
	  }
	}

	// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
	// Buffer instances.
	Buffer.prototype._isBuffer = true

	function swap (b, n, m) {
	  var i = b[n]
	  b[n] = b[m]
	  b[m] = i
	}

	Buffer.prototype.swap16 = function swap16 () {
	  var len = this.length
	  if (len % 2 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 16-bits')
	  }
	  for (var i = 0; i < len; i += 2) {
	    swap(this, i, i + 1)
	  }
	  return this
	}

	Buffer.prototype.swap32 = function swap32 () {
	  var len = this.length
	  if (len % 4 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 32-bits')
	  }
	  for (var i = 0; i < len; i += 4) {
	    swap(this, i, i + 3)
	    swap(this, i + 1, i + 2)
	  }
	  return this
	}

	Buffer.prototype.swap64 = function swap64 () {
	  var len = this.length
	  if (len % 8 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 64-bits')
	  }
	  for (var i = 0; i < len; i += 8) {
	    swap(this, i, i + 7)
	    swap(this, i + 1, i + 6)
	    swap(this, i + 2, i + 5)
	    swap(this, i + 3, i + 4)
	  }
	  return this
	}

	Buffer.prototype.toString = function toString () {
	  var length = this.length | 0
	  if (length === 0) return ''
	  if (arguments.length === 0) return utf8Slice(this, 0, length)
	  return slowToString.apply(this, arguments)
	}

	Buffer.prototype.equals = function equals (b) {
	  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
	  if (this === b) return true
	  return Buffer.compare(this, b) === 0
	}

	Buffer.prototype.inspect = function inspect () {
	  var str = ''
	  var max = exports.INSPECT_MAX_BYTES
	  if (this.length > 0) {
	    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
	    if (this.length > max) str += ' ... '
	  }
	  return '<Buffer ' + str + '>'
	}

	Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
	  if (!Buffer.isBuffer(target)) {
	    throw new TypeError('Argument must be a Buffer')
	  }

	  if (start === undefined) {
	    start = 0
	  }
	  if (end === undefined) {
	    end = target ? target.length : 0
	  }
	  if (thisStart === undefined) {
	    thisStart = 0
	  }
	  if (thisEnd === undefined) {
	    thisEnd = this.length
	  }

	  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
	    throw new RangeError('out of range index')
	  }

	  if (thisStart >= thisEnd && start >= end) {
	    return 0
	  }
	  if (thisStart >= thisEnd) {
	    return -1
	  }
	  if (start >= end) {
	    return 1
	  }

	  start >>>= 0
	  end >>>= 0
	  thisStart >>>= 0
	  thisEnd >>>= 0

	  if (this === target) return 0

	  var x = thisEnd - thisStart
	  var y = end - start
	  var len = Math.min(x, y)

	  var thisCopy = this.slice(thisStart, thisEnd)
	  var targetCopy = target.slice(start, end)

	  for (var i = 0; i < len; ++i) {
	    if (thisCopy[i] !== targetCopy[i]) {
	      x = thisCopy[i]
	      y = targetCopy[i]
	      break
	    }
	  }

	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	}

	// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
	// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
	//
	// Arguments:
	// - buffer - a Buffer to search
	// - val - a string, Buffer, or number
	// - byteOffset - an index into `buffer`; will be clamped to an int32
	// - encoding - an optional encoding, relevant is val is a string
	// - dir - true for indexOf, false for lastIndexOf
	function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
	  // Empty buffer means no match
	  if (buffer.length === 0) return -1

	  // Normalize byteOffset
	  if (typeof byteOffset === 'string') {
	    encoding = byteOffset
	    byteOffset = 0
	  } else if (byteOffset > 0x7fffffff) {
	    byteOffset = 0x7fffffff
	  } else if (byteOffset < -0x80000000) {
	    byteOffset = -0x80000000
	  }
	  byteOffset = +byteOffset  // Coerce to Number.
	  if (isNaN(byteOffset)) {
	    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
	    byteOffset = dir ? 0 : (buffer.length - 1)
	  }

	  // Normalize byteOffset: negative offsets start from the end of the buffer
	  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
	  if (byteOffset >= buffer.length) {
	    if (dir) return -1
	    else byteOffset = buffer.length - 1
	  } else if (byteOffset < 0) {
	    if (dir) byteOffset = 0
	    else return -1
	  }

	  // Normalize val
	  if (typeof val === 'string') {
	    val = Buffer.from(val, encoding)
	  }

	  // Finally, search either indexOf (if dir is true) or lastIndexOf
	  if (Buffer.isBuffer(val)) {
	    // Special case: looking for empty string/buffer always fails
	    if (val.length === 0) {
	      return -1
	    }
	    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
	  } else if (typeof val === 'number') {
	    val = val & 0xFF // Search for a byte value [0-255]
	    if (Buffer.TYPED_ARRAY_SUPPORT &&
	        typeof Uint8Array.prototype.indexOf === 'function') {
	      if (dir) {
	        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
	      } else {
	        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
	      }
	    }
	    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
	  }

	  throw new TypeError('val must be string, number or Buffer')
	}

	function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
	  var indexSize = 1
	  var arrLength = arr.length
	  var valLength = val.length

	  if (encoding !== undefined) {
	    encoding = String(encoding).toLowerCase()
	    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
	        encoding === 'utf16le' || encoding === 'utf-16le') {
	      if (arr.length < 2 || val.length < 2) {
	        return -1
	      }
	      indexSize = 2
	      arrLength /= 2
	      valLength /= 2
	      byteOffset /= 2
	    }
	  }

	  function read (buf, i) {
	    if (indexSize === 1) {
	      return buf[i]
	    } else {
	      return buf.readUInt16BE(i * indexSize)
	    }
	  }

	  var i
	  if (dir) {
	    var foundIndex = -1
	    for (i = byteOffset; i < arrLength; i++) {
	      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
	        if (foundIndex === -1) foundIndex = i
	        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
	      } else {
	        if (foundIndex !== -1) i -= i - foundIndex
	        foundIndex = -1
	      }
	    }
	  } else {
	    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
	    for (i = byteOffset; i >= 0; i--) {
	      var found = true
	      for (var j = 0; j < valLength; j++) {
	        if (read(arr, i + j) !== read(val, j)) {
	          found = false
	          break
	        }
	      }
	      if (found) return i
	    }
	  }

	  return -1
	}

	Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
	  return this.indexOf(val, byteOffset, encoding) !== -1
	}

	Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
	  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
	}

	Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
	  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
	}

	function hexWrite (buf, string, offset, length) {
	  offset = Number(offset) || 0
	  var remaining = buf.length - offset
	  if (!length) {
	    length = remaining
	  } else {
	    length = Number(length)
	    if (length > remaining) {
	      length = remaining
	    }
	  }

	  // must be an even number of digits
	  var strLen = string.length
	  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

	  if (length > strLen / 2) {
	    length = strLen / 2
	  }
	  for (var i = 0; i < length; ++i) {
	    var parsed = parseInt(string.substr(i * 2, 2), 16)
	    if (isNaN(parsed)) return i
	    buf[offset + i] = parsed
	  }
	  return i
	}

	function utf8Write (buf, string, offset, length) {
	  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
	}

	function asciiWrite (buf, string, offset, length) {
	  return blitBuffer(asciiToBytes(string), buf, offset, length)
	}

	function latin1Write (buf, string, offset, length) {
	  return asciiWrite(buf, string, offset, length)
	}

	function base64Write (buf, string, offset, length) {
	  return blitBuffer(base64ToBytes(string), buf, offset, length)
	}

	function ucs2Write (buf, string, offset, length) {
	  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
	}

	Buffer.prototype.write = function write (string, offset, length, encoding) {
	  // Buffer#write(string)
	  if (offset === undefined) {
	    encoding = 'utf8'
	    length = this.length
	    offset = 0
	  // Buffer#write(string, encoding)
	  } else if (length === undefined && typeof offset === 'string') {
	    encoding = offset
	    length = this.length
	    offset = 0
	  // Buffer#write(string, offset[, length][, encoding])
	  } else if (isFinite(offset)) {
	    offset = offset | 0
	    if (isFinite(length)) {
	      length = length | 0
	      if (encoding === undefined) encoding = 'utf8'
	    } else {
	      encoding = length
	      length = undefined
	    }
	  // legacy write(string, encoding, offset, length) - remove in v0.13
	  } else {
	    throw new Error(
	      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
	    )
	  }

	  var remaining = this.length - offset
	  if (length === undefined || length > remaining) length = remaining

	  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
	    throw new RangeError('Attempt to write outside buffer bounds')
	  }

	  if (!encoding) encoding = 'utf8'

	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'hex':
	        return hexWrite(this, string, offset, length)

	      case 'utf8':
	      case 'utf-8':
	        return utf8Write(this, string, offset, length)

	      case 'ascii':
	        return asciiWrite(this, string, offset, length)

	      case 'latin1':
	      case 'binary':
	        return latin1Write(this, string, offset, length)

	      case 'base64':
	        // Warning: maxLength not taken into account in base64Write
	        return base64Write(this, string, offset, length)

	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return ucs2Write(this, string, offset, length)

	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}

	Buffer.prototype.toJSON = function toJSON () {
	  return {
	    type: 'Buffer',
	    data: Array.prototype.slice.call(this._arr || this, 0)
	  }
	}

	function base64Slice (buf, start, end) {
	  if (start === 0 && end === buf.length) {
	    return base64.fromByteArray(buf)
	  } else {
	    return base64.fromByteArray(buf.slice(start, end))
	  }
	}

	function utf8Slice (buf, start, end) {
	  end = Math.min(buf.length, end)
	  var res = []

	  var i = start
	  while (i < end) {
	    var firstByte = buf[i]
	    var codePoint = null
	    var bytesPerSequence = (firstByte > 0xEF) ? 4
	      : (firstByte > 0xDF) ? 3
	      : (firstByte > 0xBF) ? 2
	      : 1

	    if (i + bytesPerSequence <= end) {
	      var secondByte, thirdByte, fourthByte, tempCodePoint

	      switch (bytesPerSequence) {
	        case 1:
	          if (firstByte < 0x80) {
	            codePoint = firstByte
	          }
	          break
	        case 2:
	          secondByte = buf[i + 1]
	          if ((secondByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
	            if (tempCodePoint > 0x7F) {
	              codePoint = tempCodePoint
	            }
	          }
	          break
	        case 3:
	          secondByte = buf[i + 1]
	          thirdByte = buf[i + 2]
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
	            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
	              codePoint = tempCodePoint
	            }
	          }
	          break
	        case 4:
	          secondByte = buf[i + 1]
	          thirdByte = buf[i + 2]
	          fourthByte = buf[i + 3]
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
	            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
	              codePoint = tempCodePoint
	            }
	          }
	      }
	    }

	    if (codePoint === null) {
	      // we did not generate a valid codePoint so insert a
	      // replacement char (U+FFFD) and advance only 1 byte
	      codePoint = 0xFFFD
	      bytesPerSequence = 1
	    } else if (codePoint > 0xFFFF) {
	      // encode to utf16 (surrogate pair dance)
	      codePoint -= 0x10000
	      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
	      codePoint = 0xDC00 | codePoint & 0x3FF
	    }

	    res.push(codePoint)
	    i += bytesPerSequence
	  }

	  return decodeCodePointsArray(res)
	}

	// Based on http://stackoverflow.com/a/22747272/680742, the browser with
	// the lowest limit is Chrome, with 0x10000 args.
	// We go 1 magnitude less, for safety
	var MAX_ARGUMENTS_LENGTH = 0x1000

	function decodeCodePointsArray (codePoints) {
	  var len = codePoints.length
	  if (len <= MAX_ARGUMENTS_LENGTH) {
	    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
	  }

	  // Decode in chunks to avoid "call stack size exceeded".
	  var res = ''
	  var i = 0
	  while (i < len) {
	    res += String.fromCharCode.apply(
	      String,
	      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
	    )
	  }
	  return res
	}

	function asciiSlice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)

	  for (var i = start; i < end; ++i) {
	    ret += String.fromCharCode(buf[i] & 0x7F)
	  }
	  return ret
	}

	function latin1Slice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)

	  for (var i = start; i < end; ++i) {
	    ret += String.fromCharCode(buf[i])
	  }
	  return ret
	}

	function hexSlice (buf, start, end) {
	  var len = buf.length

	  if (!start || start < 0) start = 0
	  if (!end || end < 0 || end > len) end = len

	  var out = ''
	  for (var i = start; i < end; ++i) {
	    out += toHex(buf[i])
	  }
	  return out
	}

	function utf16leSlice (buf, start, end) {
	  var bytes = buf.slice(start, end)
	  var res = ''
	  for (var i = 0; i < bytes.length; i += 2) {
	    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
	  }
	  return res
	}

	Buffer.prototype.slice = function slice (start, end) {
	  var len = this.length
	  start = ~~start
	  end = end === undefined ? len : ~~end

	  if (start < 0) {
	    start += len
	    if (start < 0) start = 0
	  } else if (start > len) {
	    start = len
	  }

	  if (end < 0) {
	    end += len
	    if (end < 0) end = 0
	  } else if (end > len) {
	    end = len
	  }

	  if (end < start) end = start

	  var newBuf
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    newBuf = this.subarray(start, end)
	    newBuf.__proto__ = Buffer.prototype
	  } else {
	    var sliceLen = end - start
	    newBuf = new Buffer(sliceLen, undefined)
	    for (var i = 0; i < sliceLen; ++i) {
	      newBuf[i] = this[i + start]
	    }
	  }

	  return newBuf
	}

	/*
	 * Need to make sure that buffer isn't trying to write out of bounds.
	 */
	function checkOffset (offset, ext, length) {
	  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
	  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
	}

	Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)

	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }

	  return val
	}

	Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) {
	    checkOffset(offset, byteLength, this.length)
	  }

	  var val = this[offset + --byteLength]
	  var mul = 1
	  while (byteLength > 0 && (mul *= 0x100)) {
	    val += this[offset + --byteLength] * mul
	  }

	  return val
	}

	Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  return this[offset]
	}

	Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return this[offset] | (this[offset + 1] << 8)
	}

	Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return (this[offset] << 8) | this[offset + 1]
	}

	Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)

	  return ((this[offset]) |
	      (this[offset + 1] << 8) |
	      (this[offset + 2] << 16)) +
	      (this[offset + 3] * 0x1000000)
	}

	Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)

	  return (this[offset] * 0x1000000) +
	    ((this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    this[offset + 3])
	}

	Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)

	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }
	  mul *= 0x80

	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

	  return val
	}

	Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)

	  var i = byteLength
	  var mul = 1
	  var val = this[offset + --i]
	  while (i > 0 && (mul *= 0x100)) {
	    val += this[offset + --i] * mul
	  }
	  mul *= 0x80

	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

	  return val
	}

	Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  if (!(this[offset] & 0x80)) return (this[offset])
	  return ((0xff - this[offset] + 1) * -1)
	}

	Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset] | (this[offset + 1] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}

	Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset + 1] | (this[offset] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}

	Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)

	  return (this[offset]) |
	    (this[offset + 1] << 8) |
	    (this[offset + 2] << 16) |
	    (this[offset + 3] << 24)
	}

	Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)

	  return (this[offset] << 24) |
	    (this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    (this[offset + 3])
	}

	Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, true, 23, 4)
	}

	Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, false, 23, 4)
	}

	Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, true, 52, 8)
	}

	Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, false, 52, 8)
	}

	function checkInt (buf, value, offset, ext, max, min) {
	  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
	  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
	  if (offset + ext > buf.length) throw new RangeError('Index out of range')
	}

	Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) {
	    var maxBytes = Math.pow(2, 8 * byteLength) - 1
	    checkInt(this, value, offset, byteLength, maxBytes, 0)
	  }

	  var mul = 1
	  var i = 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }

	  return offset + byteLength
	}

	Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) {
	    var maxBytes = Math.pow(2, 8 * byteLength) - 1
	    checkInt(this, value, offset, byteLength, maxBytes, 0)
	  }

	  var i = byteLength - 1
	  var mul = 1
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }

	  return offset + byteLength
	}

	Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  this[offset] = (value & 0xff)
	  return offset + 1
	}

	function objectWriteUInt16 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
	    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
	      (littleEndian ? i : 1 - i) * 8
	  }
	}

	Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}

	Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = (value & 0xff)
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}

	function objectWriteUInt32 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffffffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
	    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
	  }
	}

	Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset + 3] = (value >>> 24)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 1] = (value >>> 8)
	    this[offset] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}

	Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}

	Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)

	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }

	  var i = 0
	  var mul = 1
	  var sub = 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
	      sub = 1
	    }
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }

	  return offset + byteLength
	}

	Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)

	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }

	  var i = byteLength - 1
	  var mul = 1
	  var sub = 0
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
	      sub = 1
	    }
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }

	  return offset + byteLength
	}

	Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  if (value < 0) value = 0xff + value + 1
	  this[offset] = (value & 0xff)
	  return offset + 1
	}

	Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}

	Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = (value & 0xff)
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}

	Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 3] = (value >>> 24)
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}

	Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (value < 0) value = 0xffffffff + value + 1
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}

	function checkIEEE754 (buf, value, offset, ext, max, min) {
	  if (offset + ext > buf.length) throw new RangeError('Index out of range')
	  if (offset < 0) throw new RangeError('Index out of range')
	}

	function writeFloat (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 23, 4)
	  return offset + 4
	}

	Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, true, noAssert)
	}

	Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, false, noAssert)
	}

	function writeDouble (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 52, 8)
	  return offset + 8
	}

	Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, true, noAssert)
	}

	Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, false, noAssert)
	}

	// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
	Buffer.prototype.copy = function copy (target, targetStart, start, end) {
	  if (!start) start = 0
	  if (!end && end !== 0) end = this.length
	  if (targetStart >= target.length) targetStart = target.length
	  if (!targetStart) targetStart = 0
	  if (end > 0 && end < start) end = start

	  // Copy 0 bytes; we're done
	  if (end === start) return 0
	  if (target.length === 0 || this.length === 0) return 0

	  // Fatal error conditions
	  if (targetStart < 0) {
	    throw new RangeError('targetStart out of bounds')
	  }
	  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
	  if (end < 0) throw new RangeError('sourceEnd out of bounds')

	  // Are we oob?
	  if (end > this.length) end = this.length
	  if (target.length - targetStart < end - start) {
	    end = target.length - targetStart + start
	  }

	  var len = end - start
	  var i

	  if (this === target && start < targetStart && targetStart < end) {
	    // descending copy from end
	    for (i = len - 1; i >= 0; --i) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
	    // ascending copy from start
	    for (i = 0; i < len; ++i) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else {
	    Uint8Array.prototype.set.call(
	      target,
	      this.subarray(start, start + len),
	      targetStart
	    )
	  }

	  return len
	}

	// Usage:
	//    buffer.fill(number[, offset[, end]])
	//    buffer.fill(buffer[, offset[, end]])
	//    buffer.fill(string[, offset[, end]][, encoding])
	Buffer.prototype.fill = function fill (val, start, end, encoding) {
	  // Handle string cases:
	  if (typeof val === 'string') {
	    if (typeof start === 'string') {
	      encoding = start
	      start = 0
	      end = this.length
	    } else if (typeof end === 'string') {
	      encoding = end
	      end = this.length
	    }
	    if (val.length === 1) {
	      var code = val.charCodeAt(0)
	      if (code < 256) {
	        val = code
	      }
	    }
	    if (encoding !== undefined && typeof encoding !== 'string') {
	      throw new TypeError('encoding must be a string')
	    }
	    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
	      throw new TypeError('Unknown encoding: ' + encoding)
	    }
	  } else if (typeof val === 'number') {
	    val = val & 255
	  }

	  // Invalid ranges are not set to a default, so can range check early.
	  if (start < 0 || this.length < start || this.length < end) {
	    throw new RangeError('Out of range index')
	  }

	  if (end <= start) {
	    return this
	  }

	  start = start >>> 0
	  end = end === undefined ? this.length : end >>> 0

	  if (!val) val = 0

	  var i
	  if (typeof val === 'number') {
	    for (i = start; i < end; ++i) {
	      this[i] = val
	    }
	  } else {
	    var bytes = Buffer.isBuffer(val)
	      ? val
	      : utf8ToBytes(new Buffer(val, encoding).toString())
	    var len = bytes.length
	    for (i = 0; i < end - start; ++i) {
	      this[i + start] = bytes[i % len]
	    }
	  }

	  return this
	}

	// HELPER FUNCTIONS
	// ================

	var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

	function base64clean (str) {
	  // Node strips out invalid characters like \n and \t from the string, base64-js does not
	  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
	  // Node converts strings with length < 2 to ''
	  if (str.length < 2) return ''
	  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
	  while (str.length % 4 !== 0) {
	    str = str + '='
	  }
	  return str
	}

	function stringtrim (str) {
	  if (str.trim) return str.trim()
	  return str.replace(/^\s+|\s+$/g, '')
	}

	function toHex (n) {
	  if (n < 16) return '0' + n.toString(16)
	  return n.toString(16)
	}

	function utf8ToBytes (string, units) {
	  units = units || Infinity
	  var codePoint
	  var length = string.length
	  var leadSurrogate = null
	  var bytes = []

	  for (var i = 0; i < length; ++i) {
	    codePoint = string.charCodeAt(i)

	    // is surrogate component
	    if (codePoint > 0xD7FF && codePoint < 0xE000) {
	      // last char was a lead
	      if (!leadSurrogate) {
	        // no lead yet
	        if (codePoint > 0xDBFF) {
	          // unexpected trail
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        } else if (i + 1 === length) {
	          // unpaired lead
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        }

	        // valid lead
	        leadSurrogate = codePoint

	        continue
	      }

	      // 2 leads in a row
	      if (codePoint < 0xDC00) {
	        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	        leadSurrogate = codePoint
	        continue
	      }

	      // valid surrogate pair
	      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
	    } else if (leadSurrogate) {
	      // valid bmp char, but last char was a lead
	      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	    }

	    leadSurrogate = null

	    // encode utf8
	    if (codePoint < 0x80) {
	      if ((units -= 1) < 0) break
	      bytes.push(codePoint)
	    } else if (codePoint < 0x800) {
	      if ((units -= 2) < 0) break
	      bytes.push(
	        codePoint >> 0x6 | 0xC0,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x10000) {
	      if ((units -= 3) < 0) break
	      bytes.push(
	        codePoint >> 0xC | 0xE0,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x110000) {
	      if ((units -= 4) < 0) break
	      bytes.push(
	        codePoint >> 0x12 | 0xF0,
	        codePoint >> 0xC & 0x3F | 0x80,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else {
	      throw new Error('Invalid code point')
	    }
	  }

	  return bytes
	}

	function asciiToBytes (str) {
	  var byteArray = []
	  for (var i = 0; i < str.length; ++i) {
	    // Node's code seems to be doing this and not & 0x7F..
	    byteArray.push(str.charCodeAt(i) & 0xFF)
	  }
	  return byteArray
	}

	function utf16leToBytes (str, units) {
	  var c, hi, lo
	  var byteArray = []
	  for (var i = 0; i < str.length; ++i) {
	    if ((units -= 2) < 0) break

	    c = str.charCodeAt(i)
	    hi = c >> 8
	    lo = c % 256
	    byteArray.push(lo)
	    byteArray.push(hi)
	  }

	  return byteArray
	}

	function base64ToBytes (str) {
	  return base64.toByteArray(base64clean(str))
	}

	function blitBuffer (src, dst, offset, length) {
	  for (var i = 0; i < length; ++i) {
	    if ((i + offset >= dst.length) || (i >= src.length)) break
	    dst[i + offset] = src[i]
	  }
	  return i
	}

	function isnan (val) {
	  return val !== val // eslint-disable-line no-self-compare
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(364).Buffer, (function() { return this; }())))

/***/ },
/* 365 */
/***/ function(module, exports) {

	'use strict'

	exports.toByteArray = toByteArray
	exports.fromByteArray = fromByteArray

	var lookup = []
	var revLookup = []
	var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

	function init () {
	  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
	  for (var i = 0, len = code.length; i < len; ++i) {
	    lookup[i] = code[i]
	    revLookup[code.charCodeAt(i)] = i
	  }

	  revLookup['-'.charCodeAt(0)] = 62
	  revLookup['_'.charCodeAt(0)] = 63
	}

	init()

	function toByteArray (b64) {
	  var i, j, l, tmp, placeHolders, arr
	  var len = b64.length

	  if (len % 4 > 0) {
	    throw new Error('Invalid string. Length must be a multiple of 4')
	  }

	  // the number of equal signs (place holders)
	  // if there are two placeholders, than the two characters before it
	  // represent one byte
	  // if there is only one, then the three characters before it represent 2 bytes
	  // this is just a cheap hack to not do indexOf twice
	  placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0

	  // base64 is 4/3 + up to two characters of the original data
	  arr = new Arr(len * 3 / 4 - placeHolders)

	  // if there are placeholders, only get up to the last complete 4 chars
	  l = placeHolders > 0 ? len - 4 : len

	  var L = 0

	  for (i = 0, j = 0; i < l; i += 4, j += 3) {
	    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
	    arr[L++] = (tmp >> 16) & 0xFF
	    arr[L++] = (tmp >> 8) & 0xFF
	    arr[L++] = tmp & 0xFF
	  }

	  if (placeHolders === 2) {
	    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
	    arr[L++] = tmp & 0xFF
	  } else if (placeHolders === 1) {
	    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
	    arr[L++] = (tmp >> 8) & 0xFF
	    arr[L++] = tmp & 0xFF
	  }

	  return arr
	}

	function tripletToBase64 (num) {
	  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
	}

	function encodeChunk (uint8, start, end) {
	  var tmp
	  var output = []
	  for (var i = start; i < end; i += 3) {
	    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
	    output.push(tripletToBase64(tmp))
	  }
	  return output.join('')
	}

	function fromByteArray (uint8) {
	  var tmp
	  var len = uint8.length
	  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
	  var output = ''
	  var parts = []
	  var maxChunkLength = 16383 // must be multiple of 3

	  // go through the array every three bytes, we'll deal with trailing stuff later
	  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
	    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
	  }

	  // pad the end with zeros, but make sure to not forget the extra bytes
	  if (extraBytes === 1) {
	    tmp = uint8[len - 1]
	    output += lookup[tmp >> 2]
	    output += lookup[(tmp << 4) & 0x3F]
	    output += '=='
	  } else if (extraBytes === 2) {
	    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
	    output += lookup[tmp >> 10]
	    output += lookup[(tmp >> 4) & 0x3F]
	    output += lookup[(tmp << 2) & 0x3F]
	    output += '='
	  }

	  parts.push(output)

	  return parts.join('')
	}


/***/ },
/* 366 */
/***/ function(module, exports) {

	exports.read = function (buffer, offset, isLE, mLen, nBytes) {
	  var e, m
	  var eLen = nBytes * 8 - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var nBits = -7
	  var i = isLE ? (nBytes - 1) : 0
	  var d = isLE ? -1 : 1
	  var s = buffer[offset + i]

	  i += d

	  e = s & ((1 << (-nBits)) - 1)
	  s >>= (-nBits)
	  nBits += eLen
	  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

	  m = e & ((1 << (-nBits)) - 1)
	  e >>= (-nBits)
	  nBits += mLen
	  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

	  if (e === 0) {
	    e = 1 - eBias
	  } else if (e === eMax) {
	    return m ? NaN : ((s ? -1 : 1) * Infinity)
	  } else {
	    m = m + Math.pow(2, mLen)
	    e = e - eBias
	  }
	  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
	}

	exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
	  var e, m, c
	  var eLen = nBytes * 8 - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
	  var i = isLE ? 0 : (nBytes - 1)
	  var d = isLE ? 1 : -1
	  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

	  value = Math.abs(value)

	  if (isNaN(value) || value === Infinity) {
	    m = isNaN(value) ? 1 : 0
	    e = eMax
	  } else {
	    e = Math.floor(Math.log(value) / Math.LN2)
	    if (value * (c = Math.pow(2, -e)) < 1) {
	      e--
	      c *= 2
	    }
	    if (e + eBias >= 1) {
	      value += rt / c
	    } else {
	      value += rt * Math.pow(2, 1 - eBias)
	    }
	    if (value * c >= 2) {
	      e++
	      c /= 2
	    }

	    if (e + eBias >= eMax) {
	      m = 0
	      e = eMax
	    } else if (e + eBias >= 1) {
	      m = (value * c - 1) * Math.pow(2, mLen)
	      e = e + eBias
	    } else {
	      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
	      e = 0
	    }
	  }

	  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

	  e = (e << mLen) | m
	  eLen += mLen
	  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

	  buffer[offset + i - d] |= s * 128
	}


/***/ },
/* 367 */
/***/ function(module, exports) {

	var toString = {}.toString;

	module.exports = Array.isArray || function (arr) {
	  return toString.call(arr) == '[object Array]';
	};


/***/ },
/* 368 */
/***/ function(module, exports, __webpack_require__) {

	var http = module.exports;
	var EventEmitter = __webpack_require__(369).EventEmitter;
	var Request = __webpack_require__(370);
	var url = __webpack_require__(389)

	http.request = function (params, cb) {
	    if (typeof params === 'string') {
	        params = url.parse(params)
	    }
	    if (!params) params = {};
	    if (!params.host && !params.port) {
	        params.port = parseInt(window.location.port, 10);
	    }
	    if (!params.host && params.hostname) {
	        params.host = params.hostname;
	    }

	    if (!params.protocol) {
	        if (params.scheme) {
	            params.protocol = params.scheme + ':';
	        } else {
	            params.protocol = window.location.protocol;
	        }
	    }

	    if (!params.host) {
	        params.host = window.location.hostname || window.location.host;
	    }
	    if (/:/.test(params.host)) {
	        if (!params.port) {
	            params.port = params.host.split(':')[1];
	        }
	        params.host = params.host.split(':')[0];
	    }
	    if (!params.port) params.port = params.protocol == 'https:' ? 443 : 80;
	    
	    var req = new Request(new xhrHttp, params);
	    if (cb) req.on('response', cb);
	    return req;
	};

	http.get = function (params, cb) {
	    params.method = 'GET';
	    var req = http.request(params, cb);
	    req.end();
	    return req;
	};

	http.Agent = function () {};
	http.Agent.defaultMaxSockets = 4;

	var xhrHttp = (function () {
	    if (typeof window === 'undefined') {
	        throw new Error('no window object present');
	    }
	    else if (window.XMLHttpRequest) {
	        return window.XMLHttpRequest;
	    }
	    else if (window.ActiveXObject) {
	        var axs = [
	            'Msxml2.XMLHTTP.6.0',
	            'Msxml2.XMLHTTP.3.0',
	            'Microsoft.XMLHTTP'
	        ];
	        for (var i = 0; i < axs.length; i++) {
	            try {
	                var ax = new(window.ActiveXObject)(axs[i]);
	                return function () {
	                    if (ax) {
	                        var ax_ = ax;
	                        ax = null;
	                        return ax_;
	                    }
	                    else {
	                        return new(window.ActiveXObject)(axs[i]);
	                    }
	                };
	            }
	            catch (e) {}
	        }
	        throw new Error('ajax not supported in this browser')
	    }
	    else {
	        throw new Error('ajax not supported in this browser');
	    }
	})();

	http.STATUS_CODES = {
	    100 : 'Continue',
	    101 : 'Switching Protocols',
	    102 : 'Processing',                 // RFC 2518, obsoleted by RFC 4918
	    200 : 'OK',
	    201 : 'Created',
	    202 : 'Accepted',
	    203 : 'Non-Authoritative Information',
	    204 : 'No Content',
	    205 : 'Reset Content',
	    206 : 'Partial Content',
	    207 : 'Multi-Status',               // RFC 4918
	    300 : 'Multiple Choices',
	    301 : 'Moved Permanently',
	    302 : 'Moved Temporarily',
	    303 : 'See Other',
	    304 : 'Not Modified',
	    305 : 'Use Proxy',
	    307 : 'Temporary Redirect',
	    400 : 'Bad Request',
	    401 : 'Unauthorized',
	    402 : 'Payment Required',
	    403 : 'Forbidden',
	    404 : 'Not Found',
	    405 : 'Method Not Allowed',
	    406 : 'Not Acceptable',
	    407 : 'Proxy Authentication Required',
	    408 : 'Request Time-out',
	    409 : 'Conflict',
	    410 : 'Gone',
	    411 : 'Length Required',
	    412 : 'Precondition Failed',
	    413 : 'Request Entity Too Large',
	    414 : 'Request-URI Too Large',
	    415 : 'Unsupported Media Type',
	    416 : 'Requested Range Not Satisfiable',
	    417 : 'Expectation Failed',
	    418 : 'I\'m a teapot',              // RFC 2324
	    422 : 'Unprocessable Entity',       // RFC 4918
	    423 : 'Locked',                     // RFC 4918
	    424 : 'Failed Dependency',          // RFC 4918
	    425 : 'Unordered Collection',       // RFC 4918
	    426 : 'Upgrade Required',           // RFC 2817
	    428 : 'Precondition Required',      // RFC 6585
	    429 : 'Too Many Requests',          // RFC 6585
	    431 : 'Request Header Fields Too Large',// RFC 6585
	    500 : 'Internal Server Error',
	    501 : 'Not Implemented',
	    502 : 'Bad Gateway',
	    503 : 'Service Unavailable',
	    504 : 'Gateway Time-out',
	    505 : 'HTTP Version Not Supported',
	    506 : 'Variant Also Negotiates',    // RFC 2295
	    507 : 'Insufficient Storage',       // RFC 4918
	    509 : 'Bandwidth Limit Exceeded',
	    510 : 'Not Extended',               // RFC 2774
	    511 : 'Network Authentication Required' // RFC 6585
	};

/***/ },
/* 369 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(console) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	function EventEmitter() {
	  this._events = this._events || {};
	  this._maxListeners = this._maxListeners || undefined;
	}
	module.exports = EventEmitter;

	// Backwards-compat with node 0.10.x
	EventEmitter.EventEmitter = EventEmitter;

	EventEmitter.prototype._events = undefined;
	EventEmitter.prototype._maxListeners = undefined;

	// By default EventEmitters will print a warning if more than 10 listeners are
	// added to it. This is a useful default which helps finding memory leaks.
	EventEmitter.defaultMaxListeners = 10;

	// Obviously not all Emitters should be limited to 10. This function allows
	// that to be increased. Set to zero for unlimited.
	EventEmitter.prototype.setMaxListeners = function(n) {
	  if (!isNumber(n) || n < 0 || isNaN(n))
	    throw TypeError('n must be a positive number');
	  this._maxListeners = n;
	  return this;
	};

	EventEmitter.prototype.emit = function(type) {
	  var er, handler, len, args, i, listeners;

	  if (!this._events)
	    this._events = {};

	  // If there is no 'error' event listener then throw.
	  if (type === 'error') {
	    if (!this._events.error ||
	        (isObject(this._events.error) && !this._events.error.length)) {
	      er = arguments[1];
	      if (er instanceof Error) {
	        throw er; // Unhandled 'error' event
	      } else {
	        // At least give some kind of context to the user
	        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
	        err.context = er;
	        throw err;
	      }
	    }
	  }

	  handler = this._events[type];

	  if (isUndefined(handler))
	    return false;

	  if (isFunction(handler)) {
	    switch (arguments.length) {
	      // fast cases
	      case 1:
	        handler.call(this);
	        break;
	      case 2:
	        handler.call(this, arguments[1]);
	        break;
	      case 3:
	        handler.call(this, arguments[1], arguments[2]);
	        break;
	      // slower
	      default:
	        args = Array.prototype.slice.call(arguments, 1);
	        handler.apply(this, args);
	    }
	  } else if (isObject(handler)) {
	    args = Array.prototype.slice.call(arguments, 1);
	    listeners = handler.slice();
	    len = listeners.length;
	    for (i = 0; i < len; i++)
	      listeners[i].apply(this, args);
	  }

	  return true;
	};

	EventEmitter.prototype.addListener = function(type, listener) {
	  var m;

	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');

	  if (!this._events)
	    this._events = {};

	  // To avoid recursion in the case that type === "newListener"! Before
	  // adding it to the listeners, first emit "newListener".
	  if (this._events.newListener)
	    this.emit('newListener', type,
	              isFunction(listener.listener) ?
	              listener.listener : listener);

	  if (!this._events[type])
	    // Optimize the case of one listener. Don't need the extra array object.
	    this._events[type] = listener;
	  else if (isObject(this._events[type]))
	    // If we've already got an array, just append.
	    this._events[type].push(listener);
	  else
	    // Adding the second element, need to change to array.
	    this._events[type] = [this._events[type], listener];

	  // Check for listener leak
	  if (isObject(this._events[type]) && !this._events[type].warned) {
	    if (!isUndefined(this._maxListeners)) {
	      m = this._maxListeners;
	    } else {
	      m = EventEmitter.defaultMaxListeners;
	    }

	    if (m && m > 0 && this._events[type].length > m) {
	      this._events[type].warned = true;
	      console.error('(node) warning: possible EventEmitter memory ' +
	                    'leak detected. %d listeners added. ' +
	                    'Use emitter.setMaxListeners() to increase limit.',
	                    this._events[type].length);
	      if (typeof console.trace === 'function') {
	        // not supported in IE 10
	        console.trace();
	      }
	    }
	  }

	  return this;
	};

	EventEmitter.prototype.on = EventEmitter.prototype.addListener;

	EventEmitter.prototype.once = function(type, listener) {
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');

	  var fired = false;

	  function g() {
	    this.removeListener(type, g);

	    if (!fired) {
	      fired = true;
	      listener.apply(this, arguments);
	    }
	  }

	  g.listener = listener;
	  this.on(type, g);

	  return this;
	};

	// emits a 'removeListener' event iff the listener was removed
	EventEmitter.prototype.removeListener = function(type, listener) {
	  var list, position, length, i;

	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');

	  if (!this._events || !this._events[type])
	    return this;

	  list = this._events[type];
	  length = list.length;
	  position = -1;

	  if (list === listener ||
	      (isFunction(list.listener) && list.listener === listener)) {
	    delete this._events[type];
	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);

	  } else if (isObject(list)) {
	    for (i = length; i-- > 0;) {
	      if (list[i] === listener ||
	          (list[i].listener && list[i].listener === listener)) {
	        position = i;
	        break;
	      }
	    }

	    if (position < 0)
	      return this;

	    if (list.length === 1) {
	      list.length = 0;
	      delete this._events[type];
	    } else {
	      list.splice(position, 1);
	    }

	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);
	  }

	  return this;
	};

	EventEmitter.prototype.removeAllListeners = function(type) {
	  var key, listeners;

	  if (!this._events)
	    return this;

	  // not listening for removeListener, no need to emit
	  if (!this._events.removeListener) {
	    if (arguments.length === 0)
	      this._events = {};
	    else if (this._events[type])
	      delete this._events[type];
	    return this;
	  }

	  // emit removeListener for all listeners on all events
	  if (arguments.length === 0) {
	    for (key in this._events) {
	      if (key === 'removeListener') continue;
	      this.removeAllListeners(key);
	    }
	    this.removeAllListeners('removeListener');
	    this._events = {};
	    return this;
	  }

	  listeners = this._events[type];

	  if (isFunction(listeners)) {
	    this.removeListener(type, listeners);
	  } else if (listeners) {
	    // LIFO order
	    while (listeners.length)
	      this.removeListener(type, listeners[listeners.length - 1]);
	  }
	  delete this._events[type];

	  return this;
	};

	EventEmitter.prototype.listeners = function(type) {
	  var ret;
	  if (!this._events || !this._events[type])
	    ret = [];
	  else if (isFunction(this._events[type]))
	    ret = [this._events[type]];
	  else
	    ret = this._events[type].slice();
	  return ret;
	};

	EventEmitter.prototype.listenerCount = function(type) {
	  if (this._events) {
	    var evlistener = this._events[type];

	    if (isFunction(evlistener))
	      return 1;
	    else if (evlistener)
	      return evlistener.length;
	  }
	  return 0;
	};

	EventEmitter.listenerCount = function(emitter, type) {
	  return emitter.listenerCount(type);
	};

	function isFunction(arg) {
	  return typeof arg === 'function';
	}

	function isNumber(arg) {
	  return typeof arg === 'number';
	}

	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}

	function isUndefined(arg) {
	  return arg === void 0;
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 370 */
/***/ function(module, exports, __webpack_require__) {

	var Stream = __webpack_require__(371);
	var Response = __webpack_require__(387);
	var Base64 = __webpack_require__(388);
	var inherits = __webpack_require__(372);

	var Request = module.exports = function (xhr, params) {
	    var self = this;
	    self.writable = true;
	    self.xhr = xhr;
	    self.body = [];
	    
	    self.uri = (params.protocol || 'http:') + '//'
	        + params.host
	        + (params.port ? ':' + params.port : '')
	        + (params.path || '/')
	    ;
	    
	    if (typeof params.withCredentials === 'undefined') {
	        params.withCredentials = true;
	    }

	    try { xhr.withCredentials = params.withCredentials }
	    catch (e) {}
	    
	    if (params.responseType) try { xhr.responseType = params.responseType }
	    catch (e) {}
	    
	    xhr.open(
	        params.method || 'GET',
	        self.uri,
	        true
	    );

	    xhr.onerror = function(event) {
	        self.emit('error', new Error('Network error'));
	    };

	    self._headers = {};
	    
	    if (params.headers) {
	        var keys = objectKeys(params.headers);
	        for (var i = 0; i < keys.length; i++) {
	            var key = keys[i];
	            if (!self.isSafeRequestHeader(key)) continue;
	            var value = params.headers[key];
	            self.setHeader(key, value);
	        }
	    }
	    
	    if (params.auth) {
	        //basic auth
	        this.setHeader('Authorization', 'Basic ' + Base64.btoa(params.auth));
	    }

	    var res = new Response;
	    res.on('close', function () {
	        self.emit('close');
	    });
	    
	    res.on('ready', function () {
	        self.emit('response', res);
	    });

	    res.on('error', function (err) {
	        self.emit('error', err);
	    });
	    
	    xhr.onreadystatechange = function () {
	        // Fix for IE9 bug
	        // SCRIPT575: Could not complete the operation due to error c00c023f
	        // It happens when a request is aborted, calling the success callback anyway with readyState === 4
	        if (xhr.__aborted) return;
	        res.handle(xhr);
	    };
	};

	inherits(Request, Stream);

	Request.prototype.setHeader = function (key, value) {
	    this._headers[key.toLowerCase()] = value
	};

	Request.prototype.getHeader = function (key) {
	    return this._headers[key.toLowerCase()]
	};

	Request.prototype.removeHeader = function (key) {
	    delete this._headers[key.toLowerCase()]
	};

	Request.prototype.write = function (s) {
	    this.body.push(s);
	};

	Request.prototype.destroy = function (s) {
	    this.xhr.__aborted = true;
	    this.xhr.abort();
	    this.emit('close');
	};

	Request.prototype.end = function (s) {
	    if (s !== undefined) this.body.push(s);

	    var keys = objectKeys(this._headers);
	    for (var i = 0; i < keys.length; i++) {
	        var key = keys[i];
	        var value = this._headers[key];
	        if (isArray(value)) {
	            for (var j = 0; j < value.length; j++) {
	                this.xhr.setRequestHeader(key, value[j]);
	            }
	        }
	        else this.xhr.setRequestHeader(key, value)
	    }

	    if (this.body.length === 0) {
	        this.xhr.send('');
	    }
	    else if (typeof this.body[0] === 'string') {
	        this.xhr.send(this.body.join(''));
	    }
	    else if (isArray(this.body[0])) {
	        var body = [];
	        for (var i = 0; i < this.body.length; i++) {
	            body.push.apply(body, this.body[i]);
	        }
	        this.xhr.send(body);
	    }
	    else if (/Array/.test(Object.prototype.toString.call(this.body[0]))) {
	        var len = 0;
	        for (var i = 0; i < this.body.length; i++) {
	            len += this.body[i].length;
	        }
	        var body = new(this.body[0].constructor)(len);
	        var k = 0;
	        
	        for (var i = 0; i < this.body.length; i++) {
	            var b = this.body[i];
	            for (var j = 0; j < b.length; j++) {
	                body[k++] = b[j];
	            }
	        }
	        this.xhr.send(body);
	    }
	    else if (isXHR2Compatible(this.body[0])) {
	        this.xhr.send(this.body[0]);
	    }
	    else {
	        var body = '';
	        for (var i = 0; i < this.body.length; i++) {
	            body += this.body[i].toString();
	        }
	        this.xhr.send(body);
	    }
	};

	// Taken from http://dxr.mozilla.org/mozilla/mozilla-central/content/base/src/nsXMLHttpRequest.cpp.html
	Request.unsafeHeaders = [
	    "accept-charset",
	    "accept-encoding",
	    "access-control-request-headers",
	    "access-control-request-method",
	    "connection",
	    "content-length",
	    "cookie",
	    "cookie2",
	    "content-transfer-encoding",
	    "date",
	    "expect",
	    "host",
	    "keep-alive",
	    "origin",
	    "referer",
	    "te",
	    "trailer",
	    "transfer-encoding",
	    "upgrade",
	    "user-agent",
	    "via"
	];

	Request.prototype.isSafeRequestHeader = function (headerName) {
	    if (!headerName) return false;
	    return indexOf(Request.unsafeHeaders, headerName.toLowerCase()) === -1;
	};

	var objectKeys = Object.keys || function (obj) {
	    var keys = [];
	    for (var key in obj) keys.push(key);
	    return keys;
	};

	var isArray = Array.isArray || function (xs) {
	    return Object.prototype.toString.call(xs) === '[object Array]';
	};

	var indexOf = function (xs, x) {
	    if (xs.indexOf) return xs.indexOf(x);
	    for (var i = 0; i < xs.length; i++) {
	        if (xs[i] === x) return i;
	    }
	    return -1;
	};

	var isXHR2Compatible = function (obj) {
	    if (typeof Blob !== 'undefined' && obj instanceof Blob) return true;
	    if (typeof ArrayBuffer !== 'undefined' && obj instanceof ArrayBuffer) return true;
	    if (typeof FormData !== 'undefined' && obj instanceof FormData) return true;
	};


/***/ },
/* 371 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	module.exports = Stream;

	var EE = __webpack_require__(369).EventEmitter;
	var inherits = __webpack_require__(372);

	inherits(Stream, EE);
	Stream.Readable = __webpack_require__(373);
	Stream.Writable = __webpack_require__(383);
	Stream.Duplex = __webpack_require__(384);
	Stream.Transform = __webpack_require__(385);
	Stream.PassThrough = __webpack_require__(386);

	// Backwards-compat with node 0.4.x
	Stream.Stream = Stream;



	// old-style streams.  Note that the pipe method (the only relevant
	// part of this class) is overridden in the Readable class.

	function Stream() {
	  EE.call(this);
	}

	Stream.prototype.pipe = function(dest, options) {
	  var source = this;

	  function ondata(chunk) {
	    if (dest.writable) {
	      if (false === dest.write(chunk) && source.pause) {
	        source.pause();
	      }
	    }
	  }

	  source.on('data', ondata);

	  function ondrain() {
	    if (source.readable && source.resume) {
	      source.resume();
	    }
	  }

	  dest.on('drain', ondrain);

	  // If the 'end' option is not supplied, dest.end() will be called when
	  // source gets the 'end' or 'close' events.  Only dest.end() once.
	  if (!dest._isStdio && (!options || options.end !== false)) {
	    source.on('end', onend);
	    source.on('close', onclose);
	  }

	  var didOnEnd = false;
	  function onend() {
	    if (didOnEnd) return;
	    didOnEnd = true;

	    dest.end();
	  }


	  function onclose() {
	    if (didOnEnd) return;
	    didOnEnd = true;

	    if (typeof dest.destroy === 'function') dest.destroy();
	  }

	  // don't leave dangling pipes when there are errors.
	  function onerror(er) {
	    cleanup();
	    if (EE.listenerCount(this, 'error') === 0) {
	      throw er; // Unhandled stream error in pipe.
	    }
	  }

	  source.on('error', onerror);
	  dest.on('error', onerror);

	  // remove all the event listeners that were added.
	  function cleanup() {
	    source.removeListener('data', ondata);
	    dest.removeListener('drain', ondrain);

	    source.removeListener('end', onend);
	    source.removeListener('close', onclose);

	    source.removeListener('error', onerror);
	    dest.removeListener('error', onerror);

	    source.removeListener('end', cleanup);
	    source.removeListener('close', cleanup);

	    dest.removeListener('close', cleanup);
	  }

	  source.on('end', cleanup);
	  source.on('close', cleanup);

	  dest.on('close', cleanup);

	  dest.emit('pipe', source);

	  // Allow for unix-like usage: A.pipe(B).pipe(C)
	  return dest;
	};


/***/ },
/* 372 */
/***/ function(module, exports) {

	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  // old school shim for old browsers
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    var TempCtor = function () {}
	    TempCtor.prototype = superCtor.prototype
	    ctor.prototype = new TempCtor()
	    ctor.prototype.constructor = ctor
	  }
	}


/***/ },
/* 373 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {exports = module.exports = __webpack_require__(374);
	exports.Stream = __webpack_require__(371);
	exports.Readable = exports;
	exports.Writable = __webpack_require__(379);
	exports.Duplex = __webpack_require__(378);
	exports.Transform = __webpack_require__(381);
	exports.PassThrough = __webpack_require__(382);
	if (!process.browser && process.env.READABLE_STREAM === 'disable') {
	  module.exports = __webpack_require__(371);
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 374 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	module.exports = Readable;

	/*<replacement>*/
	var isArray = __webpack_require__(375);
	/*</replacement>*/


	/*<replacement>*/
	var Buffer = __webpack_require__(364).Buffer;
	/*</replacement>*/

	Readable.ReadableState = ReadableState;

	var EE = __webpack_require__(369).EventEmitter;

	/*<replacement>*/
	if (!EE.listenerCount) EE.listenerCount = function(emitter, type) {
	  return emitter.listeners(type).length;
	};
	/*</replacement>*/

	var Stream = __webpack_require__(371);

	/*<replacement>*/
	var util = __webpack_require__(376);
	util.inherits = __webpack_require__(372);
	/*</replacement>*/

	var StringDecoder;


	/*<replacement>*/
	var debug = __webpack_require__(377);
	if (debug && debug.debuglog) {
	  debug = debug.debuglog('stream');
	} else {
	  debug = function () {};
	}
	/*</replacement>*/


	util.inherits(Readable, Stream);

	function ReadableState(options, stream) {
	  var Duplex = __webpack_require__(378);

	  options = options || {};

	  // the point at which it stops calling _read() to fill the buffer
	  // Note: 0 is a valid value, means "don't call _read preemptively ever"
	  var hwm = options.highWaterMark;
	  var defaultHwm = options.objectMode ? 16 : 16 * 1024;
	  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;

	  // cast to ints.
	  this.highWaterMark = ~~this.highWaterMark;

	  this.buffer = [];
	  this.length = 0;
	  this.pipes = null;
	  this.pipesCount = 0;
	  this.flowing = null;
	  this.ended = false;
	  this.endEmitted = false;
	  this.reading = false;

	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, because any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;

	  // whenever we return null, then we set a flag to say
	  // that we're awaiting a 'readable' event emission.
	  this.needReadable = false;
	  this.emittedReadable = false;
	  this.readableListening = false;


	  // object stream flag. Used to make read(n) ignore n and to
	  // make all the buffer merging and length checks go away
	  this.objectMode = !!options.objectMode;

	  if (stream instanceof Duplex)
	    this.objectMode = this.objectMode || !!options.readableObjectMode;

	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';

	  // when piping, we only care about 'readable' events that happen
	  // after read()ing all the bytes and not getting any pushback.
	  this.ranOut = false;

	  // the number of writers that are awaiting a drain event in .pipe()s
	  this.awaitDrain = 0;

	  // if true, a maybeReadMore has been scheduled
	  this.readingMore = false;

	  this.decoder = null;
	  this.encoding = null;
	  if (options.encoding) {
	    if (!StringDecoder)
	      StringDecoder = __webpack_require__(380).StringDecoder;
	    this.decoder = new StringDecoder(options.encoding);
	    this.encoding = options.encoding;
	  }
	}

	function Readable(options) {
	  var Duplex = __webpack_require__(378);

	  if (!(this instanceof Readable))
	    return new Readable(options);

	  this._readableState = new ReadableState(options, this);

	  // legacy
	  this.readable = true;

	  Stream.call(this);
	}

	// Manually shove something into the read() buffer.
	// This returns true if the highWaterMark has not been hit yet,
	// similar to how Writable.write() returns true if you should
	// write() some more.
	Readable.prototype.push = function(chunk, encoding) {
	  var state = this._readableState;

	  if (util.isString(chunk) && !state.objectMode) {
	    encoding = encoding || state.defaultEncoding;
	    if (encoding !== state.encoding) {
	      chunk = new Buffer(chunk, encoding);
	      encoding = '';
	    }
	  }

	  return readableAddChunk(this, state, chunk, encoding, false);
	};

	// Unshift should *always* be something directly out of read()
	Readable.prototype.unshift = function(chunk) {
	  var state = this._readableState;
	  return readableAddChunk(this, state, chunk, '', true);
	};

	function readableAddChunk(stream, state, chunk, encoding, addToFront) {
	  var er = chunkInvalid(state, chunk);
	  if (er) {
	    stream.emit('error', er);
	  } else if (util.isNullOrUndefined(chunk)) {
	    state.reading = false;
	    if (!state.ended)
	      onEofChunk(stream, state);
	  } else if (state.objectMode || chunk && chunk.length > 0) {
	    if (state.ended && !addToFront) {
	      var e = new Error('stream.push() after EOF');
	      stream.emit('error', e);
	    } else if (state.endEmitted && addToFront) {
	      var e = new Error('stream.unshift() after end event');
	      stream.emit('error', e);
	    } else {
	      if (state.decoder && !addToFront && !encoding)
	        chunk = state.decoder.write(chunk);

	      if (!addToFront)
	        state.reading = false;

	      // if we want the data now, just emit it.
	      if (state.flowing && state.length === 0 && !state.sync) {
	        stream.emit('data', chunk);
	        stream.read(0);
	      } else {
	        // update the buffer info.
	        state.length += state.objectMode ? 1 : chunk.length;
	        if (addToFront)
	          state.buffer.unshift(chunk);
	        else
	          state.buffer.push(chunk);

	        if (state.needReadable)
	          emitReadable(stream);
	      }

	      maybeReadMore(stream, state);
	    }
	  } else if (!addToFront) {
	    state.reading = false;
	  }

	  return needMoreData(state);
	}



	// if it's past the high water mark, we can push in some more.
	// Also, if we have no data yet, we can stand some
	// more bytes.  This is to work around cases where hwm=0,
	// such as the repl.  Also, if the push() triggered a
	// readable event, and the user called read(largeNumber) such that
	// needReadable was set, then we ought to push more, so that another
	// 'readable' event will be triggered.
	function needMoreData(state) {
	  return !state.ended &&
	         (state.needReadable ||
	          state.length < state.highWaterMark ||
	          state.length === 0);
	}

	// backwards compatibility.
	Readable.prototype.setEncoding = function(enc) {
	  if (!StringDecoder)
	    StringDecoder = __webpack_require__(380).StringDecoder;
	  this._readableState.decoder = new StringDecoder(enc);
	  this._readableState.encoding = enc;
	  return this;
	};

	// Don't raise the hwm > 128MB
	var MAX_HWM = 0x800000;
	function roundUpToNextPowerOf2(n) {
	  if (n >= MAX_HWM) {
	    n = MAX_HWM;
	  } else {
	    // Get the next highest power of 2
	    n--;
	    for (var p = 1; p < 32; p <<= 1) n |= n >> p;
	    n++;
	  }
	  return n;
	}

	function howMuchToRead(n, state) {
	  if (state.length === 0 && state.ended)
	    return 0;

	  if (state.objectMode)
	    return n === 0 ? 0 : 1;

	  if (isNaN(n) || util.isNull(n)) {
	    // only flow one buffer at a time
	    if (state.flowing && state.buffer.length)
	      return state.buffer[0].length;
	    else
	      return state.length;
	  }

	  if (n <= 0)
	    return 0;

	  // If we're asking for more than the target buffer level,
	  // then raise the water mark.  Bump up to the next highest
	  // power of 2, to prevent increasing it excessively in tiny
	  // amounts.
	  if (n > state.highWaterMark)
	    state.highWaterMark = roundUpToNextPowerOf2(n);

	  // don't have that much.  return null, unless we've ended.
	  if (n > state.length) {
	    if (!state.ended) {
	      state.needReadable = true;
	      return 0;
	    } else
	      return state.length;
	  }

	  return n;
	}

	// you can override either this method, or the async _read(n) below.
	Readable.prototype.read = function(n) {
	  debug('read', n);
	  var state = this._readableState;
	  var nOrig = n;

	  if (!util.isNumber(n) || n > 0)
	    state.emittedReadable = false;

	  // if we're doing read(0) to trigger a readable event, but we
	  // already have a bunch of data in the buffer, then just trigger
	  // the 'readable' event and move on.
	  if (n === 0 &&
	      state.needReadable &&
	      (state.length >= state.highWaterMark || state.ended)) {
	    debug('read: emitReadable', state.length, state.ended);
	    if (state.length === 0 && state.ended)
	      endReadable(this);
	    else
	      emitReadable(this);
	    return null;
	  }

	  n = howMuchToRead(n, state);

	  // if we've ended, and we're now clear, then finish it up.
	  if (n === 0 && state.ended) {
	    if (state.length === 0)
	      endReadable(this);
	    return null;
	  }

	  // All the actual chunk generation logic needs to be
	  // *below* the call to _read.  The reason is that in certain
	  // synthetic stream cases, such as passthrough streams, _read
	  // may be a completely synchronous operation which may change
	  // the state of the read buffer, providing enough data when
	  // before there was *not* enough.
	  //
	  // So, the steps are:
	  // 1. Figure out what the state of things will be after we do
	  // a read from the buffer.
	  //
	  // 2. If that resulting state will trigger a _read, then call _read.
	  // Note that this may be asynchronous, or synchronous.  Yes, it is
	  // deeply ugly to write APIs this way, but that still doesn't mean
	  // that the Readable class should behave improperly, as streams are
	  // designed to be sync/async agnostic.
	  // Take note if the _read call is sync or async (ie, if the read call
	  // has returned yet), so that we know whether or not it's safe to emit
	  // 'readable' etc.
	  //
	  // 3. Actually pull the requested chunks out of the buffer and return.

	  // if we need a readable event, then we need to do some reading.
	  var doRead = state.needReadable;
	  debug('need readable', doRead);

	  // if we currently have less than the highWaterMark, then also read some
	  if (state.length === 0 || state.length - n < state.highWaterMark) {
	    doRead = true;
	    debug('length less than watermark', doRead);
	  }

	  // however, if we've ended, then there's no point, and if we're already
	  // reading, then it's unnecessary.
	  if (state.ended || state.reading) {
	    doRead = false;
	    debug('reading or ended', doRead);
	  }

	  if (doRead) {
	    debug('do read');
	    state.reading = true;
	    state.sync = true;
	    // if the length is currently zero, then we *need* a readable event.
	    if (state.length === 0)
	      state.needReadable = true;
	    // call internal read method
	    this._read(state.highWaterMark);
	    state.sync = false;
	  }

	  // If _read pushed data synchronously, then `reading` will be false,
	  // and we need to re-evaluate how much data we can return to the user.
	  if (doRead && !state.reading)
	    n = howMuchToRead(nOrig, state);

	  var ret;
	  if (n > 0)
	    ret = fromList(n, state);
	  else
	    ret = null;

	  if (util.isNull(ret)) {
	    state.needReadable = true;
	    n = 0;
	  }

	  state.length -= n;

	  // If we have nothing in the buffer, then we want to know
	  // as soon as we *do* get something into the buffer.
	  if (state.length === 0 && !state.ended)
	    state.needReadable = true;

	  // If we tried to read() past the EOF, then emit end on the next tick.
	  if (nOrig !== n && state.ended && state.length === 0)
	    endReadable(this);

	  if (!util.isNull(ret))
	    this.emit('data', ret);

	  return ret;
	};

	function chunkInvalid(state, chunk) {
	  var er = null;
	  if (!util.isBuffer(chunk) &&
	      !util.isString(chunk) &&
	      !util.isNullOrUndefined(chunk) &&
	      !state.objectMode) {
	    er = new TypeError('Invalid non-string/buffer chunk');
	  }
	  return er;
	}


	function onEofChunk(stream, state) {
	  if (state.decoder && !state.ended) {
	    var chunk = state.decoder.end();
	    if (chunk && chunk.length) {
	      state.buffer.push(chunk);
	      state.length += state.objectMode ? 1 : chunk.length;
	    }
	  }
	  state.ended = true;

	  // emit 'readable' now to make sure it gets picked up.
	  emitReadable(stream);
	}

	// Don't emit readable right away in sync mode, because this can trigger
	// another read() call => stack overflow.  This way, it might trigger
	// a nextTick recursion warning, but that's not so bad.
	function emitReadable(stream) {
	  var state = stream._readableState;
	  state.needReadable = false;
	  if (!state.emittedReadable) {
	    debug('emitReadable', state.flowing);
	    state.emittedReadable = true;
	    if (state.sync)
	      process.nextTick(function() {
	        emitReadable_(stream);
	      });
	    else
	      emitReadable_(stream);
	  }
	}

	function emitReadable_(stream) {
	  debug('emit readable');
	  stream.emit('readable');
	  flow(stream);
	}


	// at this point, the user has presumably seen the 'readable' event,
	// and called read() to consume some data.  that may have triggered
	// in turn another _read(n) call, in which case reading = true if
	// it's in progress.
	// However, if we're not ended, or reading, and the length < hwm,
	// then go ahead and try to read some more preemptively.
	function maybeReadMore(stream, state) {
	  if (!state.readingMore) {
	    state.readingMore = true;
	    process.nextTick(function() {
	      maybeReadMore_(stream, state);
	    });
	  }
	}

	function maybeReadMore_(stream, state) {
	  var len = state.length;
	  while (!state.reading && !state.flowing && !state.ended &&
	         state.length < state.highWaterMark) {
	    debug('maybeReadMore read 0');
	    stream.read(0);
	    if (len === state.length)
	      // didn't get any data, stop spinning.
	      break;
	    else
	      len = state.length;
	  }
	  state.readingMore = false;
	}

	// abstract method.  to be overridden in specific implementation classes.
	// call cb(er, data) where data is <= n in length.
	// for virtual (non-string, non-buffer) streams, "length" is somewhat
	// arbitrary, and perhaps not very meaningful.
	Readable.prototype._read = function(n) {
	  this.emit('error', new Error('not implemented'));
	};

	Readable.prototype.pipe = function(dest, pipeOpts) {
	  var src = this;
	  var state = this._readableState;

	  switch (state.pipesCount) {
	    case 0:
	      state.pipes = dest;
	      break;
	    case 1:
	      state.pipes = [state.pipes, dest];
	      break;
	    default:
	      state.pipes.push(dest);
	      break;
	  }
	  state.pipesCount += 1;
	  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

	  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&
	              dest !== process.stdout &&
	              dest !== process.stderr;

	  var endFn = doEnd ? onend : cleanup;
	  if (state.endEmitted)
	    process.nextTick(endFn);
	  else
	    src.once('end', endFn);

	  dest.on('unpipe', onunpipe);
	  function onunpipe(readable) {
	    debug('onunpipe');
	    if (readable === src) {
	      cleanup();
	    }
	  }

	  function onend() {
	    debug('onend');
	    dest.end();
	  }

	  // when the dest drains, it reduces the awaitDrain counter
	  // on the source.  This would be more elegant with a .once()
	  // handler in flow(), but adding and removing repeatedly is
	  // too slow.
	  var ondrain = pipeOnDrain(src);
	  dest.on('drain', ondrain);

	  function cleanup() {
	    debug('cleanup');
	    // cleanup event handlers once the pipe is broken
	    dest.removeListener('close', onclose);
	    dest.removeListener('finish', onfinish);
	    dest.removeListener('drain', ondrain);
	    dest.removeListener('error', onerror);
	    dest.removeListener('unpipe', onunpipe);
	    src.removeListener('end', onend);
	    src.removeListener('end', cleanup);
	    src.removeListener('data', ondata);

	    // if the reader is waiting for a drain event from this
	    // specific writer, then it would cause it to never start
	    // flowing again.
	    // So, if this is awaiting a drain, then we just call it now.
	    // If we don't know, then assume that we are waiting for one.
	    if (state.awaitDrain &&
	        (!dest._writableState || dest._writableState.needDrain))
	      ondrain();
	  }

	  src.on('data', ondata);
	  function ondata(chunk) {
	    debug('ondata');
	    var ret = dest.write(chunk);
	    if (false === ret) {
	      debug('false write response, pause',
	            src._readableState.awaitDrain);
	      src._readableState.awaitDrain++;
	      src.pause();
	    }
	  }

	  // if the dest has an error, then stop piping into it.
	  // however, don't suppress the throwing behavior for this.
	  function onerror(er) {
	    debug('onerror', er);
	    unpipe();
	    dest.removeListener('error', onerror);
	    if (EE.listenerCount(dest, 'error') === 0)
	      dest.emit('error', er);
	  }
	  // This is a brutally ugly hack to make sure that our error handler
	  // is attached before any userland ones.  NEVER DO THIS.
	  if (!dest._events || !dest._events.error)
	    dest.on('error', onerror);
	  else if (isArray(dest._events.error))
	    dest._events.error.unshift(onerror);
	  else
	    dest._events.error = [onerror, dest._events.error];



	  // Both close and finish should trigger unpipe, but only once.
	  function onclose() {
	    dest.removeListener('finish', onfinish);
	    unpipe();
	  }
	  dest.once('close', onclose);
	  function onfinish() {
	    debug('onfinish');
	    dest.removeListener('close', onclose);
	    unpipe();
	  }
	  dest.once('finish', onfinish);

	  function unpipe() {
	    debug('unpipe');
	    src.unpipe(dest);
	  }

	  // tell the dest that it's being piped to
	  dest.emit('pipe', src);

	  // start the flow if it hasn't been started already.
	  if (!state.flowing) {
	    debug('pipe resume');
	    src.resume();
	  }

	  return dest;
	};

	function pipeOnDrain(src) {
	  return function() {
	    var state = src._readableState;
	    debug('pipeOnDrain', state.awaitDrain);
	    if (state.awaitDrain)
	      state.awaitDrain--;
	    if (state.awaitDrain === 0 && EE.listenerCount(src, 'data')) {
	      state.flowing = true;
	      flow(src);
	    }
	  };
	}


	Readable.prototype.unpipe = function(dest) {
	  var state = this._readableState;

	  // if we're not piping anywhere, then do nothing.
	  if (state.pipesCount === 0)
	    return this;

	  // just one destination.  most common case.
	  if (state.pipesCount === 1) {
	    // passed in one, but it's not the right one.
	    if (dest && dest !== state.pipes)
	      return this;

	    if (!dest)
	      dest = state.pipes;

	    // got a match.
	    state.pipes = null;
	    state.pipesCount = 0;
	    state.flowing = false;
	    if (dest)
	      dest.emit('unpipe', this);
	    return this;
	  }

	  // slow case. multiple pipe destinations.

	  if (!dest) {
	    // remove all.
	    var dests = state.pipes;
	    var len = state.pipesCount;
	    state.pipes = null;
	    state.pipesCount = 0;
	    state.flowing = false;

	    for (var i = 0; i < len; i++)
	      dests[i].emit('unpipe', this);
	    return this;
	  }

	  // try to find the right one.
	  var i = indexOf(state.pipes, dest);
	  if (i === -1)
	    return this;

	  state.pipes.splice(i, 1);
	  state.pipesCount -= 1;
	  if (state.pipesCount === 1)
	    state.pipes = state.pipes[0];

	  dest.emit('unpipe', this);

	  return this;
	};

	// set up data events if they are asked for
	// Ensure readable listeners eventually get something
	Readable.prototype.on = function(ev, fn) {
	  var res = Stream.prototype.on.call(this, ev, fn);

	  // If listening to data, and it has not explicitly been paused,
	  // then call resume to start the flow of data on the next tick.
	  if (ev === 'data' && false !== this._readableState.flowing) {
	    this.resume();
	  }

	  if (ev === 'readable' && this.readable) {
	    var state = this._readableState;
	    if (!state.readableListening) {
	      state.readableListening = true;
	      state.emittedReadable = false;
	      state.needReadable = true;
	      if (!state.reading) {
	        var self = this;
	        process.nextTick(function() {
	          debug('readable nexttick read 0');
	          self.read(0);
	        });
	      } else if (state.length) {
	        emitReadable(this, state);
	      }
	    }
	  }

	  return res;
	};
	Readable.prototype.addListener = Readable.prototype.on;

	// pause() and resume() are remnants of the legacy readable stream API
	// If the user uses them, then switch into old mode.
	Readable.prototype.resume = function() {
	  var state = this._readableState;
	  if (!state.flowing) {
	    debug('resume');
	    state.flowing = true;
	    if (!state.reading) {
	      debug('resume read 0');
	      this.read(0);
	    }
	    resume(this, state);
	  }
	  return this;
	};

	function resume(stream, state) {
	  if (!state.resumeScheduled) {
	    state.resumeScheduled = true;
	    process.nextTick(function() {
	      resume_(stream, state);
	    });
	  }
	}

	function resume_(stream, state) {
	  state.resumeScheduled = false;
	  stream.emit('resume');
	  flow(stream);
	  if (state.flowing && !state.reading)
	    stream.read(0);
	}

	Readable.prototype.pause = function() {
	  debug('call pause flowing=%j', this._readableState.flowing);
	  if (false !== this._readableState.flowing) {
	    debug('pause');
	    this._readableState.flowing = false;
	    this.emit('pause');
	  }
	  return this;
	};

	function flow(stream) {
	  var state = stream._readableState;
	  debug('flow', state.flowing);
	  if (state.flowing) {
	    do {
	      var chunk = stream.read();
	    } while (null !== chunk && state.flowing);
	  }
	}

	// wrap an old-style stream as the async data source.
	// This is *not* part of the readable stream interface.
	// It is an ugly unfortunate mess of history.
	Readable.prototype.wrap = function(stream) {
	  var state = this._readableState;
	  var paused = false;

	  var self = this;
	  stream.on('end', function() {
	    debug('wrapped end');
	    if (state.decoder && !state.ended) {
	      var chunk = state.decoder.end();
	      if (chunk && chunk.length)
	        self.push(chunk);
	    }

	    self.push(null);
	  });

	  stream.on('data', function(chunk) {
	    debug('wrapped data');
	    if (state.decoder)
	      chunk = state.decoder.write(chunk);
	    if (!chunk || !state.objectMode && !chunk.length)
	      return;

	    var ret = self.push(chunk);
	    if (!ret) {
	      paused = true;
	      stream.pause();
	    }
	  });

	  // proxy all the other methods.
	  // important when wrapping filters and duplexes.
	  for (var i in stream) {
	    if (util.isFunction(stream[i]) && util.isUndefined(this[i])) {
	      this[i] = function(method) { return function() {
	        return stream[method].apply(stream, arguments);
	      }}(i);
	    }
	  }

	  // proxy certain important events.
	  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
	  forEach(events, function(ev) {
	    stream.on(ev, self.emit.bind(self, ev));
	  });

	  // when we try to consume some more bytes, simply unpause the
	  // underlying stream.
	  self._read = function(n) {
	    debug('wrapped _read', n);
	    if (paused) {
	      paused = false;
	      stream.resume();
	    }
	  };

	  return self;
	};



	// exposed for testing purposes only.
	Readable._fromList = fromList;

	// Pluck off n bytes from an array of buffers.
	// Length is the combined lengths of all the buffers in the list.
	function fromList(n, state) {
	  var list = state.buffer;
	  var length = state.length;
	  var stringMode = !!state.decoder;
	  var objectMode = !!state.objectMode;
	  var ret;

	  // nothing in the list, definitely empty.
	  if (list.length === 0)
	    return null;

	  if (length === 0)
	    ret = null;
	  else if (objectMode)
	    ret = list.shift();
	  else if (!n || n >= length) {
	    // read it all, truncate the array.
	    if (stringMode)
	      ret = list.join('');
	    else
	      ret = Buffer.concat(list, length);
	    list.length = 0;
	  } else {
	    // read just some of it.
	    if (n < list[0].length) {
	      // just take a part of the first list item.
	      // slice is the same for buffers and strings.
	      var buf = list[0];
	      ret = buf.slice(0, n);
	      list[0] = buf.slice(n);
	    } else if (n === list[0].length) {
	      // first list is a perfect match
	      ret = list.shift();
	    } else {
	      // complex case.
	      // we have enough to cover it, but it spans past the first buffer.
	      if (stringMode)
	        ret = '';
	      else
	        ret = new Buffer(n);

	      var c = 0;
	      for (var i = 0, l = list.length; i < l && c < n; i++) {
	        var buf = list[0];
	        var cpy = Math.min(n - c, buf.length);

	        if (stringMode)
	          ret += buf.slice(0, cpy);
	        else
	          buf.copy(ret, c, 0, cpy);

	        if (cpy < buf.length)
	          list[0] = buf.slice(cpy);
	        else
	          list.shift();

	        c += cpy;
	      }
	    }
	  }

	  return ret;
	}

	function endReadable(stream) {
	  var state = stream._readableState;

	  // If we get here before consuming all the bytes, then that is a
	  // bug in node.  Should never happen.
	  if (state.length > 0)
	    throw new Error('endReadable called on non-empty stream');

	  if (!state.endEmitted) {
	    state.ended = true;
	    process.nextTick(function() {
	      // Check that we didn't get one last unshift.
	      if (!state.endEmitted && state.length === 0) {
	        state.endEmitted = true;
	        stream.readable = false;
	        stream.emit('end');
	      }
	    });
	  }
	}

	function forEach (xs, f) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    f(xs[i], i);
	  }
	}

	function indexOf (xs, x) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    if (xs[i] === x) return i;
	  }
	  return -1;
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 375 */
/***/ function(module, exports) {

	module.exports = Array.isArray || function (arr) {
	  return Object.prototype.toString.call(arr) == '[object Array]';
	};


/***/ },
/* 376 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	// NOTE: These type checking functions intentionally don't use `instanceof`
	// because it is fragile and can be easily faked with `Object.create()`.

	function isArray(arg) {
	  if (Array.isArray) {
	    return Array.isArray(arg);
	  }
	  return objectToString(arg) === '[object Array]';
	}
	exports.isArray = isArray;

	function isBoolean(arg) {
	  return typeof arg === 'boolean';
	}
	exports.isBoolean = isBoolean;

	function isNull(arg) {
	  return arg === null;
	}
	exports.isNull = isNull;

	function isNullOrUndefined(arg) {
	  return arg == null;
	}
	exports.isNullOrUndefined = isNullOrUndefined;

	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	exports.isNumber = isNumber;

	function isString(arg) {
	  return typeof arg === 'string';
	}
	exports.isString = isString;

	function isSymbol(arg) {
	  return typeof arg === 'symbol';
	}
	exports.isSymbol = isSymbol;

	function isUndefined(arg) {
	  return arg === void 0;
	}
	exports.isUndefined = isUndefined;

	function isRegExp(re) {
	  return objectToString(re) === '[object RegExp]';
	}
	exports.isRegExp = isRegExp;

	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	exports.isObject = isObject;

	function isDate(d) {
	  return objectToString(d) === '[object Date]';
	}
	exports.isDate = isDate;

	function isError(e) {
	  return (objectToString(e) === '[object Error]' || e instanceof Error);
	}
	exports.isError = isError;

	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	exports.isFunction = isFunction;

	function isPrimitive(arg) {
	  return arg === null ||
	         typeof arg === 'boolean' ||
	         typeof arg === 'number' ||
	         typeof arg === 'string' ||
	         typeof arg === 'symbol' ||  // ES6 symbol
	         typeof arg === 'undefined';
	}
	exports.isPrimitive = isPrimitive;

	exports.isBuffer = Buffer.isBuffer;

	function objectToString(o) {
	  return Object.prototype.toString.call(o);
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(364).Buffer))

/***/ },
/* 377 */
/***/ function(module, exports) {

	/* (ignored) */

/***/ },
/* 378 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	// a duplex stream is just a stream that is both readable and writable.
	// Since JS doesn't have multiple prototypal inheritance, this class
	// prototypally inherits from Readable, and then parasitically from
	// Writable.

	module.exports = Duplex;

	/*<replacement>*/
	var objectKeys = Object.keys || function (obj) {
	  var keys = [];
	  for (var key in obj) keys.push(key);
	  return keys;
	}
	/*</replacement>*/


	/*<replacement>*/
	var util = __webpack_require__(376);
	util.inherits = __webpack_require__(372);
	/*</replacement>*/

	var Readable = __webpack_require__(374);
	var Writable = __webpack_require__(379);

	util.inherits(Duplex, Readable);

	forEach(objectKeys(Writable.prototype), function(method) {
	  if (!Duplex.prototype[method])
	    Duplex.prototype[method] = Writable.prototype[method];
	});

	function Duplex(options) {
	  if (!(this instanceof Duplex))
	    return new Duplex(options);

	  Readable.call(this, options);
	  Writable.call(this, options);

	  if (options && options.readable === false)
	    this.readable = false;

	  if (options && options.writable === false)
	    this.writable = false;

	  this.allowHalfOpen = true;
	  if (options && options.allowHalfOpen === false)
	    this.allowHalfOpen = false;

	  this.once('end', onend);
	}

	// the no-half-open enforcer
	function onend() {
	  // if we allow half-open state, or if the writable side ended,
	  // then we're ok.
	  if (this.allowHalfOpen || this._writableState.ended)
	    return;

	  // no more data can be written.
	  // But allow more writes to happen in this tick.
	  process.nextTick(this.end.bind(this));
	}

	function forEach (xs, f) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    f(xs[i], i);
	  }
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 379 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	// A bit simpler than readable streams.
	// Implement an async ._write(chunk, cb), and it'll handle all
	// the drain event emission and buffering.

	module.exports = Writable;

	/*<replacement>*/
	var Buffer = __webpack_require__(364).Buffer;
	/*</replacement>*/

	Writable.WritableState = WritableState;


	/*<replacement>*/
	var util = __webpack_require__(376);
	util.inherits = __webpack_require__(372);
	/*</replacement>*/

	var Stream = __webpack_require__(371);

	util.inherits(Writable, Stream);

	function WriteReq(chunk, encoding, cb) {
	  this.chunk = chunk;
	  this.encoding = encoding;
	  this.callback = cb;
	}

	function WritableState(options, stream) {
	  var Duplex = __webpack_require__(378);

	  options = options || {};

	  // the point at which write() starts returning false
	  // Note: 0 is a valid value, means that we always return false if
	  // the entire buffer is not flushed immediately on write()
	  var hwm = options.highWaterMark;
	  var defaultHwm = options.objectMode ? 16 : 16 * 1024;
	  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;

	  // object stream flag to indicate whether or not this stream
	  // contains buffers or objects.
	  this.objectMode = !!options.objectMode;

	  if (stream instanceof Duplex)
	    this.objectMode = this.objectMode || !!options.writableObjectMode;

	  // cast to ints.
	  this.highWaterMark = ~~this.highWaterMark;

	  this.needDrain = false;
	  // at the start of calling end()
	  this.ending = false;
	  // when end() has been called, and returned
	  this.ended = false;
	  // when 'finish' is emitted
	  this.finished = false;

	  // should we decode strings into buffers before passing to _write?
	  // this is here so that some node-core streams can optimize string
	  // handling at a lower level.
	  var noDecode = options.decodeStrings === false;
	  this.decodeStrings = !noDecode;

	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';

	  // not an actual buffer we keep track of, but a measurement
	  // of how much we're waiting to get pushed to some underlying
	  // socket or file.
	  this.length = 0;

	  // a flag to see when we're in the middle of a write.
	  this.writing = false;

	  // when true all writes will be buffered until .uncork() call
	  this.corked = 0;

	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, because any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;

	  // a flag to know if we're processing previously buffered items, which
	  // may call the _write() callback in the same tick, so that we don't
	  // end up in an overlapped onwrite situation.
	  this.bufferProcessing = false;

	  // the callback that's passed to _write(chunk,cb)
	  this.onwrite = function(er) {
	    onwrite(stream, er);
	  };

	  // the callback that the user supplies to write(chunk,encoding,cb)
	  this.writecb = null;

	  // the amount that is being written when _write is called.
	  this.writelen = 0;

	  this.buffer = [];

	  // number of pending user-supplied write callbacks
	  // this must be 0 before 'finish' can be emitted
	  this.pendingcb = 0;

	  // emit prefinish if the only thing we're waiting for is _write cbs
	  // This is relevant for synchronous Transform streams
	  this.prefinished = false;

	  // True if the error was already emitted and should not be thrown again
	  this.errorEmitted = false;
	}

	function Writable(options) {
	  var Duplex = __webpack_require__(378);

	  // Writable ctor is applied to Duplexes, though they're not
	  // instanceof Writable, they're instanceof Readable.
	  if (!(this instanceof Writable) && !(this instanceof Duplex))
	    return new Writable(options);

	  this._writableState = new WritableState(options, this);

	  // legacy.
	  this.writable = true;

	  Stream.call(this);
	}

	// Otherwise people can pipe Writable streams, which is just wrong.
	Writable.prototype.pipe = function() {
	  this.emit('error', new Error('Cannot pipe. Not readable.'));
	};


	function writeAfterEnd(stream, state, cb) {
	  var er = new Error('write after end');
	  // TODO: defer error events consistently everywhere, not just the cb
	  stream.emit('error', er);
	  process.nextTick(function() {
	    cb(er);
	  });
	}

	// If we get something that is not a buffer, string, null, or undefined,
	// and we're not in objectMode, then that's an error.
	// Otherwise stream chunks are all considered to be of length=1, and the
	// watermarks determine how many objects to keep in the buffer, rather than
	// how many bytes or characters.
	function validChunk(stream, state, chunk, cb) {
	  var valid = true;
	  if (!util.isBuffer(chunk) &&
	      !util.isString(chunk) &&
	      !util.isNullOrUndefined(chunk) &&
	      !state.objectMode) {
	    var er = new TypeError('Invalid non-string/buffer chunk');
	    stream.emit('error', er);
	    process.nextTick(function() {
	      cb(er);
	    });
	    valid = false;
	  }
	  return valid;
	}

	Writable.prototype.write = function(chunk, encoding, cb) {
	  var state = this._writableState;
	  var ret = false;

	  if (util.isFunction(encoding)) {
	    cb = encoding;
	    encoding = null;
	  }

	  if (util.isBuffer(chunk))
	    encoding = 'buffer';
	  else if (!encoding)
	    encoding = state.defaultEncoding;

	  if (!util.isFunction(cb))
	    cb = function() {};

	  if (state.ended)
	    writeAfterEnd(this, state, cb);
	  else if (validChunk(this, state, chunk, cb)) {
	    state.pendingcb++;
	    ret = writeOrBuffer(this, state, chunk, encoding, cb);
	  }

	  return ret;
	};

	Writable.prototype.cork = function() {
	  var state = this._writableState;

	  state.corked++;
	};

	Writable.prototype.uncork = function() {
	  var state = this._writableState;

	  if (state.corked) {
	    state.corked--;

	    if (!state.writing &&
	        !state.corked &&
	        !state.finished &&
	        !state.bufferProcessing &&
	        state.buffer.length)
	      clearBuffer(this, state);
	  }
	};

	function decodeChunk(state, chunk, encoding) {
	  if (!state.objectMode &&
	      state.decodeStrings !== false &&
	      util.isString(chunk)) {
	    chunk = new Buffer(chunk, encoding);
	  }
	  return chunk;
	}

	// if we're already writing something, then just put this
	// in the queue, and wait our turn.  Otherwise, call _write
	// If we return false, then we need a drain event, so set that flag.
	function writeOrBuffer(stream, state, chunk, encoding, cb) {
	  chunk = decodeChunk(state, chunk, encoding);
	  if (util.isBuffer(chunk))
	    encoding = 'buffer';
	  var len = state.objectMode ? 1 : chunk.length;

	  state.length += len;

	  var ret = state.length < state.highWaterMark;
	  // we must ensure that previous needDrain will not be reset to false.
	  if (!ret)
	    state.needDrain = true;

	  if (state.writing || state.corked)
	    state.buffer.push(new WriteReq(chunk, encoding, cb));
	  else
	    doWrite(stream, state, false, len, chunk, encoding, cb);

	  return ret;
	}

	function doWrite(stream, state, writev, len, chunk, encoding, cb) {
	  state.writelen = len;
	  state.writecb = cb;
	  state.writing = true;
	  state.sync = true;
	  if (writev)
	    stream._writev(chunk, state.onwrite);
	  else
	    stream._write(chunk, encoding, state.onwrite);
	  state.sync = false;
	}

	function onwriteError(stream, state, sync, er, cb) {
	  if (sync)
	    process.nextTick(function() {
	      state.pendingcb--;
	      cb(er);
	    });
	  else {
	    state.pendingcb--;
	    cb(er);
	  }

	  stream._writableState.errorEmitted = true;
	  stream.emit('error', er);
	}

	function onwriteStateUpdate(state) {
	  state.writing = false;
	  state.writecb = null;
	  state.length -= state.writelen;
	  state.writelen = 0;
	}

	function onwrite(stream, er) {
	  var state = stream._writableState;
	  var sync = state.sync;
	  var cb = state.writecb;

	  onwriteStateUpdate(state);

	  if (er)
	    onwriteError(stream, state, sync, er, cb);
	  else {
	    // Check if we're actually ready to finish, but don't emit yet
	    var finished = needFinish(stream, state);

	    if (!finished &&
	        !state.corked &&
	        !state.bufferProcessing &&
	        state.buffer.length) {
	      clearBuffer(stream, state);
	    }

	    if (sync) {
	      process.nextTick(function() {
	        afterWrite(stream, state, finished, cb);
	      });
	    } else {
	      afterWrite(stream, state, finished, cb);
	    }
	  }
	}

	function afterWrite(stream, state, finished, cb) {
	  if (!finished)
	    onwriteDrain(stream, state);
	  state.pendingcb--;
	  cb();
	  finishMaybe(stream, state);
	}

	// Must force callback to be called on nextTick, so that we don't
	// emit 'drain' before the write() consumer gets the 'false' return
	// value, and has a chance to attach a 'drain' listener.
	function onwriteDrain(stream, state) {
	  if (state.length === 0 && state.needDrain) {
	    state.needDrain = false;
	    stream.emit('drain');
	  }
	}


	// if there's something in the buffer waiting, then process it
	function clearBuffer(stream, state) {
	  state.bufferProcessing = true;

	  if (stream._writev && state.buffer.length > 1) {
	    // Fast case, write everything using _writev()
	    var cbs = [];
	    for (var c = 0; c < state.buffer.length; c++)
	      cbs.push(state.buffer[c].callback);

	    // count the one we are adding, as well.
	    // TODO(isaacs) clean this up
	    state.pendingcb++;
	    doWrite(stream, state, true, state.length, state.buffer, '', function(err) {
	      for (var i = 0; i < cbs.length; i++) {
	        state.pendingcb--;
	        cbs[i](err);
	      }
	    });

	    // Clear buffer
	    state.buffer = [];
	  } else {
	    // Slow case, write chunks one-by-one
	    for (var c = 0; c < state.buffer.length; c++) {
	      var entry = state.buffer[c];
	      var chunk = entry.chunk;
	      var encoding = entry.encoding;
	      var cb = entry.callback;
	      var len = state.objectMode ? 1 : chunk.length;

	      doWrite(stream, state, false, len, chunk, encoding, cb);

	      // if we didn't call the onwrite immediately, then
	      // it means that we need to wait until it does.
	      // also, that means that the chunk and cb are currently
	      // being processed, so move the buffer counter past them.
	      if (state.writing) {
	        c++;
	        break;
	      }
	    }

	    if (c < state.buffer.length)
	      state.buffer = state.buffer.slice(c);
	    else
	      state.buffer.length = 0;
	  }

	  state.bufferProcessing = false;
	}

	Writable.prototype._write = function(chunk, encoding, cb) {
	  cb(new Error('not implemented'));

	};

	Writable.prototype._writev = null;

	Writable.prototype.end = function(chunk, encoding, cb) {
	  var state = this._writableState;

	  if (util.isFunction(chunk)) {
	    cb = chunk;
	    chunk = null;
	    encoding = null;
	  } else if (util.isFunction(encoding)) {
	    cb = encoding;
	    encoding = null;
	  }

	  if (!util.isNullOrUndefined(chunk))
	    this.write(chunk, encoding);

	  // .end() fully uncorks
	  if (state.corked) {
	    state.corked = 1;
	    this.uncork();
	  }

	  // ignore unnecessary end() calls.
	  if (!state.ending && !state.finished)
	    endWritable(this, state, cb);
	};


	function needFinish(stream, state) {
	  return (state.ending &&
	          state.length === 0 &&
	          !state.finished &&
	          !state.writing);
	}

	function prefinish(stream, state) {
	  if (!state.prefinished) {
	    state.prefinished = true;
	    stream.emit('prefinish');
	  }
	}

	function finishMaybe(stream, state) {
	  var need = needFinish(stream, state);
	  if (need) {
	    if (state.pendingcb === 0) {
	      prefinish(stream, state);
	      state.finished = true;
	      stream.emit('finish');
	    } else
	      prefinish(stream, state);
	  }
	  return need;
	}

	function endWritable(stream, state, cb) {
	  state.ending = true;
	  finishMaybe(stream, state);
	  if (cb) {
	    if (state.finished)
	      process.nextTick(cb);
	    else
	      stream.once('finish', cb);
	  }
	  state.ended = true;
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 380 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	var Buffer = __webpack_require__(364).Buffer;

	var isBufferEncoding = Buffer.isEncoding
	  || function(encoding) {
	       switch (encoding && encoding.toLowerCase()) {
	         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
	         default: return false;
	       }
	     }


	function assertEncoding(encoding) {
	  if (encoding && !isBufferEncoding(encoding)) {
	    throw new Error('Unknown encoding: ' + encoding);
	  }
	}

	// StringDecoder provides an interface for efficiently splitting a series of
	// buffers into a series of JS strings without breaking apart multi-byte
	// characters. CESU-8 is handled as part of the UTF-8 encoding.
	//
	// @TODO Handling all encodings inside a single object makes it very difficult
	// to reason about this code, so it should be split up in the future.
	// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
	// points as used by CESU-8.
	var StringDecoder = exports.StringDecoder = function(encoding) {
	  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
	  assertEncoding(encoding);
	  switch (this.encoding) {
	    case 'utf8':
	      // CESU-8 represents each of Surrogate Pair by 3-bytes
	      this.surrogateSize = 3;
	      break;
	    case 'ucs2':
	    case 'utf16le':
	      // UTF-16 represents each of Surrogate Pair by 2-bytes
	      this.surrogateSize = 2;
	      this.detectIncompleteChar = utf16DetectIncompleteChar;
	      break;
	    case 'base64':
	      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
	      this.surrogateSize = 3;
	      this.detectIncompleteChar = base64DetectIncompleteChar;
	      break;
	    default:
	      this.write = passThroughWrite;
	      return;
	  }

	  // Enough space to store all bytes of a single character. UTF-8 needs 4
	  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
	  this.charBuffer = new Buffer(6);
	  // Number of bytes received for the current incomplete multi-byte character.
	  this.charReceived = 0;
	  // Number of bytes expected for the current incomplete multi-byte character.
	  this.charLength = 0;
	};


	// write decodes the given buffer and returns it as JS string that is
	// guaranteed to not contain any partial multi-byte characters. Any partial
	// character found at the end of the buffer is buffered up, and will be
	// returned when calling write again with the remaining bytes.
	//
	// Note: Converting a Buffer containing an orphan surrogate to a String
	// currently works, but converting a String to a Buffer (via `new Buffer`, or
	// Buffer#write) will replace incomplete surrogates with the unicode
	// replacement character. See https://codereview.chromium.org/121173009/ .
	StringDecoder.prototype.write = function(buffer) {
	  var charStr = '';
	  // if our last write ended with an incomplete multibyte character
	  while (this.charLength) {
	    // determine how many remaining bytes this buffer has to offer for this char
	    var available = (buffer.length >= this.charLength - this.charReceived) ?
	        this.charLength - this.charReceived :
	        buffer.length;

	    // add the new bytes to the char buffer
	    buffer.copy(this.charBuffer, this.charReceived, 0, available);
	    this.charReceived += available;

	    if (this.charReceived < this.charLength) {
	      // still not enough chars in this buffer? wait for more ...
	      return '';
	    }

	    // remove bytes belonging to the current character from the buffer
	    buffer = buffer.slice(available, buffer.length);

	    // get the character that was split
	    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

	    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
	    var charCode = charStr.charCodeAt(charStr.length - 1);
	    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
	      this.charLength += this.surrogateSize;
	      charStr = '';
	      continue;
	    }
	    this.charReceived = this.charLength = 0;

	    // if there are no more bytes in this buffer, just emit our char
	    if (buffer.length === 0) {
	      return charStr;
	    }
	    break;
	  }

	  // determine and set charLength / charReceived
	  this.detectIncompleteChar(buffer);

	  var end = buffer.length;
	  if (this.charLength) {
	    // buffer the incomplete character bytes we got
	    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
	    end -= this.charReceived;
	  }

	  charStr += buffer.toString(this.encoding, 0, end);

	  var end = charStr.length - 1;
	  var charCode = charStr.charCodeAt(end);
	  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
	  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
	    var size = this.surrogateSize;
	    this.charLength += size;
	    this.charReceived += size;
	    this.charBuffer.copy(this.charBuffer, size, 0, size);
	    buffer.copy(this.charBuffer, 0, 0, size);
	    return charStr.substring(0, end);
	  }

	  // or just emit the charStr
	  return charStr;
	};

	// detectIncompleteChar determines if there is an incomplete UTF-8 character at
	// the end of the given buffer. If so, it sets this.charLength to the byte
	// length that character, and sets this.charReceived to the number of bytes
	// that are available for this character.
	StringDecoder.prototype.detectIncompleteChar = function(buffer) {
	  // determine how many bytes we have to check at the end of this buffer
	  var i = (buffer.length >= 3) ? 3 : buffer.length;

	  // Figure out if one of the last i bytes of our buffer announces an
	  // incomplete char.
	  for (; i > 0; i--) {
	    var c = buffer[buffer.length - i];

	    // See http://en.wikipedia.org/wiki/UTF-8#Description

	    // 110XXXXX
	    if (i == 1 && c >> 5 == 0x06) {
	      this.charLength = 2;
	      break;
	    }

	    // 1110XXXX
	    if (i <= 2 && c >> 4 == 0x0E) {
	      this.charLength = 3;
	      break;
	    }

	    // 11110XXX
	    if (i <= 3 && c >> 3 == 0x1E) {
	      this.charLength = 4;
	      break;
	    }
	  }
	  this.charReceived = i;
	};

	StringDecoder.prototype.end = function(buffer) {
	  var res = '';
	  if (buffer && buffer.length)
	    res = this.write(buffer);

	  if (this.charReceived) {
	    var cr = this.charReceived;
	    var buf = this.charBuffer;
	    var enc = this.encoding;
	    res += buf.slice(0, cr).toString(enc);
	  }

	  return res;
	};

	function passThroughWrite(buffer) {
	  return buffer.toString(this.encoding);
	}

	function utf16DetectIncompleteChar(buffer) {
	  this.charReceived = buffer.length % 2;
	  this.charLength = this.charReceived ? 2 : 0;
	}

	function base64DetectIncompleteChar(buffer) {
	  this.charReceived = buffer.length % 3;
	  this.charLength = this.charReceived ? 3 : 0;
	}


/***/ },
/* 381 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.


	// a transform stream is a readable/writable stream where you do
	// something with the data.  Sometimes it's called a "filter",
	// but that's not a great name for it, since that implies a thing where
	// some bits pass through, and others are simply ignored.  (That would
	// be a valid example of a transform, of course.)
	//
	// While the output is causally related to the input, it's not a
	// necessarily symmetric or synchronous transformation.  For example,
	// a zlib stream might take multiple plain-text writes(), and then
	// emit a single compressed chunk some time in the future.
	//
	// Here's how this works:
	//
	// The Transform stream has all the aspects of the readable and writable
	// stream classes.  When you write(chunk), that calls _write(chunk,cb)
	// internally, and returns false if there's a lot of pending writes
	// buffered up.  When you call read(), that calls _read(n) until
	// there's enough pending readable data buffered up.
	//
	// In a transform stream, the written data is placed in a buffer.  When
	// _read(n) is called, it transforms the queued up data, calling the
	// buffered _write cb's as it consumes chunks.  If consuming a single
	// written chunk would result in multiple output chunks, then the first
	// outputted bit calls the readcb, and subsequent chunks just go into
	// the read buffer, and will cause it to emit 'readable' if necessary.
	//
	// This way, back-pressure is actually determined by the reading side,
	// since _read has to be called to start processing a new chunk.  However,
	// a pathological inflate type of transform can cause excessive buffering
	// here.  For example, imagine a stream where every byte of input is
	// interpreted as an integer from 0-255, and then results in that many
	// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
	// 1kb of data being output.  In this case, you could write a very small
	// amount of input, and end up with a very large amount of output.  In
	// such a pathological inflating mechanism, there'd be no way to tell
	// the system to stop doing the transform.  A single 4MB write could
	// cause the system to run out of memory.
	//
	// However, even in such a pathological case, only a single written chunk
	// would be consumed, and then the rest would wait (un-transformed) until
	// the results of the previous transformed chunk were consumed.

	module.exports = Transform;

	var Duplex = __webpack_require__(378);

	/*<replacement>*/
	var util = __webpack_require__(376);
	util.inherits = __webpack_require__(372);
	/*</replacement>*/

	util.inherits(Transform, Duplex);


	function TransformState(options, stream) {
	  this.afterTransform = function(er, data) {
	    return afterTransform(stream, er, data);
	  };

	  this.needTransform = false;
	  this.transforming = false;
	  this.writecb = null;
	  this.writechunk = null;
	}

	function afterTransform(stream, er, data) {
	  var ts = stream._transformState;
	  ts.transforming = false;

	  var cb = ts.writecb;

	  if (!cb)
	    return stream.emit('error', new Error('no writecb in Transform class'));

	  ts.writechunk = null;
	  ts.writecb = null;

	  if (!util.isNullOrUndefined(data))
	    stream.push(data);

	  if (cb)
	    cb(er);

	  var rs = stream._readableState;
	  rs.reading = false;
	  if (rs.needReadable || rs.length < rs.highWaterMark) {
	    stream._read(rs.highWaterMark);
	  }
	}


	function Transform(options) {
	  if (!(this instanceof Transform))
	    return new Transform(options);

	  Duplex.call(this, options);

	  this._transformState = new TransformState(options, this);

	  // when the writable side finishes, then flush out anything remaining.
	  var stream = this;

	  // start out asking for a readable event once data is transformed.
	  this._readableState.needReadable = true;

	  // we have implemented the _read method, and done the other things
	  // that Readable wants before the first _read call, so unset the
	  // sync guard flag.
	  this._readableState.sync = false;

	  this.once('prefinish', function() {
	    if (util.isFunction(this._flush))
	      this._flush(function(er) {
	        done(stream, er);
	      });
	    else
	      done(stream);
	  });
	}

	Transform.prototype.push = function(chunk, encoding) {
	  this._transformState.needTransform = false;
	  return Duplex.prototype.push.call(this, chunk, encoding);
	};

	// This is the part where you do stuff!
	// override this function in implementation classes.
	// 'chunk' is an input chunk.
	//
	// Call `push(newChunk)` to pass along transformed output
	// to the readable side.  You may call 'push' zero or more times.
	//
	// Call `cb(err)` when you are done with this chunk.  If you pass
	// an error, then that'll put the hurt on the whole operation.  If you
	// never call cb(), then you'll never get another chunk.
	Transform.prototype._transform = function(chunk, encoding, cb) {
	  throw new Error('not implemented');
	};

	Transform.prototype._write = function(chunk, encoding, cb) {
	  var ts = this._transformState;
	  ts.writecb = cb;
	  ts.writechunk = chunk;
	  ts.writeencoding = encoding;
	  if (!ts.transforming) {
	    var rs = this._readableState;
	    if (ts.needTransform ||
	        rs.needReadable ||
	        rs.length < rs.highWaterMark)
	      this._read(rs.highWaterMark);
	  }
	};

	// Doesn't matter what the args are here.
	// _transform does all the work.
	// That we got here means that the readable side wants more data.
	Transform.prototype._read = function(n) {
	  var ts = this._transformState;

	  if (!util.isNull(ts.writechunk) && ts.writecb && !ts.transforming) {
	    ts.transforming = true;
	    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
	  } else {
	    // mark that we need a transform, so that any data that comes in
	    // will get processed, now that we've asked for it.
	    ts.needTransform = true;
	  }
	};


	function done(stream, er) {
	  if (er)
	    return stream.emit('error', er);

	  // if there's nothing in the write buffer, then that means
	  // that nothing more will ever be provided
	  var ws = stream._writableState;
	  var ts = stream._transformState;

	  if (ws.length)
	    throw new Error('calling transform done when ws.length != 0');

	  if (ts.transforming)
	    throw new Error('calling transform done when still transforming');

	  return stream.push(null);
	}


/***/ },
/* 382 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	// a passthrough stream.
	// basically just the most minimal sort of Transform stream.
	// Every written chunk gets output as-is.

	module.exports = PassThrough;

	var Transform = __webpack_require__(381);

	/*<replacement>*/
	var util = __webpack_require__(376);
	util.inherits = __webpack_require__(372);
	/*</replacement>*/

	util.inherits(PassThrough, Transform);

	function PassThrough(options) {
	  if (!(this instanceof PassThrough))
	    return new PassThrough(options);

	  Transform.call(this, options);
	}

	PassThrough.prototype._transform = function(chunk, encoding, cb) {
	  cb(null, chunk);
	};


/***/ },
/* 383 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(379)


/***/ },
/* 384 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(378)


/***/ },
/* 385 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(381)


/***/ },
/* 386 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(382)


/***/ },
/* 387 */
/***/ function(module, exports, __webpack_require__) {

	var Stream = __webpack_require__(371);
	var util = __webpack_require__(3);

	var Response = module.exports = function (res) {
	    this.offset = 0;
	    this.readable = true;
	};

	util.inherits(Response, Stream);

	var capable = {
	    streaming : true,
	    status2 : true
	};

	function parseHeaders (res) {
	    var lines = res.getAllResponseHeaders().split(/\r?\n/);
	    var headers = {};
	    for (var i = 0; i < lines.length; i++) {
	        var line = lines[i];
	        if (line === '') continue;
	        
	        var m = line.match(/^([^:]+):\s*(.*)/);
	        if (m) {
	            var key = m[1].toLowerCase(), value = m[2];
	            
	            if (headers[key] !== undefined) {
	            
	                if (isArray(headers[key])) {
	                    headers[key].push(value);
	                }
	                else {
	                    headers[key] = [ headers[key], value ];
	                }
	            }
	            else {
	                headers[key] = value;
	            }
	        }
	        else {
	            headers[line] = true;
	        }
	    }
	    return headers;
	}

	Response.prototype.getResponse = function (xhr) {
	    var respType = String(xhr.responseType).toLowerCase();
	    if (respType === 'blob') return xhr.responseBlob || xhr.response;
	    if (respType === 'arraybuffer') return xhr.response;
	    return xhr.responseText;
	}

	Response.prototype.getHeader = function (key) {
	    return this.headers[key.toLowerCase()];
	};

	Response.prototype.handle = function (res) {
	    if (res.readyState === 2 && capable.status2) {
	        try {
	            this.statusCode = res.status;
	            this.headers = parseHeaders(res);
	        }
	        catch (err) {
	            capable.status2 = false;
	        }
	        
	        if (capable.status2) {
	            this.emit('ready');
	        }
	    }
	    else if (capable.streaming && res.readyState === 3) {
	        try {
	            if (!this.statusCode) {
	                this.statusCode = res.status;
	                this.headers = parseHeaders(res);
	                this.emit('ready');
	            }
	        }
	        catch (err) {}
	        
	        try {
	            this._emitData(res);
	        }
	        catch (err) {
	            capable.streaming = false;
	        }
	    }
	    else if (res.readyState === 4) {
	        if (!this.statusCode) {
	            this.statusCode = res.status;
	            this.emit('ready');
	        }
	        this._emitData(res);
	        
	        if (res.error) {
	            this.emit('error', this.getResponse(res));
	        }
	        else this.emit('end');
	        
	        this.emit('close');
	    }
	};

	Response.prototype._emitData = function (res) {
	    var respBody = this.getResponse(res);
	    if (respBody.toString().match(/ArrayBuffer/)) {
	        this.emit('data', new Uint8Array(respBody, this.offset));
	        this.offset = respBody.byteLength;
	        return;
	    }
	    if (respBody.length > this.offset) {
	        this.emit('data', respBody.slice(this.offset));
	        this.offset = respBody.length;
	    }
	};

	var isArray = Array.isArray || function (xs) {
	    return Object.prototype.toString.call(xs) === '[object Array]';
	};


/***/ },
/* 388 */
/***/ function(module, exports, __webpack_require__) {

	;(function () {

	  var object =  true ? exports : this; // #8: web workers
	  var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

	  function InvalidCharacterError(message) {
	    this.message = message;
	  }
	  InvalidCharacterError.prototype = new Error;
	  InvalidCharacterError.prototype.name = 'InvalidCharacterError';

	  // encoder
	  // [https://gist.github.com/999166] by [https://github.com/nignag]
	  object.btoa || (
	  object.btoa = function (input) {
	    for (
	      // initialize result and counter
	      var block, charCode, idx = 0, map = chars, output = '';
	      // if the next input index does not exist:
	      //   change the mapping table to "="
	      //   check if d has no fractional digits
	      input.charAt(idx | 0) || (map = '=', idx % 1);
	      // "8 - idx % 1 * 8" generates the sequence 2, 4, 6, 8
	      output += map.charAt(63 & block >> 8 - idx % 1 * 8)
	    ) {
	      charCode = input.charCodeAt(idx += 3/4);
	      if (charCode > 0xFF) {
	        throw new InvalidCharacterError("'btoa' failed: The string to be encoded contains characters outside of the Latin1 range.");
	      }
	      block = block << 8 | charCode;
	    }
	    return output;
	  });

	  // decoder
	  // [https://gist.github.com/1020396] by [https://github.com/atk]
	  object.atob || (
	  object.atob = function (input) {
	    input = input.replace(/=+$/, '');
	    if (input.length % 4 == 1) {
	      throw new InvalidCharacterError("'atob' failed: The string to be decoded is not correctly encoded.");
	    }
	    for (
	      // initialize result and counters
	      var bc = 0, bs, buffer, idx = 0, output = '';
	      // get next character
	      buffer = input.charAt(idx++);
	      // character found in table? initialize bit storage and add its ascii value;
	      ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer,
	        // and if not first of each 4 characters,
	        // convert the first 8 bits to one ascii character
	        bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0
	    ) {
	      // try to find character in table (0-63, not found => -1)
	      buffer = chars.indexOf(buffer);
	    }
	    return output;
	  });

	}());


/***/ },
/* 389 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	var punycode = __webpack_require__(390);

	exports.parse = urlParse;
	exports.resolve = urlResolve;
	exports.resolveObject = urlResolveObject;
	exports.format = urlFormat;

	exports.Url = Url;

	function Url() {
	  this.protocol = null;
	  this.slashes = null;
	  this.auth = null;
	  this.host = null;
	  this.port = null;
	  this.hostname = null;
	  this.hash = null;
	  this.search = null;
	  this.query = null;
	  this.pathname = null;
	  this.path = null;
	  this.href = null;
	}

	// Reference: RFC 3986, RFC 1808, RFC 2396

	// define these here so at least they only have to be
	// compiled once on the first module load.
	var protocolPattern = /^([a-z0-9.+-]+:)/i,
	    portPattern = /:[0-9]*$/,

	    // RFC 2396: characters reserved for delimiting URLs.
	    // We actually just auto-escape these.
	    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

	    // RFC 2396: characters not allowed for various reasons.
	    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

	    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
	    autoEscape = ['\''].concat(unwise),
	    // Characters that are never ever allowed in a hostname.
	    // Note that any invalid chars are also handled, but these
	    // are the ones that are *expected* to be seen, so we fast-path
	    // them.
	    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
	    hostEndingChars = ['/', '?', '#'],
	    hostnameMaxLen = 255,
	    hostnamePartPattern = /^[a-z0-9A-Z_-]{0,63}$/,
	    hostnamePartStart = /^([a-z0-9A-Z_-]{0,63})(.*)$/,
	    // protocols that can allow "unsafe" and "unwise" chars.
	    unsafeProtocol = {
	      'javascript': true,
	      'javascript:': true
	    },
	    // protocols that never have a hostname.
	    hostlessProtocol = {
	      'javascript': true,
	      'javascript:': true
	    },
	    // protocols that always contain a // bit.
	    slashedProtocol = {
	      'http': true,
	      'https': true,
	      'ftp': true,
	      'gopher': true,
	      'file': true,
	      'http:': true,
	      'https:': true,
	      'ftp:': true,
	      'gopher:': true,
	      'file:': true
	    },
	    querystring = __webpack_require__(391);

	function urlParse(url, parseQueryString, slashesDenoteHost) {
	  if (url && isObject(url) && url instanceof Url) return url;

	  var u = new Url;
	  u.parse(url, parseQueryString, slashesDenoteHost);
	  return u;
	}

	Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
	  if (!isString(url)) {
	    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
	  }

	  var rest = url;

	  // trim before proceeding.
	  // This is to support parse stuff like "  http://foo.com  \n"
	  rest = rest.trim();

	  var proto = protocolPattern.exec(rest);
	  if (proto) {
	    proto = proto[0];
	    var lowerProto = proto.toLowerCase();
	    this.protocol = lowerProto;
	    rest = rest.substr(proto.length);
	  }

	  // figure out if it's got a host
	  // user@server is *always* interpreted as a hostname, and url
	  // resolution will treat //foo/bar as host=foo,path=bar because that's
	  // how the browser resolves relative URLs.
	  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
	    var slashes = rest.substr(0, 2) === '//';
	    if (slashes && !(proto && hostlessProtocol[proto])) {
	      rest = rest.substr(2);
	      this.slashes = true;
	    }
	  }

	  if (!hostlessProtocol[proto] &&
	      (slashes || (proto && !slashedProtocol[proto]))) {

	    // there's a hostname.
	    // the first instance of /, ?, ;, or # ends the host.
	    //
	    // If there is an @ in the hostname, then non-host chars *are* allowed
	    // to the left of the last @ sign, unless some host-ending character
	    // comes *before* the @-sign.
	    // URLs are obnoxious.
	    //
	    // ex:
	    // http://a@b@c/ => user:a@b host:c
	    // http://a@b?@c => user:a host:c path:/?@c

	    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
	    // Review our test case against browsers more comprehensively.

	    // find the first instance of any hostEndingChars
	    var hostEnd = -1;
	    for (var i = 0; i < hostEndingChars.length; i++) {
	      var hec = rest.indexOf(hostEndingChars[i]);
	      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
	        hostEnd = hec;
	    }

	    // at this point, either we have an explicit point where the
	    // auth portion cannot go past, or the last @ char is the decider.
	    var auth, atSign;
	    if (hostEnd === -1) {
	      // atSign can be anywhere.
	      atSign = rest.lastIndexOf('@');
	    } else {
	      // atSign must be in auth portion.
	      // http://a@b/c@d => host:b auth:a path:/c@d
	      atSign = rest.lastIndexOf('@', hostEnd);
	    }

	    // Now we have a portion which is definitely the auth.
	    // Pull that off.
	    if (atSign !== -1) {
	      auth = rest.slice(0, atSign);
	      rest = rest.slice(atSign + 1);
	      this.auth = decodeURIComponent(auth);
	    }

	    // the host is the remaining to the left of the first non-host char
	    hostEnd = -1;
	    for (var i = 0; i < nonHostChars.length; i++) {
	      var hec = rest.indexOf(nonHostChars[i]);
	      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
	        hostEnd = hec;
	    }
	    // if we still have not hit it, then the entire thing is a host.
	    if (hostEnd === -1)
	      hostEnd = rest.length;

	    this.host = rest.slice(0, hostEnd);
	    rest = rest.slice(hostEnd);

	    // pull out port.
	    this.parseHost();

	    // we've indicated that there is a hostname,
	    // so even if it's empty, it has to be present.
	    this.hostname = this.hostname || '';

	    // if hostname begins with [ and ends with ]
	    // assume that it's an IPv6 address.
	    var ipv6Hostname = this.hostname[0] === '[' &&
	        this.hostname[this.hostname.length - 1] === ']';

	    // validate a little.
	    if (!ipv6Hostname) {
	      var hostparts = this.hostname.split(/\./);
	      for (var i = 0, l = hostparts.length; i < l; i++) {
	        var part = hostparts[i];
	        if (!part) continue;
	        if (!part.match(hostnamePartPattern)) {
	          var newpart = '';
	          for (var j = 0, k = part.length; j < k; j++) {
	            if (part.charCodeAt(j) > 127) {
	              // we replace non-ASCII char with a temporary placeholder
	              // we need this to make sure size of hostname is not
	              // broken by replacing non-ASCII by nothing
	              newpart += 'x';
	            } else {
	              newpart += part[j];
	            }
	          }
	          // we test again with ASCII char only
	          if (!newpart.match(hostnamePartPattern)) {
	            var validParts = hostparts.slice(0, i);
	            var notHost = hostparts.slice(i + 1);
	            var bit = part.match(hostnamePartStart);
	            if (bit) {
	              validParts.push(bit[1]);
	              notHost.unshift(bit[2]);
	            }
	            if (notHost.length) {
	              rest = '/' + notHost.join('.') + rest;
	            }
	            this.hostname = validParts.join('.');
	            break;
	          }
	        }
	      }
	    }

	    if (this.hostname.length > hostnameMaxLen) {
	      this.hostname = '';
	    } else {
	      // hostnames are always lower case.
	      this.hostname = this.hostname.toLowerCase();
	    }

	    if (!ipv6Hostname) {
	      // IDNA Support: Returns a puny coded representation of "domain".
	      // It only converts the part of the domain name that
	      // has non ASCII characters. I.e. it dosent matter if
	      // you call it with a domain that already is in ASCII.
	      var domainArray = this.hostname.split('.');
	      var newOut = [];
	      for (var i = 0; i < domainArray.length; ++i) {
	        var s = domainArray[i];
	        newOut.push(s.match(/[^A-Za-z0-9_-]/) ?
	            'xn--' + punycode.encode(s) : s);
	      }
	      this.hostname = newOut.join('.');
	    }

	    var p = this.port ? ':' + this.port : '';
	    var h = this.hostname || '';
	    this.host = h + p;
	    this.href += this.host;

	    // strip [ and ] from the hostname
	    // the host field still retains them, though
	    if (ipv6Hostname) {
	      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
	      if (rest[0] !== '/') {
	        rest = '/' + rest;
	      }
	    }
	  }

	  // now rest is set to the post-host stuff.
	  // chop off any delim chars.
	  if (!unsafeProtocol[lowerProto]) {

	    // First, make 100% sure that any "autoEscape" chars get
	    // escaped, even if encodeURIComponent doesn't think they
	    // need to be.
	    for (var i = 0, l = autoEscape.length; i < l; i++) {
	      var ae = autoEscape[i];
	      var esc = encodeURIComponent(ae);
	      if (esc === ae) {
	        esc = escape(ae);
	      }
	      rest = rest.split(ae).join(esc);
	    }
	  }


	  // chop off from the tail first.
	  var hash = rest.indexOf('#');
	  if (hash !== -1) {
	    // got a fragment string.
	    this.hash = rest.substr(hash);
	    rest = rest.slice(0, hash);
	  }
	  var qm = rest.indexOf('?');
	  if (qm !== -1) {
	    this.search = rest.substr(qm);
	    this.query = rest.substr(qm + 1);
	    if (parseQueryString) {
	      this.query = querystring.parse(this.query);
	    }
	    rest = rest.slice(0, qm);
	  } else if (parseQueryString) {
	    // no query string, but parseQueryString still requested
	    this.search = '';
	    this.query = {};
	  }
	  if (rest) this.pathname = rest;
	  if (slashedProtocol[lowerProto] &&
	      this.hostname && !this.pathname) {
	    this.pathname = '/';
	  }

	  //to support http.request
	  if (this.pathname || this.search) {
	    var p = this.pathname || '';
	    var s = this.search || '';
	    this.path = p + s;
	  }

	  // finally, reconstruct the href based on what has been validated.
	  this.href = this.format();
	  return this;
	};

	// format a parsed object into a url string
	function urlFormat(obj) {
	  // ensure it's an object, and not a string url.
	  // If it's an obj, this is a no-op.
	  // this way, you can call url_format() on strings
	  // to clean up potentially wonky urls.
	  if (isString(obj)) obj = urlParse(obj);
	  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
	  return obj.format();
	}

	Url.prototype.format = function() {
	  var auth = this.auth || '';
	  if (auth) {
	    auth = encodeURIComponent(auth);
	    auth = auth.replace(/%3A/i, ':');
	    auth += '@';
	  }

	  var protocol = this.protocol || '',
	      pathname = this.pathname || '',
	      hash = this.hash || '',
	      host = false,
	      query = '';

	  if (this.host) {
	    host = auth + this.host;
	  } else if (this.hostname) {
	    host = auth + (this.hostname.indexOf(':') === -1 ?
	        this.hostname :
	        '[' + this.hostname + ']');
	    if (this.port) {
	      host += ':' + this.port;
	    }
	  }

	  if (this.query &&
	      isObject(this.query) &&
	      Object.keys(this.query).length) {
	    query = querystring.stringify(this.query);
	  }

	  var search = this.search || (query && ('?' + query)) || '';

	  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

	  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
	  // unless they had them to begin with.
	  if (this.slashes ||
	      (!protocol || slashedProtocol[protocol]) && host !== false) {
	    host = '//' + (host || '');
	    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
	  } else if (!host) {
	    host = '';
	  }

	  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
	  if (search && search.charAt(0) !== '?') search = '?' + search;

	  pathname = pathname.replace(/[?#]/g, function(match) {
	    return encodeURIComponent(match);
	  });
	  search = search.replace('#', '%23');

	  return protocol + host + pathname + search + hash;
	};

	function urlResolve(source, relative) {
	  return urlParse(source, false, true).resolve(relative);
	}

	Url.prototype.resolve = function(relative) {
	  return this.resolveObject(urlParse(relative, false, true)).format();
	};

	function urlResolveObject(source, relative) {
	  if (!source) return relative;
	  return urlParse(source, false, true).resolveObject(relative);
	}

	Url.prototype.resolveObject = function(relative) {
	  if (isString(relative)) {
	    var rel = new Url();
	    rel.parse(relative, false, true);
	    relative = rel;
	  }

	  var result = new Url();
	  Object.keys(this).forEach(function(k) {
	    result[k] = this[k];
	  }, this);

	  // hash is always overridden, no matter what.
	  // even href="" will remove it.
	  result.hash = relative.hash;

	  // if the relative url is empty, then there's nothing left to do here.
	  if (relative.href === '') {
	    result.href = result.format();
	    return result;
	  }

	  // hrefs like //foo/bar always cut to the protocol.
	  if (relative.slashes && !relative.protocol) {
	    // take everything except the protocol from relative
	    Object.keys(relative).forEach(function(k) {
	      if (k !== 'protocol')
	        result[k] = relative[k];
	    });

	    //urlParse appends trailing / to urls like http://www.example.com
	    if (slashedProtocol[result.protocol] &&
	        result.hostname && !result.pathname) {
	      result.path = result.pathname = '/';
	    }

	    result.href = result.format();
	    return result;
	  }

	  if (relative.protocol && relative.protocol !== result.protocol) {
	    // if it's a known url protocol, then changing
	    // the protocol does weird things
	    // first, if it's not file:, then we MUST have a host,
	    // and if there was a path
	    // to begin with, then we MUST have a path.
	    // if it is file:, then the host is dropped,
	    // because that's known to be hostless.
	    // anything else is assumed to be absolute.
	    if (!slashedProtocol[relative.protocol]) {
	      Object.keys(relative).forEach(function(k) {
	        result[k] = relative[k];
	      });
	      result.href = result.format();
	      return result;
	    }

	    result.protocol = relative.protocol;
	    if (!relative.host && !hostlessProtocol[relative.protocol]) {
	      var relPath = (relative.pathname || '').split('/');
	      while (relPath.length && !(relative.host = relPath.shift()));
	      if (!relative.host) relative.host = '';
	      if (!relative.hostname) relative.hostname = '';
	      if (relPath[0] !== '') relPath.unshift('');
	      if (relPath.length < 2) relPath.unshift('');
	      result.pathname = relPath.join('/');
	    } else {
	      result.pathname = relative.pathname;
	    }
	    result.search = relative.search;
	    result.query = relative.query;
	    result.host = relative.host || '';
	    result.auth = relative.auth;
	    result.hostname = relative.hostname || relative.host;
	    result.port = relative.port;
	    // to support http.request
	    if (result.pathname || result.search) {
	      var p = result.pathname || '';
	      var s = result.search || '';
	      result.path = p + s;
	    }
	    result.slashes = result.slashes || relative.slashes;
	    result.href = result.format();
	    return result;
	  }

	  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
	      isRelAbs = (
	          relative.host ||
	          relative.pathname && relative.pathname.charAt(0) === '/'
	      ),
	      mustEndAbs = (isRelAbs || isSourceAbs ||
	                    (result.host && relative.pathname)),
	      removeAllDots = mustEndAbs,
	      srcPath = result.pathname && result.pathname.split('/') || [],
	      relPath = relative.pathname && relative.pathname.split('/') || [],
	      psychotic = result.protocol && !slashedProtocol[result.protocol];

	  // if the url is a non-slashed url, then relative
	  // links like ../.. should be able
	  // to crawl up to the hostname, as well.  This is strange.
	  // result.protocol has already been set by now.
	  // Later on, put the first path part into the host field.
	  if (psychotic) {
	    result.hostname = '';
	    result.port = null;
	    if (result.host) {
	      if (srcPath[0] === '') srcPath[0] = result.host;
	      else srcPath.unshift(result.host);
	    }
	    result.host = '';
	    if (relative.protocol) {
	      relative.hostname = null;
	      relative.port = null;
	      if (relative.host) {
	        if (relPath[0] === '') relPath[0] = relative.host;
	        else relPath.unshift(relative.host);
	      }
	      relative.host = null;
	    }
	    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
	  }

	  if (isRelAbs) {
	    // it's absolute.
	    result.host = (relative.host || relative.host === '') ?
	                  relative.host : result.host;
	    result.hostname = (relative.hostname || relative.hostname === '') ?
	                      relative.hostname : result.hostname;
	    result.search = relative.search;
	    result.query = relative.query;
	    srcPath = relPath;
	    // fall through to the dot-handling below.
	  } else if (relPath.length) {
	    // it's relative
	    // throw away the existing file, and take the new path instead.
	    if (!srcPath) srcPath = [];
	    srcPath.pop();
	    srcPath = srcPath.concat(relPath);
	    result.search = relative.search;
	    result.query = relative.query;
	  } else if (!isNullOrUndefined(relative.search)) {
	    // just pull out the search.
	    // like href='?foo'.
	    // Put this after the other two cases because it simplifies the booleans
	    if (psychotic) {
	      result.hostname = result.host = srcPath.shift();
	      //occationaly the auth can get stuck only in host
	      //this especialy happens in cases like
	      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
	      var authInHost = result.host && result.host.indexOf('@') > 0 ?
	                       result.host.split('@') : false;
	      if (authInHost) {
	        result.auth = authInHost.shift();
	        result.host = result.hostname = authInHost.shift();
	      }
	    }
	    result.search = relative.search;
	    result.query = relative.query;
	    //to support http.request
	    if (!isNull(result.pathname) || !isNull(result.search)) {
	      result.path = (result.pathname ? result.pathname : '') +
	                    (result.search ? result.search : '');
	    }
	    result.href = result.format();
	    return result;
	  }

	  if (!srcPath.length) {
	    // no path at all.  easy.
	    // we've already handled the other stuff above.
	    result.pathname = null;
	    //to support http.request
	    if (result.search) {
	      result.path = '/' + result.search;
	    } else {
	      result.path = null;
	    }
	    result.href = result.format();
	    return result;
	  }

	  // if a url ENDs in . or .., then it must get a trailing slash.
	  // however, if it ends in anything else non-slashy,
	  // then it must NOT get a trailing slash.
	  var last = srcPath.slice(-1)[0];
	  var hasTrailingSlash = (
	      (result.host || relative.host) && (last === '.' || last === '..') ||
	      last === '');

	  // strip single dots, resolve double dots to parent dir
	  // if the path tries to go above the root, `up` ends up > 0
	  var up = 0;
	  for (var i = srcPath.length; i >= 0; i--) {
	    last = srcPath[i];
	    if (last == '.') {
	      srcPath.splice(i, 1);
	    } else if (last === '..') {
	      srcPath.splice(i, 1);
	      up++;
	    } else if (up) {
	      srcPath.splice(i, 1);
	      up--;
	    }
	  }

	  // if the path is allowed to go above the root, restore leading ..s
	  if (!mustEndAbs && !removeAllDots) {
	    for (; up--; up) {
	      srcPath.unshift('..');
	    }
	  }

	  if (mustEndAbs && srcPath[0] !== '' &&
	      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
	    srcPath.unshift('');
	  }

	  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
	    srcPath.push('');
	  }

	  var isAbsolute = srcPath[0] === '' ||
	      (srcPath[0] && srcPath[0].charAt(0) === '/');

	  // put the host back
	  if (psychotic) {
	    result.hostname = result.host = isAbsolute ? '' :
	                                    srcPath.length ? srcPath.shift() : '';
	    //occationaly the auth can get stuck only in host
	    //this especialy happens in cases like
	    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
	    var authInHost = result.host && result.host.indexOf('@') > 0 ?
	                     result.host.split('@') : false;
	    if (authInHost) {
	      result.auth = authInHost.shift();
	      result.host = result.hostname = authInHost.shift();
	    }
	  }

	  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

	  if (mustEndAbs && !isAbsolute) {
	    srcPath.unshift('');
	  }

	  if (!srcPath.length) {
	    result.pathname = null;
	    result.path = null;
	  } else {
	    result.pathname = srcPath.join('/');
	  }

	  //to support request.http
	  if (!isNull(result.pathname) || !isNull(result.search)) {
	    result.path = (result.pathname ? result.pathname : '') +
	                  (result.search ? result.search : '');
	  }
	  result.auth = relative.auth || result.auth;
	  result.slashes = result.slashes || relative.slashes;
	  result.href = result.format();
	  return result;
	};

	Url.prototype.parseHost = function() {
	  var host = this.host;
	  var port = portPattern.exec(host);
	  if (port) {
	    port = port[0];
	    if (port !== ':') {
	      this.port = port.substr(1);
	    }
	    host = host.substr(0, host.length - port.length);
	  }
	  if (host) this.hostname = host;
	};

	function isString(arg) {
	  return typeof arg === "string";
	}

	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}

	function isNull(arg) {
	  return arg === null;
	}
	function isNullOrUndefined(arg) {
	  return  arg == null;
	}


/***/ },
/* 390 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {/*! https://mths.be/punycode v1.3.2 by @mathias */
	;(function(root) {

		/** Detect free variables */
		var freeExports = typeof exports == 'object' && exports &&
			!exports.nodeType && exports;
		var freeModule = typeof module == 'object' && module &&
			!module.nodeType && module;
		var freeGlobal = typeof global == 'object' && global;
		if (
			freeGlobal.global === freeGlobal ||
			freeGlobal.window === freeGlobal ||
			freeGlobal.self === freeGlobal
		) {
			root = freeGlobal;
		}

		/**
		 * The `punycode` object.
		 * @name punycode
		 * @type Object
		 */
		var punycode,

		/** Highest positive signed 32-bit float value */
		maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

		/** Bootstring parameters */
		base = 36,
		tMin = 1,
		tMax = 26,
		skew = 38,
		damp = 700,
		initialBias = 72,
		initialN = 128, // 0x80
		delimiter = '-', // '\x2D'

		/** Regular expressions */
		regexPunycode = /^xn--/,
		regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
		regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

		/** Error messages */
		errors = {
			'overflow': 'Overflow: input needs wider integers to process',
			'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
			'invalid-input': 'Invalid input'
		},

		/** Convenience shortcuts */
		baseMinusTMin = base - tMin,
		floor = Math.floor,
		stringFromCharCode = String.fromCharCode,

		/** Temporary variable */
		key;

		/*--------------------------------------------------------------------------*/

		/**
		 * A generic error utility function.
		 * @private
		 * @param {String} type The error type.
		 * @returns {Error} Throws a `RangeError` with the applicable error message.
		 */
		function error(type) {
			throw RangeError(errors[type]);
		}

		/**
		 * A generic `Array#map` utility function.
		 * @private
		 * @param {Array} array The array to iterate over.
		 * @param {Function} callback The function that gets called for every array
		 * item.
		 * @returns {Array} A new array of values returned by the callback function.
		 */
		function map(array, fn) {
			var length = array.length;
			var result = [];
			while (length--) {
				result[length] = fn(array[length]);
			}
			return result;
		}

		/**
		 * A simple `Array#map`-like wrapper to work with domain name strings or email
		 * addresses.
		 * @private
		 * @param {String} domain The domain name or email address.
		 * @param {Function} callback The function that gets called for every
		 * character.
		 * @returns {Array} A new string of characters returned by the callback
		 * function.
		 */
		function mapDomain(string, fn) {
			var parts = string.split('@');
			var result = '';
			if (parts.length > 1) {
				// In email addresses, only the domain name should be punycoded. Leave
				// the local part (i.e. everything up to `@`) intact.
				result = parts[0] + '@';
				string = parts[1];
			}
			// Avoid `split(regex)` for IE8 compatibility. See #17.
			string = string.replace(regexSeparators, '\x2E');
			var labels = string.split('.');
			var encoded = map(labels, fn).join('.');
			return result + encoded;
		}

		/**
		 * Creates an array containing the numeric code points of each Unicode
		 * character in the string. While JavaScript uses UCS-2 internally,
		 * this function will convert a pair of surrogate halves (each of which
		 * UCS-2 exposes as separate characters) into a single code point,
		 * matching UTF-16.
		 * @see `punycode.ucs2.encode`
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode.ucs2
		 * @name decode
		 * @param {String} string The Unicode input string (UCS-2).
		 * @returns {Array} The new array of code points.
		 */
		function ucs2decode(string) {
			var output = [],
			    counter = 0,
			    length = string.length,
			    value,
			    extra;
			while (counter < length) {
				value = string.charCodeAt(counter++);
				if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
					// high surrogate, and there is a next character
					extra = string.charCodeAt(counter++);
					if ((extra & 0xFC00) == 0xDC00) { // low surrogate
						output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
					} else {
						// unmatched surrogate; only append this code unit, in case the next
						// code unit is the high surrogate of a surrogate pair
						output.push(value);
						counter--;
					}
				} else {
					output.push(value);
				}
			}
			return output;
		}

		/**
		 * Creates a string based on an array of numeric code points.
		 * @see `punycode.ucs2.decode`
		 * @memberOf punycode.ucs2
		 * @name encode
		 * @param {Array} codePoints The array of numeric code points.
		 * @returns {String} The new Unicode string (UCS-2).
		 */
		function ucs2encode(array) {
			return map(array, function(value) {
				var output = '';
				if (value > 0xFFFF) {
					value -= 0x10000;
					output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
					value = 0xDC00 | value & 0x3FF;
				}
				output += stringFromCharCode(value);
				return output;
			}).join('');
		}

		/**
		 * Converts a basic code point into a digit/integer.
		 * @see `digitToBasic()`
		 * @private
		 * @param {Number} codePoint The basic numeric code point value.
		 * @returns {Number} The numeric value of a basic code point (for use in
		 * representing integers) in the range `0` to `base - 1`, or `base` if
		 * the code point does not represent a value.
		 */
		function basicToDigit(codePoint) {
			if (codePoint - 48 < 10) {
				return codePoint - 22;
			}
			if (codePoint - 65 < 26) {
				return codePoint - 65;
			}
			if (codePoint - 97 < 26) {
				return codePoint - 97;
			}
			return base;
		}

		/**
		 * Converts a digit/integer into a basic code point.
		 * @see `basicToDigit()`
		 * @private
		 * @param {Number} digit The numeric value of a basic code point.
		 * @returns {Number} The basic code point whose value (when used for
		 * representing integers) is `digit`, which needs to be in the range
		 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
		 * used; else, the lowercase form is used. The behavior is undefined
		 * if `flag` is non-zero and `digit` has no uppercase form.
		 */
		function digitToBasic(digit, flag) {
			//  0..25 map to ASCII a..z or A..Z
			// 26..35 map to ASCII 0..9
			return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
		}

		/**
		 * Bias adaptation function as per section 3.4 of RFC 3492.
		 * http://tools.ietf.org/html/rfc3492#section-3.4
		 * @private
		 */
		function adapt(delta, numPoints, firstTime) {
			var k = 0;
			delta = firstTime ? floor(delta / damp) : delta >> 1;
			delta += floor(delta / numPoints);
			for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
				delta = floor(delta / baseMinusTMin);
			}
			return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
		}

		/**
		 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
		 * symbols.
		 * @memberOf punycode
		 * @param {String} input The Punycode string of ASCII-only symbols.
		 * @returns {String} The resulting string of Unicode symbols.
		 */
		function decode(input) {
			// Don't use UCS-2
			var output = [],
			    inputLength = input.length,
			    out,
			    i = 0,
			    n = initialN,
			    bias = initialBias,
			    basic,
			    j,
			    index,
			    oldi,
			    w,
			    k,
			    digit,
			    t,
			    /** Cached calculation results */
			    baseMinusT;

			// Handle the basic code points: let `basic` be the number of input code
			// points before the last delimiter, or `0` if there is none, then copy
			// the first basic code points to the output.

			basic = input.lastIndexOf(delimiter);
			if (basic < 0) {
				basic = 0;
			}

			for (j = 0; j < basic; ++j) {
				// if it's not a basic code point
				if (input.charCodeAt(j) >= 0x80) {
					error('not-basic');
				}
				output.push(input.charCodeAt(j));
			}

			// Main decoding loop: start just after the last delimiter if any basic code
			// points were copied; start at the beginning otherwise.

			for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

				// `index` is the index of the next character to be consumed.
				// Decode a generalized variable-length integer into `delta`,
				// which gets added to `i`. The overflow checking is easier
				// if we increase `i` as we go, then subtract off its starting
				// value at the end to obtain `delta`.
				for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

					if (index >= inputLength) {
						error('invalid-input');
					}

					digit = basicToDigit(input.charCodeAt(index++));

					if (digit >= base || digit > floor((maxInt - i) / w)) {
						error('overflow');
					}

					i += digit * w;
					t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

					if (digit < t) {
						break;
					}

					baseMinusT = base - t;
					if (w > floor(maxInt / baseMinusT)) {
						error('overflow');
					}

					w *= baseMinusT;

				}

				out = output.length + 1;
				bias = adapt(i - oldi, out, oldi == 0);

				// `i` was supposed to wrap around from `out` to `0`,
				// incrementing `n` each time, so we'll fix that now:
				if (floor(i / out) > maxInt - n) {
					error('overflow');
				}

				n += floor(i / out);
				i %= out;

				// Insert `n` at position `i` of the output
				output.splice(i++, 0, n);

			}

			return ucs2encode(output);
		}

		/**
		 * Converts a string of Unicode symbols (e.g. a domain name label) to a
		 * Punycode string of ASCII-only symbols.
		 * @memberOf punycode
		 * @param {String} input The string of Unicode symbols.
		 * @returns {String} The resulting Punycode string of ASCII-only symbols.
		 */
		function encode(input) {
			var n,
			    delta,
			    handledCPCount,
			    basicLength,
			    bias,
			    j,
			    m,
			    q,
			    k,
			    t,
			    currentValue,
			    output = [],
			    /** `inputLength` will hold the number of code points in `input`. */
			    inputLength,
			    /** Cached calculation results */
			    handledCPCountPlusOne,
			    baseMinusT,
			    qMinusT;

			// Convert the input in UCS-2 to Unicode
			input = ucs2decode(input);

			// Cache the length
			inputLength = input.length;

			// Initialize the state
			n = initialN;
			delta = 0;
			bias = initialBias;

			// Handle the basic code points
			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue < 0x80) {
					output.push(stringFromCharCode(currentValue));
				}
			}

			handledCPCount = basicLength = output.length;

			// `handledCPCount` is the number of code points that have been handled;
			// `basicLength` is the number of basic code points.

			// Finish the basic string - if it is not empty - with a delimiter
			if (basicLength) {
				output.push(delimiter);
			}

			// Main encoding loop:
			while (handledCPCount < inputLength) {

				// All non-basic code points < n have been handled already. Find the next
				// larger one:
				for (m = maxInt, j = 0; j < inputLength; ++j) {
					currentValue = input[j];
					if (currentValue >= n && currentValue < m) {
						m = currentValue;
					}
				}

				// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
				// but guard against overflow
				handledCPCountPlusOne = handledCPCount + 1;
				if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
					error('overflow');
				}

				delta += (m - n) * handledCPCountPlusOne;
				n = m;

				for (j = 0; j < inputLength; ++j) {
					currentValue = input[j];

					if (currentValue < n && ++delta > maxInt) {
						error('overflow');
					}

					if (currentValue == n) {
						// Represent delta as a generalized variable-length integer
						for (q = delta, k = base; /* no condition */; k += base) {
							t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
							if (q < t) {
								break;
							}
							qMinusT = q - t;
							baseMinusT = base - t;
							output.push(
								stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
							);
							q = floor(qMinusT / baseMinusT);
						}

						output.push(stringFromCharCode(digitToBasic(q, 0)));
						bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
						delta = 0;
						++handledCPCount;
					}
				}

				++delta;
				++n;

			}
			return output.join('');
		}

		/**
		 * Converts a Punycode string representing a domain name or an email address
		 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
		 * it doesn't matter if you call it on a string that has already been
		 * converted to Unicode.
		 * @memberOf punycode
		 * @param {String} input The Punycoded domain name or email address to
		 * convert to Unicode.
		 * @returns {String} The Unicode representation of the given Punycode
		 * string.
		 */
		function toUnicode(input) {
			return mapDomain(input, function(string) {
				return regexPunycode.test(string)
					? decode(string.slice(4).toLowerCase())
					: string;
			});
		}

		/**
		 * Converts a Unicode string representing a domain name or an email address to
		 * Punycode. Only the non-ASCII parts of the domain name will be converted,
		 * i.e. it doesn't matter if you call it with a domain that's already in
		 * ASCII.
		 * @memberOf punycode
		 * @param {String} input The domain name or email address to convert, as a
		 * Unicode string.
		 * @returns {String} The Punycode representation of the given domain name or
		 * email address.
		 */
		function toASCII(input) {
			return mapDomain(input, function(string) {
				return regexNonASCII.test(string)
					? 'xn--' + encode(string)
					: string;
			});
		}

		/*--------------------------------------------------------------------------*/

		/** Define the public API */
		punycode = {
			/**
			 * A string representing the current Punycode.js version number.
			 * @memberOf punycode
			 * @type String
			 */
			'version': '1.3.2',
			/**
			 * An object of methods to convert from JavaScript's internal character
			 * representation (UCS-2) to Unicode code points, and back.
			 * @see <https://mathiasbynens.be/notes/javascript-encoding>
			 * @memberOf punycode
			 * @type Object
			 */
			'ucs2': {
				'decode': ucs2decode,
				'encode': ucs2encode
			},
			'decode': decode,
			'encode': encode,
			'toASCII': toASCII,
			'toUnicode': toUnicode
		};

		/** Expose `punycode` */
		// Some AMD build optimizers, like r.js, check for specific condition patterns
		// like the following:
		if (
			true
		) {
			!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
				return punycode;
			}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else if (freeExports && freeModule) {
			if (module.exports == freeExports) { // in Node.js or RingoJS v0.8.0+
				freeModule.exports = punycode;
			} else { // in Narwhal or RingoJS v0.7.0-
				for (key in punycode) {
					punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
				}
			}
		} else { // in Rhino or a web browser
			root.punycode = punycode;
		}

	}(this));

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(107)(module), (function() { return this; }())))

/***/ },
/* 391 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.decode = exports.parse = __webpack_require__(392);
	exports.encode = exports.stringify = __webpack_require__(393);


/***/ },
/* 392 */
/***/ function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	'use strict';

	// If obj.hasOwnProperty has been overridden, then calling
	// obj.hasOwnProperty(prop) will break.
	// See: https://github.com/joyent/node/issues/1707
	function hasOwnProperty(obj, prop) {
	  return Object.prototype.hasOwnProperty.call(obj, prop);
	}

	module.exports = function(qs, sep, eq, options) {
	  sep = sep || '&';
	  eq = eq || '=';
	  var obj = {};

	  if (typeof qs !== 'string' || qs.length === 0) {
	    return obj;
	  }

	  var regexp = /\+/g;
	  qs = qs.split(sep);

	  var maxKeys = 1000;
	  if (options && typeof options.maxKeys === 'number') {
	    maxKeys = options.maxKeys;
	  }

	  var len = qs.length;
	  // maxKeys <= 0 means that we should not limit keys count
	  if (maxKeys > 0 && len > maxKeys) {
	    len = maxKeys;
	  }

	  for (var i = 0; i < len; ++i) {
	    var x = qs[i].replace(regexp, '%20'),
	        idx = x.indexOf(eq),
	        kstr, vstr, k, v;

	    if (idx >= 0) {
	      kstr = x.substr(0, idx);
	      vstr = x.substr(idx + 1);
	    } else {
	      kstr = x;
	      vstr = '';
	    }

	    k = decodeURIComponent(kstr);
	    v = decodeURIComponent(vstr);

	    if (!hasOwnProperty(obj, k)) {
	      obj[k] = v;
	    } else if (Array.isArray(obj[k])) {
	      obj[k].push(v);
	    } else {
	      obj[k] = [obj[k], v];
	    }
	  }

	  return obj;
	};


/***/ },
/* 393 */
/***/ function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	'use strict';

	var stringifyPrimitive = function(v) {
	  switch (typeof v) {
	    case 'string':
	      return v;

	    case 'boolean':
	      return v ? 'true' : 'false';

	    case 'number':
	      return isFinite(v) ? v : '';

	    default:
	      return '';
	  }
	};

	module.exports = function(obj, sep, eq, name) {
	  sep = sep || '&';
	  eq = eq || '=';
	  if (obj === null) {
	    obj = undefined;
	  }

	  if (typeof obj === 'object') {
	    return Object.keys(obj).map(function(k) {
	      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
	      if (Array.isArray(obj[k])) {
	        return obj[k].map(function(v) {
	          return ks + encodeURIComponent(stringifyPrimitive(v));
	        }).join(sep);
	      } else {
	        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
	      }
	    }).join(sep);

	  }

	  if (!name) return '';
	  return encodeURIComponent(stringifyPrimitive(name)) + eq +
	         encodeURIComponent(stringifyPrimitive(obj));
	};


/***/ },
/* 394 */
/***/ function(module, exports, __webpack_require__) {

	var http = __webpack_require__(368);

	var https = module.exports;

	for (var key in http) {
	    if (http.hasOwnProperty(key)) https[key] = http[key];
	};

	https.request = function (params, cb) {
	    if (!params) params = {};
	    params.scheme = 'https';
	    return http.request.call(this, params, cb);
	}


/***/ },
/* 395 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.TitaniumHttp = undefined;

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // eslint-disable-line no-unused-vars


	var _promise = __webpack_require__(286);

	var _promise2 = _interopRequireDefault(_promise);

	var _regeneratorRuntime = __webpack_require__(148);

	var _regeneratorRuntime2 = _interopRequireDefault(_regeneratorRuntime);

	var _parseHeaders = __webpack_require__(396);

	var _parseHeaders2 = _interopRequireDefault(_parseHeaders);

	var _isFunction = __webpack_require__(31);

	var _isFunction2 = _interopRequireDefault(_isFunction);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new _promise2.default(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return _promise2.default.resolve(value).then(function (value) { return step("next", value); }, function (err) { return step("throw", err); }); } } return step("next"); }); }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var Titanium = global.Titanium;

	var TitaniumHttp = exports.TitaniumHttp = function () {
	  function TitaniumHttp() {
	    _classCallCheck(this, TitaniumHttp);
	  }

	  _createClass(TitaniumHttp, [{
	    key: 'handle',
	    value: function () {
	      var _ref = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee(request) {
	        var promise;
	        return _regeneratorRuntime2.default.wrap(function _callee$(_context) {
	          while (1) {
	            switch (_context.prev = _context.next) {
	              case 0:
	                promise = new _promise2.default(function (resolve, reject) {
	                  var url = request.url;
	                  var method = request.method;
	                  var headers = request.headers;
	                  var body = request.body;
	                  var autoRedirect = request.autoRedirect;

	                  // Create an HTTP Client

	                  var client = Titanium.Network.createHTTPClient();

	                  // Open the request
	                  client.open(method, url);

	                  // Set request headers
	                  var keys = Object.keys(headers);
	                  for (var i = 0, len = keys.length; i < len; i += 1) {
	                    var key = keys[i];
	                    client.setRequestHeader(key, headers[key]);
	                  }

	                  // Set autoRedirect flag
	                  client.autoRedirect = autoRedirect || true;

	                  // Set the TLS version (iOS only)
	                  if ((0, _isFunction2.default)(client.setTlsVersion) && Titanium.Network.TLS_VERSION_1_2) {
	                    client.setTlsVersion(Titanium.Network.TLS_VERSION_1_2);
	                  }

	                  // Set timeout
	                  client.timeout = request.timeout || 0;

	                  // onload listener
	                  client.onload = function onLoad() {
	                    resolve({
	                      response: {
	                        statusCode: this.status,
	                        headers: (0, _parseHeaders2.default)(this.allResponseHeaders),
	                        data: this.responseText
	                      }
	                    });
	                  };

	                  // onerror listener
	                  client.onerror = function onError(e) {
	                    reject(e.error);
	                  };

	                  // Send request
	                  client.send(body);
	                });

	                // Return the promise

	                return _context.abrupt('return', promise);

	              case 2:
	              case 'end':
	                return _context.stop();
	            }
	          }
	        }, _callee, this);
	      }));

	      function handle(_x) {
	        return _ref.apply(this, arguments);
	      }

	      return handle;
	    }()
	  }], [{
	    key: 'isSupported',
	    value: function isSupported() {
	      return typeof Titanium !== 'undefined' && typeof Titanium.Network !== 'undefined';
	    }
	  }]);

	  return TitaniumHttp;
	}();
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 396 */
/***/ function(module, exports, __webpack_require__) {

	var trim = __webpack_require__(397)
	  , forEach = __webpack_require__(398)
	  , isArray = function(arg) {
	      return Object.prototype.toString.call(arg) === '[object Array]';
	    }

	module.exports = function (headers) {
	  if (!headers)
	    return {}

	  var result = {}

	  forEach(
	      trim(headers).split('\n')
	    , function (row) {
	        var index = row.indexOf(':')
	          , key = trim(row.slice(0, index)).toLowerCase()
	          , value = trim(row.slice(index + 1))

	        if (typeof(result[key]) === 'undefined') {
	          result[key] = value
	        } else if (isArray(result[key])) {
	          result[key].push(value)
	        } else {
	          result[key] = [ result[key], value ]
	        }
	      }
	  )

	  return result
	}

/***/ },
/* 397 */
/***/ function(module, exports) {

	
	exports = module.exports = trim;

	function trim(str){
	  return str.replace(/^\s*|\s*$/g, '');
	}

	exports.left = function(str){
	  return str.replace(/^\s*/, '');
	};

	exports.right = function(str){
	  return str.replace(/\s*$/, '');
	};


/***/ },
/* 398 */
/***/ function(module, exports, __webpack_require__) {

	var isFunction = __webpack_require__(399)

	module.exports = forEach

	var toString = Object.prototype.toString
	var hasOwnProperty = Object.prototype.hasOwnProperty

	function forEach(list, iterator, context) {
	    if (!isFunction(iterator)) {
	        throw new TypeError('iterator must be a function')
	    }

	    if (arguments.length < 3) {
	        context = this
	    }
	    
	    if (toString.call(list) === '[object Array]')
	        forEachArray(list, iterator, context)
	    else if (typeof list === 'string')
	        forEachString(list, iterator, context)
	    else
	        forEachObject(list, iterator, context)
	}

	function forEachArray(array, iterator, context) {
	    for (var i = 0, len = array.length; i < len; i++) {
	        if (hasOwnProperty.call(array, i)) {
	            iterator.call(context, array[i], i, array)
	        }
	    }
	}

	function forEachString(string, iterator, context) {
	    for (var i = 0, len = string.length; i < len; i++) {
	        // no such thing as a sparse string.
	        iterator.call(context, string.charAt(i), i, string)
	    }
	}

	function forEachObject(object, iterator, context) {
	    for (var k in object) {
	        if (hasOwnProperty.call(object, k)) {
	            iterator.call(context, object[k], k, object)
	        }
	    }
	}


/***/ },
/* 399 */
/***/ function(module, exports) {

	module.exports = isFunction

	var toString = Object.prototype.toString

	function isFunction (fn) {
	  var string = toString.call(fn)
	  return string === '[object Function]' ||
	    (typeof fn === 'function' && string !== '[object RegExp]') ||
	    (typeof window !== 'undefined' &&
	     // IE8 and below
	     (fn === window.setTimeout ||
	      fn === window.alert ||
	      fn === window.confirm ||
	      fn === window.prompt))
	};


/***/ },
/* 400 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.XHR = undefined;

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _promise = __webpack_require__(286);

	var _promise2 = _interopRequireDefault(_promise);

	var _parseHeaders = __webpack_require__(396);

	var _parseHeaders2 = _interopRequireDefault(_parseHeaders);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var XHR = exports.XHR = function () {
	  function XHR() {
	    _classCallCheck(this, XHR);
	  }

	  _createClass(XHR, [{
	    key: 'handle',
	    value: function handle(request) {
	      var promise = new _promise2.default(function (resolve) {
	        var url = request.url;
	        var method = request.method;
	        var headers = request.headers;
	        var body = request.body;

	        // Create request

	        var xhr = new XMLHttpRequest();
	        xhr.open(method, url);

	        // Append request headers
	        var names = Object.keys(headers);
	        var _iteratorNormalCompletion = true;
	        var _didIteratorError = false;
	        var _iteratorError = undefined;

	        try {
	          for (var _iterator = names[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	            var name = _step.value;

	            xhr.setRequestHeader(name, headers[name]);
	          }
	        } catch (err) {
	          _didIteratorError = true;
	          _iteratorError = err;
	        } finally {
	          try {
	            if (!_iteratorNormalCompletion && _iterator.return) {
	              _iterator.return();
	            }
	          } finally {
	            if (_didIteratorError) {
	              throw _iteratorError;
	            }
	          }
	        }

	        xhr.onload = xhr.ontimeout = xhr.onabort = xhr.onerror = function () {
	          // Extract status code
	          var statusCode = xhr.status;

	          // Extract the response
	          var data = xhr.response || null;
	          if (xhr.response) {
	            data = xhr.responseText || null;
	          }

	          // Resolve
	          return resolve({
	            response: {
	              statusCode: statusCode,
	              headers: (0, _parseHeaders2.default)(xhr.getAllResponseHeaders()),
	              data: data
	            }
	          });
	        };

	        // Send xhr
	        xhr.send(body);
	      });
	      return promise;
	    }
	  }], [{
	    key: 'isSupported',
	    value: function isSupported() {
	      return typeof window !== 'undefined' && typeof window.XMLHttpRequest !== 'undefined';
	    }
	  }]);

	  return XHR;
	}();

/***/ },
/* 401 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _middleware = __webpack_require__(239);

	var _middleware2 = _interopRequireDefault(_middleware);

	var _regeneratorRuntime = __webpack_require__(148);

	var _regeneratorRuntime2 = _interopRequireDefault(_regeneratorRuntime);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { return step("next", value); }, function (err) { return step("throw", err); }); } } return step("next"); }); }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	// eslint-disable-line no-unused-vars

	var ParseMiddleware = function (_Middleware) {
	  _inherits(ParseMiddleware, _Middleware);

	  function ParseMiddleware() {
	    var name = arguments.length <= 0 || arguments[0] === undefined ? 'Parse Middleware' : arguments[0];

	    _classCallCheck(this, ParseMiddleware);

	    return _possibleConstructorReturn(this, (ParseMiddleware.__proto__ || Object.getPrototypeOf(ParseMiddleware)).call(this, name));
	  }

	  _createClass(ParseMiddleware, [{
	    key: 'handle',
	    value: function () {
	      var _ref = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee(request, response) {
	        var contentType;
	        return _regeneratorRuntime2.default.wrap(function _callee$(_context) {
	          while (1) {
	            switch (_context.prev = _context.next) {
	              case 0:
	                if (response && response.data) {
	                  contentType = response.headers['content-type'] || response.headers['Content-Type'];


	                  if (contentType) {
	                    if (contentType.indexOf('application/json') === 0) {
	                      try {
	                        response.data = JSON.parse(response.data);
	                      } catch (error) {
	                        // Just catch the error
	                      }
	                    }
	                  }
	                }

	                return _context.abrupt('return', { response: response });

	              case 2:
	              case 'end':
	                return _context.stop();
	            }
	          }
	        }, _callee, this);
	      }));

	      function handle(_x2, _x3) {
	        return _ref.apply(this, arguments);
	      }

	      return handle;
	    }()
	  }]);

	  return ParseMiddleware;
	}(_middleware2.default);

	exports.default = ParseMiddleware;

/***/ },
/* 402 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _middleware = __webpack_require__(239);

	var _middleware2 = _interopRequireDefault(_middleware);

	var _regeneratorRuntime = __webpack_require__(148);

	var _regeneratorRuntime2 = _interopRequireDefault(_regeneratorRuntime);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { return step("next", value); }, function (err) { return step("throw", err); }); } } return step("next"); }); }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	// eslint-disable-line no-unused-vars

	var SerializeMiddleware = function (_Middleware) {
	  _inherits(SerializeMiddleware, _Middleware);

	  function SerializeMiddleware() {
	    var name = arguments.length <= 0 || arguments[0] === undefined ? 'Serialize Middleware' : arguments[0];

	    _classCallCheck(this, SerializeMiddleware);

	    return _possibleConstructorReturn(this, (SerializeMiddleware.__proto__ || Object.getPrototypeOf(SerializeMiddleware)).call(this, name));
	  }

	  _createClass(SerializeMiddleware, [{
	    key: 'handle',
	    value: function () {
	      var _ref = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee(request) {
	        var contentType, body, keys, str, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, key;

	        return _regeneratorRuntime2.default.wrap(function _callee$(_context) {
	          while (1) {
	            switch (_context.prev = _context.next) {
	              case 0:
	                if (!(request && request.body)) {
	                  _context.next = 31;
	                  break;
	                }

	                contentType = request.headers['content-type'] || request.headers['Content-Type'];

	                if (!contentType) {
	                  _context.next = 31;
	                  break;
	                }

	                if (!(contentType.indexOf('application/json') === 0)) {
	                  _context.next = 7;
	                  break;
	                }

	                request.body = JSON.stringify(request.body);
	                _context.next = 31;
	                break;

	              case 7:
	                if (!(contentType.indexOf('application/x-www-form-urlencoded') === 0)) {
	                  _context.next = 31;
	                  break;
	                }

	                body = request.body;
	                keys = Object.keys(body);
	                str = [];
	                _iteratorNormalCompletion = true;
	                _didIteratorError = false;
	                _iteratorError = undefined;
	                _context.prev = 14;


	                for (_iterator = keys[Symbol.iterator](); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	                  key = _step.value;

	                  str.push(global.encodeURIComponent(key) + '=' + global.encodeURIComponent(body[key]));
	                }

	                _context.next = 22;
	                break;

	              case 18:
	                _context.prev = 18;
	                _context.t0 = _context['catch'](14);
	                _didIteratorError = true;
	                _iteratorError = _context.t0;

	              case 22:
	                _context.prev = 22;
	                _context.prev = 23;

	                if (!_iteratorNormalCompletion && _iterator.return) {
	                  _iterator.return();
	                }

	              case 25:
	                _context.prev = 25;

	                if (!_didIteratorError) {
	                  _context.next = 28;
	                  break;
	                }

	                throw _iteratorError;

	              case 28:
	                return _context.finish(25);

	              case 29:
	                return _context.finish(22);

	              case 30:
	                request.body = str.join('&');

	              case 31:
	                return _context.abrupt('return', { request: request });

	              case 32:
	              case 'end':
	                return _context.stop();
	            }
	          }
	        }, _callee, this, [[14, 18, 22, 30], [23,, 25, 29]]);
	      }));

	      function handle(_x2) {
	        return _ref.apply(this, arguments);
	      }

	      return handle;
	    }()
	  }]);

	  return SerializeMiddleware;
	}(_middleware2.default);

	exports.default = SerializeMiddleware;
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 403 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.NetworkRack = exports.CacheRack = undefined;

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _middleware = __webpack_require__(235);

	var _middleware2 = _interopRequireDefault(_middleware);

	var _regeneratorRuntime = __webpack_require__(148);

	var _regeneratorRuntime2 = _interopRequireDefault(_regeneratorRuntime);

	var _findIndex = __webpack_require__(282);

	var _findIndex2 = _interopRequireDefault(_findIndex);

	var _reduce = __webpack_require__(404);

	var _reduce2 = _interopRequireDefault(_reduce);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { return step("next", value); }, function (err) { return step("throw", err); }); } } return step("next"); }); }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // eslint-disable-line no-unused-vars


	var Rack = function (_Middleware) {
	  _inherits(Rack, _Middleware);

	  function Rack() {
	    var name = arguments.length <= 0 || arguments[0] === undefined ? 'Rack' : arguments[0];

	    _classCallCheck(this, Rack);

	    var _this = _possibleConstructorReturn(this, (Rack.__proto__ || Object.getPrototypeOf(Rack)).call(this, name));

	    _this.middlewares = [];
	    _this.canceled = false;
	    return _this;
	  }

	  _createClass(Rack, [{
	    key: 'getMiddleware',
	    value: function getMiddleware() {
	      var index = arguments.length <= 0 || arguments[0] === undefined ? -1 : arguments[0];

	      var middlewares = this.middlewares;

	      if (index < -1 || index >= middlewares.length) {
	        throw new Error('Index ' + index + ' is out of bounds.');
	      }

	      return middlewares[index];
	    }
	  }, {
	    key: 'use',
	    value: function use(middleware) {
	      if (middleware) {
	        if (middleware instanceof _middleware2.default) {
	          this.middlewares.push(middleware);
	          return;
	        }

	        throw new Error('Unable to use the middleware. It must be an instance of Middleware.');
	      }
	    }
	  }, {
	    key: 'useBefore',
	    value: function useBefore(middlewareClass, middleware) {
	      if (middleware) {
	        if (middleware instanceof _middleware2.default) {
	          var middlewares = this.middlewares;
	          var index = (0, _findIndex2.default)(middlewares, function (existingMiddleware) {
	            return existingMiddleware instanceof middlewareClass;
	          });

	          if (index > -1) {
	            middlewares.splice(index, 0, middleware);
	            this.middlewares = middlewares;
	          }

	          return;
	        }

	        throw new Error('Unable to use the middleware. It must be an instance of Middleware.');
	      }
	    }
	  }, {
	    key: 'useAfter',
	    value: function useAfter(middlewareClass, middleware) {
	      if (middleware) {
	        if (middleware instanceof _middleware2.default) {
	          var middlewares = this.middlewares;
	          var index = (0, _findIndex2.default)(middlewares, function (existingMiddleware) {
	            return existingMiddleware instanceof middlewareClass;
	          });

	          if (index > -1) {
	            middlewares.splice(index + 1, 0, middleware);
	            this.middlewares = middlewares;
	          }

	          return;
	        }

	        throw new Error('Unable to use the middleware. It must be an instance of Middleware.');
	      }
	    }
	  }, {
	    key: 'swap',
	    value: function swap(middlewareClass, middleware) {
	      if (middleware) {
	        if (middleware instanceof _middleware2.default) {
	          var middlewares = this.middlewares;
	          var index = (0, _findIndex2.default)(middlewares, function (existingMiddleware) {
	            return existingMiddleware instanceof middlewareClass;
	          });

	          if (index > -1) {
	            middlewares.splice(index, 1, middleware);
	            this.middlewares = middlewares;
	          }

	          return;
	        }

	        throw new Error('Unable to use the middleware. It must be an instance of Middleware.');
	      }
	    }
	  }, {
	    key: 'remove',
	    value: function remove(middlewareClass) {
	      var middlewares = this.middlewares;
	      var index = (0, _findIndex2.default)(middlewares, function (existingMiddleware) {
	        return existingMiddleware instanceof middlewareClass;
	      });

	      if (index > -1) {
	        middlewares.splice(index, 1);
	        this.middlewares = middlewares;
	        this.remove(middlewareClass);
	      }
	    }
	  }, {
	    key: 'reset',
	    value: function reset() {
	      this.middlewares = [];
	    }
	  }, {
	    key: 'execute',
	    value: function () {
	      var _ref = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee(req) {
	        var _ref2, response;

	        return _regeneratorRuntime2.default.wrap(function _callee$(_context) {
	          while (1) {
	            switch (_context.prev = _context.next) {
	              case 0:
	                if (req) {
	                  _context.next = 2;
	                  break;
	                }

	                throw new Error('Request is undefined. Please provide a valid request.');

	              case 2:
	                _context.next = 4;
	                return (0, _reduce2.default)(this.middlewares, function (promise, middleware) {
	                  return promise.then(function (_ref3) {
	                    var request = _ref3.request;
	                    var response = _ref3.response;
	                    return middleware.handle(request || req, response);
	                  });
	                }, Promise.resolve({ request: req }));

	              case 4:
	                _ref2 = _context.sent;
	                response = _ref2.response;
	                return _context.abrupt('return', response);

	              case 7:
	              case 'end':
	                return _context.stop();
	            }
	          }
	        }, _callee, this);
	      }));

	      function execute(_x3) {
	        return _ref.apply(this, arguments);
	      }

	      return execute;
	    }()
	  }, {
	    key: 'cancel',
	    value: function cancel() {
	      this.canceled = true;
	    }
	  }, {
	    key: 'handle',
	    value: function handle(request) {
	      return this.execute(request);
	    }
	  }, {
	    key: 'generateTree',
	    value: function generateTree() {
	      var level = arguments.length <= 0 || arguments[0] === undefined ? 0 : arguments[0];

	      var root = _get(Rack.prototype.__proto__ || Object.getPrototypeOf(Rack.prototype), 'generateTree', this).call(this, level);
	      var middlewares = this.middlewares;

	      middlewares.forEach(function (middleware) {
	        root.nodes.push(middleware.generateTree(level + 1));
	      });

	      return root;
	    }
	  }]);

	  return Rack;
	}(_middleware2.default);

	exports.default = Rack;

	var CacheRack = exports.CacheRack = function (_Rack) {
	  _inherits(CacheRack, _Rack);

	  function CacheRack() {
	    var name = arguments.length <= 0 || arguments[0] === undefined ? 'Cache Rack' : arguments[0];

	    _classCallCheck(this, CacheRack);

	    var _this2 = _possibleConstructorReturn(this, (CacheRack.__proto__ || Object.getPrototypeOf(CacheRack)).call(this, name));

	    _this2.use(new _middleware.CacheMiddleware());
	    return _this2;
	  }

	  return CacheRack;
	}(Rack);

	var NetworkRack = exports.NetworkRack = function (_Rack2) {
	  _inherits(NetworkRack, _Rack2);

	  function NetworkRack() {
	    var name = arguments.length <= 0 || arguments[0] === undefined ? 'Network Rack' : arguments[0];

	    _classCallCheck(this, NetworkRack);

	    var _this3 = _possibleConstructorReturn(this, (NetworkRack.__proto__ || Object.getPrototypeOf(NetworkRack)).call(this, name));

	    _this3.use(new _middleware.SerializeMiddleware());
	    _this3.use(new _middleware.HttpMiddleware());
	    _this3.use(new _middleware.ParseMiddleware());
	    return _this3;
	  }

	  return NetworkRack;
	}(Rack);

/***/ },
/* 404 */
/***/ function(module, exports, __webpack_require__) {

	var arrayReduce = __webpack_require__(268),
	    baseEach = __webpack_require__(21),
	    baseIteratee = __webpack_require__(42),
	    baseReduce = __webpack_require__(405),
	    isArray = __webpack_require__(35);

	/**
	 * Reduces `collection` to a value which is the accumulated result of running
	 * each element in `collection` thru `iteratee`, where each successive
	 * invocation is supplied the return value of the previous. If `accumulator`
	 * is not given, the first element of `collection` is used as the initial
	 * value. The iteratee is invoked with four arguments:
	 * (accumulator, value, index|key, collection).
	 *
	 * Many lodash methods are guarded to work as iteratees for methods like
	 * `_.reduce`, `_.reduceRight`, and `_.transform`.
	 *
	 * The guarded methods are:
	 * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
	 * and `sortBy`
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Collection
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	 * @param {*} [accumulator] The initial value.
	 * @returns {*} Returns the accumulated value.
	 * @see _.reduceRight
	 * @example
	 *
	 * _.reduce([1, 2], function(sum, n) {
	 *   return sum + n;
	 * }, 0);
	 * // => 3
	 *
	 * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
	 *   (result[value] || (result[value] = [])).push(key);
	 *   return result;
	 * }, {});
	 * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
	 */
	function reduce(collection, iteratee, accumulator) {
	  var func = isArray(collection) ? arrayReduce : baseReduce,
	      initAccum = arguments.length < 3;

	  return func(collection, baseIteratee(iteratee, 4), accumulator, initAccum, baseEach);
	}

	module.exports = reduce;


/***/ },
/* 405 */
/***/ function(module, exports) {

	/**
	 * The base implementation of `_.reduce` and `_.reduceRight`, without support
	 * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
	 *
	 * @private
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @param {*} accumulator The initial value.
	 * @param {boolean} initAccum Specify using the first or last element of
	 *  `collection` as the initial value.
	 * @param {Function} eachFunc The function to iterate over `collection`.
	 * @returns {*} Returns the accumulated value.
	 */
	function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
	  eachFunc(collection, function(value, index, collection) {
	    accumulator = initAccum
	      ? (initAccum = false, value)
	      : iteratee(accumulator, value, index, collection);
	  });
	  return accumulator;
	}

	module.exports = baseReduce;


/***/ },
/* 406 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// Generated by CoffeeScript 1.10.0
	var slice = [].slice;

	(function(root, factory) {
	  if (('function' === "function") && (__webpack_require__(407) != null)) {
	    return !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  } else if (typeof exports !== "undefined" && exports !== null) {
	    return module.exports = factory();
	  } else {
	    return root.UrlPattern = factory();
	  }
	})(this, function() {
	  var P, UrlPattern, astNodeContainsSegmentsForProvidedParams, astNodeToNames, astNodeToRegexString, baseAstNodeToRegexString, concatMap, defaultOptions, escapeForRegex, getParam, keysAndValuesToObject, newParser, regexGroupCount, stringConcatMap, stringify;
	  escapeForRegex = function(string) {
	    return string.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
	  };
	  concatMap = function(array, f) {
	    var i, length, results;
	    results = [];
	    i = -1;
	    length = array.length;
	    while (++i < length) {
	      results = results.concat(f(array[i]));
	    }
	    return results;
	  };
	  stringConcatMap = function(array, f) {
	    var i, length, result;
	    result = '';
	    i = -1;
	    length = array.length;
	    while (++i < length) {
	      result += f(array[i]);
	    }
	    return result;
	  };
	  regexGroupCount = function(regex) {
	    return (new RegExp(regex.toString() + '|')).exec('').length - 1;
	  };
	  keysAndValuesToObject = function(keys, values) {
	    var i, key, length, object, value;
	    object = {};
	    i = -1;
	    length = keys.length;
	    while (++i < length) {
	      key = keys[i];
	      value = values[i];
	      if (value == null) {
	        continue;
	      }
	      if (object[key] != null) {
	        if (!Array.isArray(object[key])) {
	          object[key] = [object[key]];
	        }
	        object[key].push(value);
	      } else {
	        object[key] = value;
	      }
	    }
	    return object;
	  };
	  P = {};
	  P.Result = function(value, rest) {
	    this.value = value;
	    this.rest = rest;
	  };
	  P.Tagged = function(tag, value) {
	    this.tag = tag;
	    this.value = value;
	  };
	  P.tag = function(tag, parser) {
	    return function(input) {
	      var result, tagged;
	      result = parser(input);
	      if (result == null) {
	        return;
	      }
	      tagged = new P.Tagged(tag, result.value);
	      return new P.Result(tagged, result.rest);
	    };
	  };
	  P.regex = function(regex) {
	    return function(input) {
	      var matches, result;
	      matches = regex.exec(input);
	      if (matches == null) {
	        return;
	      }
	      result = matches[0];
	      return new P.Result(result, input.slice(result.length));
	    };
	  };
	  P.sequence = function() {
	    var parsers;
	    parsers = 1 <= arguments.length ? slice.call(arguments, 0) : [];
	    return function(input) {
	      var i, length, parser, rest, result, values;
	      i = -1;
	      length = parsers.length;
	      values = [];
	      rest = input;
	      while (++i < length) {
	        parser = parsers[i];
	        result = parser(rest);
	        if (result == null) {
	          return;
	        }
	        values.push(result.value);
	        rest = result.rest;
	      }
	      return new P.Result(values, rest);
	    };
	  };
	  P.pick = function() {
	    var indexes, parsers;
	    indexes = arguments[0], parsers = 2 <= arguments.length ? slice.call(arguments, 1) : [];
	    return function(input) {
	      var array, result;
	      result = P.sequence.apply(P, parsers)(input);
	      if (result == null) {
	        return;
	      }
	      array = result.value;
	      result.value = array[indexes];
	      return result;
	    };
	  };
	  P.string = function(string) {
	    var length;
	    length = string.length;
	    return function(input) {
	      if (input.slice(0, length) === string) {
	        return new P.Result(string, input.slice(length));
	      }
	    };
	  };
	  P.lazy = function(fn) {
	    var cached;
	    cached = null;
	    return function(input) {
	      if (cached == null) {
	        cached = fn();
	      }
	      return cached(input);
	    };
	  };
	  P.baseMany = function(parser, end, stringResult, atLeastOneResultRequired, input) {
	    var endResult, parserResult, rest, results;
	    rest = input;
	    results = stringResult ? '' : [];
	    while (true) {
	      if (end != null) {
	        endResult = end(rest);
	        if (endResult != null) {
	          break;
	        }
	      }
	      parserResult = parser(rest);
	      if (parserResult == null) {
	        break;
	      }
	      if (stringResult) {
	        results += parserResult.value;
	      } else {
	        results.push(parserResult.value);
	      }
	      rest = parserResult.rest;
	    }
	    if (atLeastOneResultRequired && results.length === 0) {
	      return;
	    }
	    return new P.Result(results, rest);
	  };
	  P.many1 = function(parser) {
	    return function(input) {
	      return P.baseMany(parser, null, false, true, input);
	    };
	  };
	  P.concatMany1Till = function(parser, end) {
	    return function(input) {
	      return P.baseMany(parser, end, true, true, input);
	    };
	  };
	  P.firstChoice = function() {
	    var parsers;
	    parsers = 1 <= arguments.length ? slice.call(arguments, 0) : [];
	    return function(input) {
	      var i, length, parser, result;
	      i = -1;
	      length = parsers.length;
	      while (++i < length) {
	        parser = parsers[i];
	        result = parser(input);
	        if (result != null) {
	          return result;
	        }
	      }
	    };
	  };
	  newParser = function(options) {
	    var U;
	    U = {};
	    U.wildcard = P.tag('wildcard', P.string(options.wildcardChar));
	    U.optional = P.tag('optional', P.pick(1, P.string(options.optionalSegmentStartChar), P.lazy(function() {
	      return U.pattern;
	    }), P.string(options.optionalSegmentEndChar)));
	    U.name = P.regex(new RegExp("^[" + options.segmentNameCharset + "]+"));
	    U.named = P.tag('named', P.pick(1, P.string(options.segmentNameStartChar), P.lazy(function() {
	      return U.name;
	    })));
	    U.escapedChar = P.pick(1, P.string(options.escapeChar), P.regex(/^./));
	    U["static"] = P.tag('static', P.concatMany1Till(P.firstChoice(P.lazy(function() {
	      return U.escapedChar;
	    }), P.regex(/^./)), P.firstChoice(P.string(options.segmentNameStartChar), P.string(options.optionalSegmentStartChar), P.string(options.optionalSegmentEndChar), U.wildcard)));
	    U.token = P.lazy(function() {
	      return P.firstChoice(U.wildcard, U.optional, U.named, U["static"]);
	    });
	    U.pattern = P.many1(P.lazy(function() {
	      return U.token;
	    }));
	    return U;
	  };
	  defaultOptions = {
	    escapeChar: '\\',
	    segmentNameStartChar: ':',
	    segmentValueCharset: 'a-zA-Z0-9-_~ %',
	    segmentNameCharset: 'a-zA-Z0-9',
	    optionalSegmentStartChar: '(',
	    optionalSegmentEndChar: ')',
	    wildcardChar: '*'
	  };
	  baseAstNodeToRegexString = function(astNode, segmentValueCharset) {
	    if (Array.isArray(astNode)) {
	      return stringConcatMap(astNode, function(node) {
	        return baseAstNodeToRegexString(node, segmentValueCharset);
	      });
	    }
	    switch (astNode.tag) {
	      case 'wildcard':
	        return '(.*?)';
	      case 'named':
	        return "([" + segmentValueCharset + "]+)";
	      case 'static':
	        return escapeForRegex(astNode.value);
	      case 'optional':
	        return '(?:' + baseAstNodeToRegexString(astNode.value, segmentValueCharset) + ')?';
	    }
	  };
	  astNodeToRegexString = function(astNode, segmentValueCharset) {
	    if (segmentValueCharset == null) {
	      segmentValueCharset = defaultOptions.segmentValueCharset;
	    }
	    return '^' + baseAstNodeToRegexString(astNode, segmentValueCharset) + '$';
	  };
	  astNodeToNames = function(astNode) {
	    if (Array.isArray(astNode)) {
	      return concatMap(astNode, astNodeToNames);
	    }
	    switch (astNode.tag) {
	      case 'wildcard':
	        return ['_'];
	      case 'named':
	        return [astNode.value];
	      case 'static':
	        return [];
	      case 'optional':
	        return astNodeToNames(astNode.value);
	    }
	  };
	  getParam = function(params, key, nextIndexes, sideEffects) {
	    var index, maxIndex, result, value;
	    if (sideEffects == null) {
	      sideEffects = false;
	    }
	    value = params[key];
	    if (value == null) {
	      if (sideEffects) {
	        throw new Error("no values provided for key `" + key + "`");
	      } else {
	        return;
	      }
	    }
	    index = nextIndexes[key] || 0;
	    maxIndex = Array.isArray(value) ? value.length - 1 : 0;
	    if (index > maxIndex) {
	      if (sideEffects) {
	        throw new Error("too few values provided for key `" + key + "`");
	      } else {
	        return;
	      }
	    }
	    result = Array.isArray(value) ? value[index] : value;
	    if (sideEffects) {
	      nextIndexes[key] = index + 1;
	    }
	    return result;
	  };
	  astNodeContainsSegmentsForProvidedParams = function(astNode, params, nextIndexes) {
	    var i, length;
	    if (Array.isArray(astNode)) {
	      i = -1;
	      length = astNode.length;
	      while (++i < length) {
	        if (astNodeContainsSegmentsForProvidedParams(astNode[i], params, nextIndexes)) {
	          return true;
	        }
	      }
	      return false;
	    }
	    switch (astNode.tag) {
	      case 'wildcard':
	        return getParam(params, '_', nextIndexes, false) != null;
	      case 'named':
	        return getParam(params, astNode.value, nextIndexes, false) != null;
	      case 'static':
	        return false;
	      case 'optional':
	        return astNodeContainsSegmentsForProvidedParams(astNode.value, params, nextIndexes);
	    }
	  };
	  stringify = function(astNode, params, nextIndexes) {
	    if (Array.isArray(astNode)) {
	      return stringConcatMap(astNode, function(node) {
	        return stringify(node, params, nextIndexes);
	      });
	    }
	    switch (astNode.tag) {
	      case 'wildcard':
	        return getParam(params, '_', nextIndexes, true);
	      case 'named':
	        return getParam(params, astNode.value, nextIndexes, true);
	      case 'static':
	        return astNode.value;
	      case 'optional':
	        if (astNodeContainsSegmentsForProvidedParams(astNode.value, params, nextIndexes)) {
	          return stringify(astNode.value, params, nextIndexes);
	        } else {
	          return '';
	        }
	    }
	  };
	  UrlPattern = function(arg1, arg2) {
	    var groupCount, options, parsed, parser, withoutWhitespace;
	    if (arg1 instanceof UrlPattern) {
	      this.isRegex = arg1.isRegex;
	      this.regex = arg1.regex;
	      this.ast = arg1.ast;
	      this.names = arg1.names;
	      return;
	    }
	    this.isRegex = arg1 instanceof RegExp;
	    if (!(('string' === typeof arg1) || this.isRegex)) {
	      throw new TypeError('argument must be a regex or a string');
	    }
	    if (this.isRegex) {
	      this.regex = arg1;
	      if (arg2 != null) {
	        if (!Array.isArray(arg2)) {
	          throw new Error('if first argument is a regex the second argument may be an array of group names but you provided something else');
	        }
	        groupCount = regexGroupCount(this.regex);
	        if (arg2.length !== groupCount) {
	          throw new Error("regex contains " + groupCount + " groups but array of group names contains " + arg2.length);
	        }
	        this.names = arg2;
	      }
	      return;
	    }
	    if (arg1 === '') {
	      throw new Error('argument must not be the empty string');
	    }
	    withoutWhitespace = arg1.replace(/\s+/g, '');
	    if (withoutWhitespace !== arg1) {
	      throw new Error('argument must not contain whitespace');
	    }
	    options = {
	      escapeChar: (arg2 != null ? arg2.escapeChar : void 0) || defaultOptions.escapeChar,
	      segmentNameStartChar: (arg2 != null ? arg2.segmentNameStartChar : void 0) || defaultOptions.segmentNameStartChar,
	      segmentNameCharset: (arg2 != null ? arg2.segmentNameCharset : void 0) || defaultOptions.segmentNameCharset,
	      segmentValueCharset: (arg2 != null ? arg2.segmentValueCharset : void 0) || defaultOptions.segmentValueCharset,
	      optionalSegmentStartChar: (arg2 != null ? arg2.optionalSegmentStartChar : void 0) || defaultOptions.optionalSegmentStartChar,
	      optionalSegmentEndChar: (arg2 != null ? arg2.optionalSegmentEndChar : void 0) || defaultOptions.optionalSegmentEndChar,
	      wildcardChar: (arg2 != null ? arg2.wildcardChar : void 0) || defaultOptions.wildcardChar
	    };
	    parser = newParser(options);
	    parsed = parser.pattern(arg1);
	    if (parsed == null) {
	      throw new Error("couldn't parse pattern");
	    }
	    if (parsed.rest !== '') {
	      throw new Error("could only partially parse pattern");
	    }
	    this.ast = parsed.value;
	    this.regex = new RegExp(astNodeToRegexString(this.ast, options.segmentValueCharset));
	    this.names = astNodeToNames(this.ast);
	  };
	  UrlPattern.prototype.match = function(url) {
	    var groups, match;
	    match = this.regex.exec(url);
	    if (match == null) {
	      return null;
	    }
	    groups = match.slice(1);
	    if (this.names) {
	      return keysAndValuesToObject(this.names, groups);
	    } else {
	      return groups;
	    }
	  };
	  UrlPattern.prototype.stringify = function(params) {
	    if (params == null) {
	      params = {};
	    }
	    if (this.isRegex) {
	      throw new Error("can't stringify patterns generated from a regex");
	    }
	    if (params !== Object(params)) {
	      throw new Error("argument must be an object or undefined");
	    }
	    return stringify(this.ast, params, {});
	  };
	  UrlPattern.escapeForRegex = escapeForRegex;
	  UrlPattern.concatMap = concatMap;
	  UrlPattern.stringConcatMap = stringConcatMap;
	  UrlPattern.regexGroupCount = regexGroupCount;
	  UrlPattern.keysAndValuesToObject = keysAndValuesToObject;
	  UrlPattern.P = P;
	  UrlPattern.newParser = newParser;
	  UrlPattern.defaultOptions = defaultOptions;
	  UrlPattern.astNodeToRegexString = astNodeToRegexString;
	  UrlPattern.astNodeToNames = astNodeToNames;
	  UrlPattern.getParam = getParam;
	  UrlPattern.astNodeContainsSegmentsForProvidedParams = astNodeContainsSegmentsForProvidedParams;
	  UrlPattern.stringify = stringify;
	  return UrlPattern;
	});


/***/ },
/* 407 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {module.exports = __webpack_amd_options__;

	/* WEBPACK VAR INJECTION */}.call(exports, {}))

/***/ },
/* 408 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _set = function set(object, property, value, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent !== null) { set(parent, property, value, receiver); } } else if ("value" in desc && desc.writable) { desc.value = value; } else { var setter = desc.set; if (setter !== undefined) { setter.call(receiver, value); } } return value; };

	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _kinveyrequest = __webpack_require__(409);

	var _kinveyrequest2 = _interopRequireDefault(_kinveyrequest);

	var _request3 = __webpack_require__(221);

	var _cacherequest = __webpack_require__(220);

	var _cacherequest2 = _interopRequireDefault(_cacherequest);

	var _response = __webpack_require__(222);

	var _response2 = _interopRequireDefault(_response);

	var _errors = __webpack_require__(11);

	var _query3 = __webpack_require__(422);

	var _promise = __webpack_require__(286);

	var _promise2 = _interopRequireDefault(_promise);

	var _regeneratorRuntime = __webpack_require__(148);

	var _regeneratorRuntime2 = _interopRequireDefault(_regeneratorRuntime);

	var _keyBy = __webpack_require__(243);

	var _keyBy2 = _interopRequireDefault(_keyBy);

	var _reduce = __webpack_require__(404);

	var _reduce2 = _interopRequireDefault(_reduce);

	var _result = __webpack_require__(428);

	var _result2 = _interopRequireDefault(_result);

	var _values = __webpack_require__(279);

	var _values2 = _interopRequireDefault(_values);

	var _forEach = __webpack_require__(19);

	var _forEach2 = _interopRequireDefault(_forEach);

	var _isArray = __webpack_require__(35);

	var _isArray2 = _interopRequireDefault(_isArray);

	var _isString = __webpack_require__(217);

	var _isString2 = _interopRequireDefault(_isString);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new _promise2.default(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return _promise2.default.resolve(value).then(function (value) { return step("next", value); }, function (err) { return step("throw", err); }); } } return step("next"); }); }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // eslint-disable-line no-unused-vars


	var idAttribute = process && process.env && process.env.KINVEY_ID_ATTRIBUTE || '_id' || '_id';
	var kmdAttribute = process && process.env && process.env.KINVEY_KMD_ATTRIBUTE || '_kmd' || '_kmd';
	var maxIdsPerRequest = 200;

	/**
	 * @private
	 */

	var DeltaFetchRequest = function (_KinveyRequest) {
	  _inherits(DeltaFetchRequest, _KinveyRequest);

	  function DeltaFetchRequest() {
	    _classCallCheck(this, DeltaFetchRequest);

	    return _possibleConstructorReturn(this, (DeltaFetchRequest.__proto__ || Object.getPrototypeOf(DeltaFetchRequest)).apply(this, arguments));
	  }

	  _createClass(DeltaFetchRequest, [{
	    key: 'execute',
	    value: function () {
	      var _ref = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee2() {
	        var _this2 = this;

	        var cacheData, _request, _ret, request;

	        return _regeneratorRuntime2.default.wrap(function _callee2$(_context2) {
	          while (1) {
	            switch (_context2.prev = _context2.next) {
	              case 0:
	                cacheData = [];
	                _context2.next = 3;
	                return _get(DeltaFetchRequest.prototype.__proto__ || Object.getPrototypeOf(DeltaFetchRequest.prototype), 'execute', this).call(this);

	              case 3:
	                _context2.prev = 3;
	                _request = new _cacherequest2.default({
	                  method: _request3.RequestMethod.GET,
	                  url: this.url,
	                  headers: this.headers,
	                  query: this.query,
	                  timeout: this.timeout,
	                  client: this.client
	                });
	                _context2.next = 7;
	                return _request.execute().then(function (cacheResponse) {
	                  return cacheResponse.data;
	                });

	              case 7:
	                cacheData = _context2.sent;
	                _context2.next = 15;
	                break;

	              case 10:
	                _context2.prev = 10;
	                _context2.t0 = _context2['catch'](3);

	                if (_context2.t0 instanceof _errors.NotFoundError) {
	                  _context2.next = 14;
	                  break;
	                }

	                throw _context2.t0;

	              case 14:

	                cacheData = [];

	              case 15:
	                if (!((0, _isArray2.default)(cacheData) && cacheData.length > 0)) {
	                  _context2.next = 20;
	                  break;
	                }

	                return _context2.delegateYield(_regeneratorRuntime2.default.mark(function _callee() {
	                  var cacheDocuments, query, request, networkData, networkDocuments, deltaSet, cacheDocumentIds, deltaSetIds, promises, i, _query, ids, _request2, promise, responses, response, _query2;

	                  return _regeneratorRuntime2.default.wrap(function _callee$(_context) {
	                    while (1) {
	                      switch (_context.prev = _context.next) {
	                        case 0:
	                          cacheDocuments = (0, _keyBy2.default)(cacheData, idAttribute);
	                          query = new _query3.Query((0, _result2.default)(_this2.query, 'toJSON', _this2.query));

	                          query.fields = [idAttribute, kmdAttribute + '.lmt'];
	                          request = new _kinveyrequest2.default({
	                            method: _request3.RequestMethod.GET,
	                            url: _this2.url,
	                            headers: _this2.headers,
	                            auth: _this2.auth,
	                            query: query,
	                            timeout: _this2.timeout,
	                            client: _this2.client
	                          });
	                          _context.next = 6;
	                          return request.execute().then(function (response) {
	                            return response.data;
	                          });

	                        case 6:
	                          networkData = _context.sent;
	                          networkDocuments = (0, _keyBy2.default)(networkData, idAttribute);
	                          deltaSet = networkDocuments;
	                          cacheDocumentIds = Object.keys(cacheDocuments);


	                          (0, _forEach2.default)(cacheDocumentIds, function (id) {
	                            var cacheDocument = cacheDocuments[id];
	                            var networkDocument = networkDocuments[id];

	                            if (networkDocument) {
	                              if (networkDocument[kmdAttribute] && cacheDocument[kmdAttribute] && networkDocument[kmdAttribute].lmt === cacheDocument[kmdAttribute].lmt) {
	                                delete deltaSet[id];
	                              } else {
	                                delete cacheDocuments[id];
	                              }
	                            } else {
	                              delete cacheDocuments[id];
	                            }
	                          });

	                          deltaSetIds = Object.keys(deltaSet);
	                          promises = [];
	                          i = 0;


	                          while (i < deltaSetIds.length) {
	                            _query = new _query3.Query((0, _result2.default)(_this2.query, 'toJSON', _this2.query));
	                            ids = deltaSetIds.slice(i, deltaSetIds.length > maxIdsPerRequest + i ? maxIdsPerRequest : deltaSetIds.length);

	                            _query.contains(idAttribute, ids);
	                            _request2 = new _kinveyrequest2.default({
	                              method: _request3.RequestMethod.GET,
	                              url: _this2.url,
	                              headers: _this2.headers,
	                              auth: _this2.auth,
	                              query: _query,
	                              timeout: _this2.timeout,
	                              client: _this2.client
	                            });
	                            promise = _request2.execute();

	                            promises.push(promise);
	                            i += maxIdsPerRequest;
	                          }

	                          _context.next = 17;
	                          return _promise2.default.all(promises);

	                        case 17:
	                          responses = _context.sent;
	                          response = (0, _reduce2.default)(responses, function (result, response) {
	                            if (response.isSuccess()) {
	                              var headers = result.headers;
	                              headers.addHeaders(response.headers);
	                              result.headers = headers;
	                              result.data = result.data.concat(response.data);
	                            }

	                            return result;
	                          }, new _response2.default({
	                            statusCode: _response.StatusCode.Ok,
	                            data: []
	                          }));


	                          response.data = response.data.concat((0, _values2.default)(cacheDocuments));

	                          if (_this2.query) {
	                            _query2 = new _query3.Query((0, _result2.default)(_this2.query, 'toJSON', _this2.query));

	                            _query2.skip(0).limit(0);
	                            response.data = _query2.process(response.data);
	                          }

	                          return _context.abrupt('return', {
	                            v: response
	                          });

	                        case 22:
	                        case 'end':
	                          return _context.stop();
	                      }
	                    }
	                  }, _callee, _this2);
	                })(), 't1', 17);

	              case 17:
	                _ret = _context2.t1;

	                if (!((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object")) {
	                  _context2.next = 20;
	                  break;
	                }

	                return _context2.abrupt('return', _ret.v);

	              case 20:
	                request = new _kinveyrequest2.default({
	                  method: _request3.RequestMethod.GET,
	                  url: this.url,
	                  headers: this.headers,
	                  auth: this.auth,
	                  query: this.query,
	                  timeout: this.timeout,
	                  client: this.client
	                });
	                return _context2.abrupt('return', request.execute());

	              case 22:
	              case 'end':
	                return _context2.stop();
	            }
	          }
	        }, _callee2, this, [[3, 10]]);
	      }));

	      function execute() {
	        return _ref.apply(this, arguments);
	      }

	      return execute;
	    }()
	  }, {
	    key: 'method',
	    get: function get() {
	      return _get(DeltaFetchRequest.prototype.__proto__ || Object.getPrototypeOf(DeltaFetchRequest.prototype), 'method', this);
	    },
	    set: function set(method) {
	      // Cast the method to a string
	      if (!(0, _isString2.default)(method)) {
	        method = String(method);
	      }

	      // Make sure the the method is upper case
	      method = method.toUpperCase();

	      // Verify that the method is allowed
	      switch (method) {
	        case _request3.RequestMethod.GET:
	          _set(DeltaFetchRequest.prototype.__proto__ || Object.getPrototypeOf(DeltaFetchRequest.prototype), 'method', method, this);
	          break;
	        case _request3.RequestMethod.POST:
	        case _request3.RequestMethod.PATCH:
	        case _request3.RequestMethod.PUT:
	        case _request3.RequestMethod.DELETE:
	        default:
	          throw new Error('Invalid request Method. Only RequestMethod.GET is allowed.');
	      }
	    }
	  }]);

	  return DeltaFetchRequest;
	}(_kinveyrequest2.default);

	exports.default = DeltaFetchRequest;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 409 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, Buffer) {'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Properties = exports.AuthType = undefined;

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _set = function set(object, property, value, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent !== null) { set(parent, property, value, receiver); } } else if ("value" in desc && desc.writable) { desc.value = value; } else { var setter = desc.set; if (setter !== undefined) { setter.call(receiver, value); } } return value; };

	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _request = __webpack_require__(221);

	var _headers = __webpack_require__(223);

	var _headers2 = _interopRequireDefault(_headers);

	var _networkrequest = __webpack_require__(410);

	var _networkrequest2 = _interopRequireDefault(_networkrequest);

	var _kinveyresponse = __webpack_require__(233);

	var _kinveyresponse2 = _interopRequireDefault(_kinveyresponse);

	var _errors = __webpack_require__(11);

	var _client = __webpack_require__(10);

	var _social = __webpack_require__(411);

	var _utils = __webpack_require__(13);

	var _regeneratorRuntime = __webpack_require__(148);

	var _regeneratorRuntime2 = _interopRequireDefault(_regeneratorRuntime);

	var _url = __webpack_require__(206);

	var _url2 = _interopRequireDefault(_url);

	var _qs = __webpack_require__(226);

	var _qs2 = _interopRequireDefault(_qs);

	var _appendQuery = __webpack_require__(230);

	var _appendQuery2 = _interopRequireDefault(_appendQuery);

	var _assign = __webpack_require__(211);

	var _assign2 = _interopRequireDefault(_assign);

	var _isNumber = __webpack_require__(232);

	var _isNumber2 = _interopRequireDefault(_isNumber);

	var _isEmpty = __webpack_require__(359);

	var _isEmpty2 = _interopRequireDefault(_isEmpty);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { return step("next", value); }, function (err) { return step("throw", err); }); } } return step("next"); }); }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // eslint-disable-line no-unused-vars


	var socialIdentityAttribute = process && process.env && process.env.KINVEY_SOCIAL_IDENTITY_ATTRIBUTE || '_socialIdentity' || '_socialIdentity';
	var tokenPathname = process && process.env && process.env.KINVEY_MIC_TOKEN_PATHNAME || '/oauth/token' || '/oauth/token';
	var usersNamespace = process && process.env && process.env.KINVEY_USERS_NAMESPACE || 'user' || 'user';
	var kmdAttribute = process && process.env && process.env.KINVEY_KMD_ATTRIBUTE || '_kmd' || '_kmd';
	var defaultApiVersion = process && process.env && process.env.KINVEY_DEFAULT_API_VERSION || '4' || 4;
	var customPropertiesMaxBytesAllowed = process && process.env && process.env.KINVEY_MAX_HEADER_BYTES || '2000' || 2000;

	/**
	 * @private
	 * Enum for Auth types.
	 */
	var AuthType = {
	  All: 'All',
	  App: 'App',
	  Basic: 'Basic',
	  Default: 'Default',
	  Master: 'Master',
	  None: 'None',
	  Session: 'Session'
	};
	Object.freeze(AuthType);
	exports.AuthType = AuthType;


	var Auth = {
	  /**
	   * Authenticate through (1) user credentials, (2) Master Secret, or (3) App
	   * Secret.
	   *
	   * @returns {Object}
	   */
	  all: function all(client) {
	    try {
	      return Auth.session(client);
	    } catch (error) {
	      return Auth.basic(client);
	    }
	  },


	  /**
	   * Authenticate through App Secret.
	   *
	   * @returns {Object}
	   */
	  app: function app(client) {
	    if (!client.appKey || !client.appSecret) {
	      throw new Error('Missing client appKey and/or appSecret.' + ' Use Kinvey.init() to set the appKey and appSecret for the client.');
	    }

	    return {
	      scheme: 'Basic',
	      username: client.appKey,
	      password: client.appSecret
	    };
	  },


	  /**
	   * Authenticate through (1) Master Secret, or (2) App Secret.
	   *
	   * @returns {Object}
	   */
	  basic: function basic(client) {
	    try {
	      return Auth.master(client);
	    } catch (error) {
	      return Auth.app(client);
	    }
	  },


	  /**
	   * Authenticate through Master Secret.
	   *
	   * @returns {Object}
	   */
	  master: function master(client) {
	    if (!client.appKey || !client.masterSecret) {
	      throw new Error('Missing client appKey and/or appSecret.' + ' Use Kinvey.init() to set the appKey and appSecret for the client.');
	    }

	    return {
	      scheme: 'Basic',
	      username: client.appKey,
	      password: client.masterSecret
	    };
	  },


	  /**
	   * Do not authenticate.
	   *
	   * @returns {Null}
	   */
	  none: function none() {
	    return null;
	  },


	  /**
	   * Authenticate through user credentials.
	   *
	   * @returns {Object}
	   */
	  session: function session(client) {
	    var activeUser = client.activeUser;

	    if (!activeUser) {
	      throw new _errors.NoActiveUserError('There is not an active user. Please login a user and retry the request.');
	    }

	    return {
	      scheme: 'Kinvey',
	      credentials: activeUser[kmdAttribute].authtoken
	    };
	  }
	};

	/**
	 * @private
	 */
	function byteCount(str) {
	  if (str) {
	    var count = 0;
	    var stringLength = str.length;
	    str = String(str || '');

	    for (var i = 0; i < stringLength; i += 1) {
	      var partCount = encodeURI(str[i]).split('%').length;
	      count += partCount === 1 ? 1 : partCount - 1;
	    }

	    return count;
	  }

	  return 0;
	}

	/**
	 * @private
	 */

	var Properties = exports.Properties = function (_Headers) {
	  _inherits(Properties, _Headers);

	  function Properties() {
	    _classCallCheck(this, Properties);

	    return _possibleConstructorReturn(this, (Properties.__proto__ || Object.getPrototypeOf(Properties)).apply(this, arguments));
	  }

	  return Properties;
	}(_headers2.default);

	var KinveyRequest = function (_NetworkRequest) {
	  _inherits(KinveyRequest, _NetworkRequest);

	  function KinveyRequest() {
	    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

	    _classCallCheck(this, KinveyRequest);

	    // Set default options
	    var _this2 = _possibleConstructorReturn(this, (KinveyRequest.__proto__ || Object.getPrototypeOf(KinveyRequest)).call(this, options));

	    options = (0, _assign2.default)({
	      authType: AuthType.None,
	      query: null,
	      apiVersion: defaultApiVersion,
	      properties: new Properties(),
	      skipBL: false,
	      trace: false,
	      client: _client.Client.sharedInstance()
	    }, options);

	    _this2.authType = options.authType;
	    _this2.query = options.query;
	    _this2.apiVersion = options.apiVersion;
	    _this2.properties = options.properties;
	    _this2.client = options.client;
	    _this2.skipBL = options.skipBL;
	    _this2.trace = options.trace;
	    return _this2;
	  }

	  _createClass(KinveyRequest, [{
	    key: 'execute',
	    value: function () {
	      var _ref = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee() {
	        var rawResponse = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];
	        var response, micSession, refreshMICRequest, newMicSession, data, loginRequest, activeUser;
	        return _regeneratorRuntime2.default.wrap(function _callee$(_context) {
	          while (1) {
	            switch (_context.prev = _context.next) {
	              case 0:
	                _context.prev = 0;
	                _context.next = 3;
	                return _get(KinveyRequest.prototype.__proto__ || Object.getPrototypeOf(KinveyRequest.prototype), 'execute', this).call(this);

	              case 3:
	                response = _context.sent;


	                if (!(response instanceof _kinveyresponse2.default)) {
	                  response = new _kinveyresponse2.default({
	                    statusCode: response.statusCode,
	                    headers: response.headers,
	                    data: response.data
	                  });
	                }

	                if (!(rawResponse === false && response.isSuccess() === false)) {
	                  _context.next = 7;
	                  break;
	                }

	                throw response.error;

	              case 7:
	                return _context.abrupt('return', response);

	              case 10:
	                _context.prev = 10;
	                _context.t0 = _context['catch'](0);

	                if (!(_context.t0 instanceof _errors.InvalidCredentialsError)) {
	                  _context.next = 30;
	                  break;
	                }

	                // Retrieve the MIC session
	                micSession = (0, _utils.getIdentitySession)(this.client, _social.SocialIdentity.MobileIdentityConnect);

	                if (!micSession) {
	                  _context.next = 30;
	                  break;
	                }

	                // Refresh MIC Auth Token
	                refreshMICRequest = new KinveyRequest({
	                  method: _request.RequestMethod.POST,
	                  headers: {
	                    'Content-Type': 'application/x-www-form-urlencoded'
	                  },
	                  authType: AuthType.App,
	                  url: _url2.default.format({
	                    protocol: micSession.protocol || this.client.micProtocol,
	                    host: micSession.host || this.client.micHost,
	                    pathname: tokenPathname
	                  }),
	                  body: {
	                    grant_type: 'refresh_token',
	                    client_id: micSession.client_id,
	                    redirect_uri: micSession.redirect_uri,
	                    refresh_token: micSession.refresh_token
	                  },
	                  timeout: this.timeout,
	                  properties: this.properties
	                });
	                _context.next = 18;
	                return refreshMICRequest.execute().then(function (response) {
	                  return response.data;
	                });

	              case 18:
	                newMicSession = _context.sent;

	                micSession = (0, _assign2.default)(micSession, newMicSession);

	                // Login the user with the new mic session
	                data = {};

	                data[socialIdentityAttribute] = {};
	                data[socialIdentityAttribute][_social.SocialIdentity.MobileIdentityConnect] = micSession;

	                // Login the user
	                loginRequest = new KinveyRequest({
	                  method: _request.RequestMethod.POST,
	                  authType: AuthType.App,
	                  url: _url2.default.format({
	                    protocol: this.client.protocol,
	                    host: this.client.host,
	                    pathname: '/' + usersNamespace + '/' + this.client.appKey + '/login'
	                  }),
	                  properties: this.properties,
	                  body: data,
	                  timeout: this.timeout,
	                  client: this.client
	                });
	                _context.next = 26;
	                return loginRequest.execute().then(function (response) {
	                  return response.data;
	                });

	              case 26:
	                activeUser = _context.sent;


	                // Store the updated active user
	                (0, _utils.setActiveUser)(this.client, activeUser);

	                // Store the updated mic session
	                (0, _utils.setIdentitySession)(this.client, _social.SocialIdentity.MobileIdentityConnect, micSession);

	                // Execute the original request
	                return _context.abrupt('return', this.execute(rawResponse));

	              case 30:
	                throw _context.t0;

	              case 31:
	              case 'end':
	                return _context.stop();
	            }
	          }
	        }, _callee, this, [[0, 10]]);
	      }));

	      function execute(_x2) {
	        return _ref.apply(this, arguments);
	      }

	      return execute;
	    }()
	  }, {
	    key: 'headers',
	    get: function get() {
	      var headers = _get(KinveyRequest.prototype.__proto__ || Object.getPrototypeOf(KinveyRequest.prototype), 'headers', this);

	      // Add the Accept header
	      if (!headers.has('Accept')) {
	        headers.set('Accept', 'application/json; charset=utf-8');
	      }

	      // Add the Content-Type header
	      if (!headers.has('Content-Type')) {
	        headers.set('Content-Type', 'application/json; charset=utf-8');
	      }

	      // Add the X-Kinvey-API-Version header
	      if (!headers.has('X-Kinvey-Api-Version')) {
	        headers.set('X-Kinvey-Api-Version', this.apiVersion);
	      }

	      // Add or remove the X-Kinvey-Skip-Business-Logic header
	      if (this.skipBL === true) {
	        headers.set('X-Kinvey-Skip-Business-Logic', true);
	      } else {
	        headers.remove('X-Kinvey-Skip-Business-Logic');
	      }

	      // Add or remove the X-Kinvey-Include-Headers-In-Response and X-Kinvey-ResponseWrapper headers
	      if (this.trace === true) {
	        headers.set('X-Kinvey-Include-Headers-In-Response', 'X-Kinvey-Request-Id');
	        headers.set('X-Kinvey-ResponseWrapper', true);
	      } else {
	        headers.remove('X-Kinvey-Include-Headers-In-Response');
	        headers.remove('X-Kinvey-ResponseWrapper');
	      }

	      // Add or remove the X-Kinvey-Client-App-Version header
	      if (this.appVersion) {
	        headers.set('X-Kinvey-Client-App-Version', this.appVersion);
	      } else {
	        headers.remove('X-Kinvey-Client-App-Version');
	      }

	      // Add or remove X-Kinvey-Custom-Request-Properties header
	      if (this.properties) {
	        var customPropertiesHeader = this.properties.toString();

	        if (!(0, _isEmpty2.default)(customPropertiesHeader)) {
	          var customPropertiesByteCount = byteCount(customPropertiesHeader);

	          if (customPropertiesByteCount >= customPropertiesMaxBytesAllowed) {
	            throw new Error('The custom properties are ' + customPropertiesByteCount + ' bytes.' + ('It must be less then ' + customPropertiesMaxBytesAllowed + ' bytes.'), 'Please remove some custom properties.');
	          }

	          headers.set('X-Kinvey-Custom-Request-Properties', customPropertiesHeader);
	        } else {
	          headers.remove('X-Kinvey-Custom-Request-Properties');
	        }
	      } else {
	        headers.remove('X-Kinvey-Custom-Request-Properties');
	      }

	      // Add the X-Kinvey-Device-Information header
	      headers.set('X-Kinvey-Device-Information', _utils.Device.toString());

	      // Add or remove the Authorization header
	      if (this.authType) {
	        var authInfo = void 0;

	        // Get the auth info based on the set AuthType
	        switch (this.authType) {
	          case AuthType.All:
	            authInfo = Auth.all(this.client);
	            break;
	          case AuthType.App:
	            authInfo = Auth.app(this.client);
	            break;
	          case AuthType.Basic:
	            authInfo = Auth.basic(this.client);
	            break;
	          case AuthType.Master:
	            authInfo = Auth.master(this.client);
	            break;
	          case AuthType.None:
	            authInfo = Auth.none(this.client);
	            break;
	          case AuthType.Session:
	            authInfo = Auth.session(this.client);
	            break;
	          default:
	            try {
	              authInfo = Auth.session(this.client);
	            } catch (error) {
	              try {
	                authInfo = Auth.master(this.client);
	              } catch (error2) {
	                throw error;
	              }
	            }
	        }

	        // Add the auth info to the Authorization header
	        if (authInfo) {
	          var credentials = authInfo.credentials;

	          if (authInfo.username) {
	            credentials = new Buffer(authInfo.username + ':' + authInfo.password).toString('base64');
	          }

	          headers.set('Authorization', authInfo.scheme + ' ' + credentials);
	        }
	      } else {
	        headers.remove('Authorization');
	      }

	      // Return the headers
	      return headers;
	    },
	    set: function set(headers) {
	      _set(KinveyRequest.prototype.__proto__ || Object.getPrototypeOf(KinveyRequest.prototype), 'headers', headers, this);
	    }
	  }, {
	    key: 'url',
	    get: function get() {
	      var urlString = _get(KinveyRequest.prototype.__proto__ || Object.getPrototypeOf(KinveyRequest.prototype), 'url', this);
	      var queryString = this.query ? this.query.toQueryString() : {};

	      if ((0, _isEmpty2.default)(queryString)) {
	        return urlString;
	      }

	      return (0, _appendQuery2.default)(urlString, _qs2.default.stringify(queryString));
	    },
	    set: function set(urlString) {
	      _set(KinveyRequest.prototype.__proto__ || Object.getPrototypeOf(KinveyRequest.prototype), 'url', urlString, this);
	    }
	  }, {
	    key: 'apiVersion',
	    get: function get() {
	      return this._apiVersion;
	    },
	    set: function set(apiVersion) {
	      this._apiVersion = (0, _isNumber2.default)(apiVersion) ? apiVersion : defaultApiVersion;
	    }
	  }, {
	    key: 'properties',
	    get: function get() {
	      return this._properties;
	    },
	    set: function set(properties) {
	      if (properties && !(properties instanceof Properties)) {
	        properties = new Properties(properties);
	      }

	      this._properties = properties;
	    }
	  }, {
	    key: 'client',
	    get: function get() {
	      return this._client;
	    },
	    set: function set(client) {
	      if (client) {
	        if (!(client instanceof _client.Client)) {
	          throw new _errors.KinveyError('client must be an instance of the Client class.');
	        }

	        this.appVersion = client.appVersion;
	      }

	      this._client = client;
	    }
	  }]);

	  return KinveyRequest;
	}(_networkrequest2.default);

	exports.default = KinveyRequest;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4), __webpack_require__(364).Buffer))

/***/ },
/* 410 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _request = __webpack_require__(221);

	var _request2 = _interopRequireDefault(_request);

	var _kinveyJavascriptRack = __webpack_require__(234);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var NetworkRequest = function (_Request) {
	  _inherits(NetworkRequest, _Request);

	  function NetworkRequest() {
	    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

	    _classCallCheck(this, NetworkRequest);

	    var _this = _possibleConstructorReturn(this, (NetworkRequest.__proto__ || Object.getPrototypeOf(NetworkRequest)).call(this, options));

	    _this.rack = new _kinveyJavascriptRack.NetworkRack();
	    return _this;
	  }

	  return NetworkRequest;
	}(_request2.default);

	exports.default = NetworkRequest;

/***/ },
/* 411 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _enums = __webpack_require__(412);

	Object.keys(_enums).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function get() {
	      return _enums[key];
	    }
	  });
	});

	var _facebook = __webpack_require__(413);

	Object.keys(_facebook).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function get() {
	      return _facebook[key];
	    }
	  });
	});

	var _google = __webpack_require__(417);

	Object.keys(_google).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function get() {
	      return _google[key];
	    }
	  });
	});

	var _linkedin = __webpack_require__(418);

	Object.keys(_linkedin).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function get() {
	      return _linkedin[key];
	    }
	  });
	});

	var _mic = __webpack_require__(419);

	Object.keys(_mic).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function get() {
	      return _mic[key];
	    }
	  });
	});

	var _windows = __webpack_require__(421);

	Object.keys(_windows).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function get() {
	      return _windows[key];
	    }
	  });
	});

/***/ },
/* 412 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	/**
	 * @private
	 * Enum for Social Identities
	 */
	var SocialIdentity = {
	  Facebook: 'facebook',
	  Google: 'google',
	  Kinvey: process && process.env && process.env.KINVEY_IDENTITY || 'kinvey' || 'kinvey',
	  LinkedIn: 'linkedin',
	  MobileIdentityConnect: process && process.env && process.env.KINVEY_MIC_IDENTITY || 'kinveyAuth' || 'kinveyAuth',
	  Windows: 'windows'
	};
	Object.freeze(SocialIdentity);
	exports.SocialIdentity = SocialIdentity;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 413 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Facebook = undefined;

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _social = __webpack_require__(414);

	var _enums = __webpack_require__(412);

	var _errors = __webpack_require__(11);

	var _utils = __webpack_require__(13);

	var _promise = __webpack_require__(286);

	var _promise2 = _interopRequireDefault(_promise);

	var _regeneratorRuntime = __webpack_require__(148);

	var _regeneratorRuntime2 = _interopRequireDefault(_regeneratorRuntime);

	var _assign = __webpack_require__(211);

	var _assign2 = _interopRequireDefault(_assign);

	var _querystring = __webpack_require__(208);

	var _querystring2 = _interopRequireDefault(_querystring);

	var _url = __webpack_require__(206);

	var _url2 = _interopRequireDefault(_url);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new _promise2.default(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return _promise2.default.resolve(value).then(function (value) { return step("next", value); }, function (err) { return step("throw", err); }); } } return step("next"); }); }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* eslint-disable camelcase */
	// eslint-disable-line no-unused-vars


	/**
	 * @private
	 */
	var Facebook = exports.Facebook = function (_Social) {
	  _inherits(Facebook, _Social);

	  function Facebook() {
	    _classCallCheck(this, Facebook);

	    return _possibleConstructorReturn(this, (Facebook.__proto__ || Object.getPrototypeOf(Facebook)).apply(this, arguments));
	  }

	  _createClass(Facebook, [{
	    key: 'isSupported',
	    value: function isSupported() {
	      return !!_utils.Popup;
	    }
	  }, {
	    key: 'login',
	    value: function () {
	      var _ref = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee(clientId) {
	        var _this2 = this;

	        var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
	        var session, promise;
	        return _regeneratorRuntime2.default.wrap(function _callee$(_context) {
	          while (1) {
	            switch (_context.prev = _context.next) {
	              case 0:
	                options = (0, _assign2.default)({
	                  force: false,
	                  scope: 'public_profile'
	                }, options);

	                if (this.isSupported()) {
	                  _context.next = 3;
	                  break;
	                }

	                throw new _errors.KinveyError('Unable to login with ' + this.identity + '. It is not supported on this platform.');

	              case 3:
	                session = this.session;

	                if (!(session && this.isOnline(session))) {
	                  _context.next = 6;
	                  break;
	                }

	                return _context.abrupt('return', session);

	              case 6:
	                if (clientId) {
	                  _context.next = 8;
	                  break;
	                }

	                throw new _errors.KinveyError('Unable to login with ' + this.identity + '. ' + ' No client id was provided.');

	              case 8:
	                promise = new _promise2.default(function (resolve, reject) {
	                  var redirectUri = options.redirectUri || global.location.href;
	                  var originalState = (0, _utils.randomString)();
	                  var popup = new _utils.Popup();
	                  var redirected = false;

	                  // Handle the response from a login request
	                  var oauthCallback = function oauthCallback(urlString) {
	                    var _url$parse = _url2.default.parse(urlString);

	                    var hash = _url$parse.hash;

	                    var _querystring$parse = _querystring2.default.parse(hash.substring(1));

	                    var access_token = _querystring$parse.access_token;
	                    var expires_in = _querystring$parse.expires_in;
	                    var error = _querystring$parse.error;
	                    var error_description = _querystring$parse.error_description;
	                    var error_reason = _querystring$parse.error_reason;
	                    var state = _querystring$parse.state;

	                    var expiresIn = parseInt(expires_in, 10);
	                    var expires = new Date().getTime() / 1e3 + (expiresIn || 60 * 60 * 24 * 365);

	                    if (state === originalState) {
	                      if (access_token) {
	                        var _session = {
	                          access_token: access_token,
	                          expires_in: expiresIn,
	                          expires: expires,
	                          client_id: clientId
	                        };
	                        _this2.session = _session;
	                        resolve(_session);
	                      } else if (error) {
	                        _this2.session = null;
	                        reject({ reason: error_reason, error: error, description: error_description });
	                      } else {
	                        _this2.session = null;
	                        reject({ reason: 'not_authorized', error: 'access_denied', description: 'Your app is not authorized.' });
	                      }
	                    } else {
	                      _this2.session = null;
	                      reject({ reason: 'state_mismatch', error: 'access_denied', description: 'The state did not match.' });
	                    }
	                  };

	                  function loadCallback(event) {
	                    var urlString = event.url;

	                    try {
	                      if (urlString && urlString.indexOf(redirectUri) === 0 && redirected === false) {
	                        redirected = true;
	                        popup.removeAllListeners();
	                        popup.close();
	                        oauthCallback(urlString);
	                      }
	                    } catch (error) {
	                      // Just catch the error
	                    }
	                  }

	                  function errorCallback(event) {
	                    var urlString = event.url;

	                    try {
	                      if (urlString && urlString.indexOf(redirectUri) === 0 && redirected === false) {
	                        redirected = true;
	                        popup.removeAllListeners();
	                        popup.close();
	                        oauthCallback(urlString);
	                      } else if (redirected === false) {
	                        popup.removeAllListeners();
	                        popup.close();
	                        reject(new _errors.KinveyError(event.message, '', event.code));
	                      }
	                    } catch (error) {
	                      // Just catch the error
	                    }
	                  }

	                  function closedCallback() {
	                    if (redirected === false) {
	                      popup.removeAllListeners();
	                      reject(new _errors.KinveyError('Facebook login has been cancelled.'));
	                    }
	                  }

	                  popup.on('loadstart', loadCallback);
	                  popup.on('loadstop', loadCallback);
	                  popup.on('error', errorCallback);
	                  popup.on('closed', closedCallback);
	                  popup.open(_url2.default.format({
	                    protocol: 'https:',
	                    host: 'www.facebook.com',
	                    pathname: '/dialog/oauth',
	                    query: {
	                      client_id: clientId,
	                      redirect_uri: redirectUri,
	                      response_type: 'token',
	                      scope: options.scope,
	                      auth_type: options.force === true ? 'rerequest' : null,
	                      state: originalState
	                    }
	                  }));
	                });
	                return _context.abrupt('return', promise);

	              case 10:
	              case 'end':
	                return _context.stop();
	            }
	          }
	        }, _callee, this);
	      }));

	      function login(_x, _x2) {
	        return _ref.apply(this, arguments);
	      }

	      return login;
	    }()
	  }, {
	    key: 'logout',
	    value: function () {
	      var _ref2 = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee2() {
	        return _regeneratorRuntime2.default.wrap(function _callee2$(_context2) {
	          while (1) {
	            switch (_context2.prev = _context2.next) {
	              case 0:
	                this.session = null;

	              case 1:
	              case 'end':
	                return _context2.stop();
	            }
	          }
	        }, _callee2, this);
	      }));

	      function logout() {
	        return _ref2.apply(this, arguments);
	      }

	      return logout;
	    }()
	  }, {
	    key: 'identity',
	    get: function get() {
	      return _enums.SocialIdentity.Facebook;
	    }
	  }], [{
	    key: 'identity',
	    get: function get() {
	      return _enums.SocialIdentity.Facebook;
	    }
	  }]);

	  return Facebook;
	}(_social.Social);
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 414 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Social = undefined;

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // eslint-disable-line no-unused-vars


	var _client = __webpack_require__(10);

	var _errors = __webpack_require__(11);

	var _localStorage = __webpack_require__(201);

	var _localStorage2 = _interopRequireDefault(_localStorage);

	var _regeneratorRuntime = __webpack_require__(148);

	var _regeneratorRuntime2 = _interopRequireDefault(_regeneratorRuntime);

	var _assign = __webpack_require__(211);

	var _assign2 = _interopRequireDefault(_assign);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { return step("next", value); }, function (err) { return step("throw", err); }); } } return step("next"); }); }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var hello = void 0;

	if (typeof window !== 'undefined') {
	  hello = __webpack_require__(415); // eslint-disable-line global-require
	}

	/**
	 * @private
	 */

	var Social = exports.Social = function () {
	  function Social() {
	    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

	    _classCallCheck(this, Social);

	    this.client = options.client || _client.Client.sharedInstance();
	  }

	  _createClass(Social, [{
	    key: 'isSupported',
	    value: function isSupported() {
	      return !!hello;
	    }
	  }, {
	    key: 'isOnline',
	    value: function isOnline(session) {
	      var currentTime = new Date().getTime() / 1000;
	      return session && session.access_token && session.expires > currentTime;
	    }
	  }, {
	    key: 'login',
	    value: function () {
	      var _ref = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee(clientId) {
	        var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
	        var session, helloSettings;
	        return _regeneratorRuntime2.default.wrap(function _callee$(_context) {
	          while (1) {
	            switch (_context.prev = _context.next) {
	              case 0:
	                options = (0, _assign2.default)({
	                  redirectUri: global.location.href,
	                  scope: null,
	                  force: null
	                }, options);

	                if (this.isSupported()) {
	                  _context.next = 3;
	                  break;
	                }

	                throw new _errors.KinveyError('Unable to login with ' + this.identity + '. It is not supported on this platform.');

	              case 3:
	                session = this.session;

	                if (!(session && this.isOnline(session))) {
	                  _context.next = 6;
	                  break;
	                }

	                return _context.abrupt('return', session);

	              case 6:
	                if (clientId) {
	                  _context.next = 8;
	                  break;
	                }

	                throw new _errors.KinveyError('Unable to login with ' + this.identity + '. ' + ' No client id was provided.');

	              case 8:
	                helloSettings = {};

	                helloSettings[this.identity] = clientId;
	                hello.init(helloSettings);
	                _context.next = 13;
	                return hello(this.identity).login({
	                  redirect_uri: options.redirectUri,
	                  scope: options.scope,
	                  force: options.force
	                });

	              case 13:
	                session = hello(this.identity).getAuthResponse();
	                session.clientId = clientId;
	                this.session = session;
	                return _context.abrupt('return', session);

	              case 17:
	              case 'end':
	                return _context.stop();
	            }
	          }
	        }, _callee, this);
	      }));

	      function login(_x2, _x3) {
	        return _ref.apply(this, arguments);
	      }

	      return login;
	    }()
	  }, {
	    key: 'logout',
	    value: function () {
	      var _ref2 = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee2() {
	        var helloSettings;
	        return _regeneratorRuntime2.default.wrap(function _callee2$(_context2) {
	          while (1) {
	            switch (_context2.prev = _context2.next) {
	              case 0:
	                if (!this.isSupported()) {
	                  _context2.next = 6;
	                  break;
	                }

	                helloSettings = {};

	                helloSettings[this.identity] = this.session.clientId;
	                hello.init(helloSettings);
	                _context2.next = 6;
	                return hello(this.identity).logout();

	              case 6:

	                this.session = null;

	              case 7:
	              case 'end':
	                return _context2.stop();
	            }
	          }
	        }, _callee2, this);
	      }));

	      function logout() {
	        return _ref2.apply(this, arguments);
	      }

	      return logout;
	    }()
	  }, {
	    key: 'identity',
	    get: function get() {
	      throw new _errors.KinveyError('A subclass must override this property.');
	    }
	  }, {
	    key: 'session',
	    get: function get() {
	      return _localStorage2.default.get('' + this.client.appKey + this.identity);
	    },
	    set: function set(session) {
	      if (session) {
	        _localStorage2.default.set('' + this.client.appKey + this.identity, session);
	      } else {
	        _localStorage2.default.remove('' + this.client.appKey + this.identity);
	      }
	    }
	  }], [{
	    key: 'login',
	    value: function login(clientId, options) {
	      var social = new this(options);
	      return social.login(clientId, options);
	    }
	  }, {
	    key: 'logout',
	    value: function logout(user, options) {
	      var social = new this();
	      return social.logout(user, options);
	    }
	  }, {
	    key: 'identity',
	    get: function get() {
	      throw new _errors.KinveyError('A subclass must override this property.');
	    }
	  }]);

	  return Social;
	}();
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 415 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(process, setImmediate, console) {/*! hellojs v1.14.0 | (c) 2012-2016 Andrew Dodson | MIT https://adodson.com/hello.js/LICENSE */
	// ES5 Object.create
	if (!Object.create) {

		// Shim, Object create
		// A shim for Object.create(), it adds a prototype to a new object
		Object.create = (function() {

			function F() {}

			return function(o) {

				if (arguments.length != 1) {
					throw new Error('Object.create implementation only accepts one parameter.');
				}

				F.prototype = o;
				return new F();
			};

		})();

	}

	// ES5 Object.keys
	if (!Object.keys) {
		Object.keys = function(o, k, r) {
			r = [];
			for (k in o) {
				if (r.hasOwnProperty.call(o, k))
					r.push(k);
			}

			return r;
		};
	}

	// ES5 [].indexOf
	if (!Array.prototype.indexOf) {
		Array.prototype.indexOf = function(s) {

			for (var j = 0; j < this.length; j++) {
				if (this[j] === s) {
					return j;
				}
			}

			return -1;
		};
	}

	// ES5 [].forEach
	if (!Array.prototype.forEach) {
		Array.prototype.forEach = function(fun/*, thisArg*/) {

			if (this === void 0 || this === null) {
				throw new TypeError();
			}

			var t = Object(this);
			var len = t.length >>> 0;
			if (typeof fun !== 'function') {
				throw new TypeError();
			}

			var thisArg = arguments.length >= 2 ? arguments[1] : void 0;
			for (var i = 0; i < len; i++) {
				if (i in t) {
					fun.call(thisArg, t[i], i, t);
				}
			}

			return this;
		};
	}

	// ES5 [].filter
	if (!Array.prototype.filter) {
		Array.prototype.filter = function(fun, thisArg) {

			var a = [];
			this.forEach(function(val, i, t) {
				if (fun.call(thisArg || void 0, val, i, t)) {
					a.push(val);
				}
			});

			return a;
		};
	}

	// Production steps of ECMA-262, Edition 5, 15.4.4.19
	// Reference: http://es5.github.io/#x15.4.4.19
	if (!Array.prototype.map) {

		Array.prototype.map = function(fun, thisArg) {

			var a = [];
			this.forEach(function(val, i, t) {
				a.push(fun.call(thisArg || void 0, val, i, t));
			});

			return a;
		};
	}

	// ES5 isArray
	if (!Array.isArray) {

		// Function Array.isArray
		Array.isArray = function(o) {
			return Object.prototype.toString.call(o) === '[object Array]';
		};

	}

	// Test for location.assign
	if (typeof window === 'object' && typeof window.location === 'object' && !window.location.assign) {

		window.location.assign = function(url) {
			window.location = url;
		};

	}

	// Test for Function.bind
	if (!Function.prototype.bind) {

		// MDN
		// Polyfill IE8, does not support native Function.bind
		Function.prototype.bind = function(b) {

			if (typeof this !== 'function') {
				throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');
			}

			function C() {}

			var a = [].slice;
			var f = a.call(arguments, 1);
			var _this = this;
			var D = function() {
				return _this.apply(this instanceof C ? this : b || window, f.concat(a.call(arguments)));
			};

			C.prototype = this.prototype;
			D.prototype = new C();

			return D;
		};

	}

	/**
	 * @hello.js
	 *
	 * HelloJS is a client side Javascript SDK for making OAuth2 logins and subsequent REST calls.
	 *
	 * @author Andrew Dodson
	 * @website https://adodson.com/hello.js/
	 *
	 * @copyright Andrew Dodson, 2012 - 2015
	 * @license MIT: You are free to use and modify this code for any use, on the condition that this copyright notice remains.
	 */

	var hello = function(name) {
		return hello.use(name);
	};

	hello.utils = {

		// Extend the first object with the properties and methods of the second
		extend: function(r /*, a[, b[, ...]] */) {

			// Get the arguments as an array but ommit the initial item
			Array.prototype.slice.call(arguments, 1).forEach(function(a) {
				if (Array.isArray(r) && Array.isArray(a)) {
					Array.prototype.push.apply(r, a);
				}
				else if (r instanceof Object && a instanceof Object && r !== a) {
					for (var x in a) {
						r[x] = hello.utils.extend(r[x], a[x]);
					}
				}
				else {

					if (Array.isArray(a)) {
						// Clone it
						a = a.slice(0);
					}

					r = a;
				}
			});

			return r;
		}
	};

	// Core library
	hello.utils.extend(hello, {

		settings: {

			// OAuth2 authentication defaults
			redirect_uri: window.location.href.split('#')[0],
			response_type: 'token',
			display: 'popup',
			state: '',

			// OAuth1 shim
			// The path to the OAuth1 server for signing user requests
			// Want to recreate your own? Checkout https://github.com/MrSwitch/node-oauth-shim
			oauth_proxy: 'https://auth-server.herokuapp.com/proxy',

			// API timeout in milliseconds
			timeout: 20000,

			// Popup Options
			popup: {
				resizable: 1,
				scrollbars: 1,
				width: 500,
				height: 550
			},

			// Default scope
			// Many services require atleast a profile scope,
			// HelloJS automatially includes the value of provider.scope_map.basic
			// If that's not required it can be removed via hello.settings.scope.length = 0;
			scope: ['basic'],

			// Scope Maps
			// This is the default module scope, these are the defaults which each service is mapped too.
			// By including them here it prevents the scope from being applied accidentally
			scope_map: {
				basic: ''
			},

			// Default service / network
			default_service: null,

			// Force authentication
			// When hello.login is fired.
			// (null): ignore current session expiry and continue with login
			// (true): ignore current session expiry and continue with login, ask for user to reauthenticate
			// (false): if the current session looks good for the request scopes return the current session.
			force: null,

			// Page URL
			// When 'display=page' this property defines where the users page should end up after redirect_uri
			// Ths could be problematic if the redirect_uri is indeed the final place,
			// Typically this circumvents the problem of the redirect_url being a dumb relay page.
			page_uri: window.location.href
		},

		// Service configuration objects
		services: {},

		// Use
		// Define a new instance of the HelloJS library with a default service
		use: function(service) {

			// Create self, which inherits from its parent
			var self = Object.create(this);

			// Inherit the prototype from its parent
			self.settings = Object.create(this.settings);

			// Define the default service
			if (service) {
				self.settings.default_service = service;
			}

			// Create an instance of Events
			self.utils.Event.call(self);

			return self;
		},

		// Initialize
		// Define the client_ids for the endpoint services
		// @param object o, contains a key value pair, service => clientId
		// @param object opts, contains a key value pair of options used for defining the authentication defaults
		// @param number timeout, timeout in seconds
		init: function(services, options) {

			var utils = this.utils;

			if (!services) {
				return this.services;
			}

			// Define provider credentials
			// Reformat the ID field
			for (var x in services) {if (services.hasOwnProperty(x)) {
				if (typeof (services[x]) !== 'object') {
					services[x] = {id: services[x]};
				}
			}}

			// Merge services if there already exists some
			utils.extend(this.services, services);

			// Update the default settings with this one.
			if (options) {
				utils.extend(this.settings, options);

				// Do this immediatly incase the browser changes the current path.
				if ('redirect_uri' in options) {
					this.settings.redirect_uri = utils.url(options.redirect_uri).href;
				}
			}

			return this;
		},

		// Login
		// Using the endpoint
		// @param network stringify       name to connect to
		// @param options object    (optional)  {display mode, is either none|popup(default)|page, scope: email,birthday,publish, .. }
		// @param callback  function  (optional)  fired on signin
		login: function() {

			// Create an object which inherits its parent as the prototype and constructs a new event chain.
			var _this = this;
			var utils = _this.utils;
			var error = utils.error;
			var promise = utils.Promise();

			// Get parameters
			var p = utils.args({network: 's', options: 'o', callback: 'f'}, arguments);

			// Local vars
			var url;

			// Get all the custom options and store to be appended to the querystring
			var qs = utils.diffKey(p.options, _this.settings);

			// Merge/override options with app defaults
			var opts = p.options = utils.merge(_this.settings, p.options || {});

			// Merge/override options with app defaults
			opts.popup = utils.merge(_this.settings.popup, p.options.popup || {});

			// Network
			p.network = p.network || _this.settings.default_service;

			// Bind callback to both reject and fulfill states
			promise.proxy.then(p.callback, p.callback);

			// Trigger an event on the global listener
			function emit(s, value) {
				hello.emit(s, value);
			}

			promise.proxy.then(emit.bind(this, 'auth.login auth'), emit.bind(this, 'auth.failed auth'));

			// Is our service valid?
			if (typeof (p.network) !== 'string' || !(p.network in _this.services)) {
				// Trigger the default login.
				// Ahh we dont have one.
				return promise.reject(error('invalid_network', 'The provided network was not recognized'));
			}

			var provider = _this.services[p.network];

			// Create a global listener to capture events triggered out of scope
			var callbackId = utils.globalEvent(function(str) {

				// The responseHandler returns a string, lets save this locally
				var obj;

				if (str) {
					obj = JSON.parse(str);
				}
				else {
					obj = error('cancelled', 'The authentication was not completed');
				}

				// Handle these response using the local
				// Trigger on the parent
				if (!obj.error) {

					// Save on the parent window the new credentials
					// This fixes an IE10 bug i think... atleast it does for me.
					utils.store(obj.network, obj);

					// Fulfill a successful login
					promise.fulfill({
						network: obj.network,
						authResponse: obj
					});
				}
				else {
					// Reject a successful login
					promise.reject(obj);
				}
			});

			var redirectUri = utils.url(opts.redirect_uri).href;

			// May be a space-delimited list of multiple, complementary types
			var responseType = provider.oauth.response_type || opts.response_type;

			// Fallback to token if the module hasn't defined a grant url
			if (/\bcode\b/.test(responseType) && !provider.oauth.grant) {
				responseType = responseType.replace(/\bcode\b/, 'token');
			}

			// Query string parameters, we may pass our own arguments to form the querystring
			p.qs = utils.merge(qs, {
				client_id: encodeURIComponent(provider.id),
				response_type: encodeURIComponent(responseType),
				redirect_uri: encodeURIComponent(redirectUri),
				state: {
					client_id: provider.id,
					network: p.network,
					display: opts.display,
					callback: callbackId,
					state: opts.state,
					redirect_uri: redirectUri
				}
			});

			// Get current session for merging scopes, and for quick auth response
			var session = utils.store(p.network);

			// Scopes (authentication permisions)
			// Ensure this is a string - IE has a problem moving Arrays between windows
			// Append the setup scope
			var SCOPE_SPLIT = /[,\s]+/;

			// Include default scope settings (cloned).
			var scope = _this.settings.scope ? [_this.settings.scope.toString()] : [];

			// Extend the providers scope list with the default
			var scopeMap = utils.merge(_this.settings.scope_map, provider.scope || {});

			// Add user defined scopes...
			if (opts.scope) {
				scope.push(opts.scope.toString());
			}

			// Append scopes from a previous session.
			// This helps keep app credentials constant,
			// Avoiding having to keep tabs on what scopes are authorized
			if (session && 'scope' in session && session.scope instanceof String) {
				scope.push(session.scope);
			}

			// Join and Split again
			scope = scope.join(',').split(SCOPE_SPLIT);

			// Format remove duplicates and empty values
			scope = utils.unique(scope).filter(filterEmpty);

			// Save the the scopes to the state with the names that they were requested with.
			p.qs.state.scope = scope.join(',');

			// Map scopes to the providers naming convention
			scope = scope.map(function(item) {
				// Does this have a mapping?
				return (item in scopeMap) ? scopeMap[item] : item;
			});

			// Stringify and Arrayify so that double mapped scopes are given the chance to be formatted
			scope = scope.join(',').split(SCOPE_SPLIT);

			// Again...
			// Format remove duplicates and empty values
			scope = utils.unique(scope).filter(filterEmpty);

			// Join with the expected scope delimiter into a string
			p.qs.scope = scope.join(provider.scope_delim || ',');

			// Is the user already signed in with the appropriate scopes, valid access_token?
			if (opts.force === false) {

				if (session && 'access_token' in session && session.access_token && 'expires' in session && session.expires > ((new Date()).getTime() / 1e3)) {
					// What is different about the scopes in the session vs the scopes in the new login?
					var diff = utils.diff((session.scope || '').split(SCOPE_SPLIT), (p.qs.state.scope || '').split(SCOPE_SPLIT));
					if (diff.length === 0) {

						// OK trigger the callback
						promise.fulfill({
							unchanged: true,
							network: p.network,
							authResponse: session
						});

						// Nothing has changed
						return promise;
					}
				}
			}

			// Page URL
			if (opts.display === 'page' && opts.page_uri) {
				// Add a page location, place to endup after session has authenticated
				p.qs.state.page_uri = utils.url(opts.page_uri).href;
			}

			// Bespoke
			// Override login querystrings from auth_options
			if ('login' in provider && typeof (provider.login) === 'function') {
				// Format the paramaters according to the providers formatting function
				provider.login(p);
			}

			// Add OAuth to state
			// Where the service is going to take advantage of the oauth_proxy
			if (!/\btoken\b/.test(responseType) ||
			parseInt(provider.oauth.version, 10) < 2 ||
			(opts.display === 'none' && provider.oauth.grant && session && session.refresh_token)) {

				// Add the oauth endpoints
				p.qs.state.oauth = provider.oauth;

				// Add the proxy url
				p.qs.state.oauth_proxy = opts.oauth_proxy;

			}

			// Convert state to a string
			p.qs.state = encodeURIComponent(JSON.stringify(p.qs.state));

			// URL
			if (parseInt(provider.oauth.version, 10) === 1) {

				// Turn the request to the OAuth Proxy for 3-legged auth
				url = utils.qs(opts.oauth_proxy, p.qs, encodeFunction);
			}

			// Refresh token
			else if (opts.display === 'none' && provider.oauth.grant && session && session.refresh_token) {

				// Add the refresh_token to the request
				p.qs.refresh_token = session.refresh_token;

				// Define the request path
				url = utils.qs(opts.oauth_proxy, p.qs, encodeFunction);
			}
			else {
				url = utils.qs(provider.oauth.auth, p.qs, encodeFunction);
			}

			// Broadcast this event as an auth:init
			emit('auth.init', p);

			// Execute
			// Trigger how we want self displayed
			if (opts.display === 'none') {
				// Sign-in in the background, iframe
				utils.iframe(url, redirectUri);
			}

			// Triggering popup?
			else if (opts.display === 'popup') {

				var popup = utils.popup(url, redirectUri, opts.popup);

				var timer = setInterval(function() {
					if (!popup || popup.closed) {
						clearInterval(timer);
						if (!promise.state) {

							var response = error('cancelled', 'Login has been cancelled');

							if (!popup) {
								response = error('blocked', 'Popup was blocked');
							}

							response.network = p.network;

							promise.reject(response);
						}
					}
				}, 100);
			}

			else {
				window.location = url;
			}

			return promise.proxy;

			function encodeFunction(s) {return s;}

			function filterEmpty(s) {return !!s;}
		},

		// Remove any data associated with a given service
		// @param string name of the service
		// @param function callback
		logout: function() {

			var _this = this;
			var utils = _this.utils;
			var error = utils.error;

			// Create a new promise
			var promise = utils.Promise();

			var p = utils.args({name:'s', options: 'o', callback: 'f'}, arguments);

			p.options = p.options || {};

			// Add callback to events
			promise.proxy.then(p.callback, p.callback);

			// Trigger an event on the global listener
			function emit(s, value) {
				hello.emit(s, value);
			}

			promise.proxy.then(emit.bind(this, 'auth.logout auth'), emit.bind(this, 'error'));

			// Network
			p.name = p.name || this.settings.default_service;
			p.authResponse = utils.store(p.name);

			if (p.name && !(p.name in _this.services)) {

				promise.reject(error('invalid_network', 'The network was unrecognized'));

			}
			else if (p.name && p.authResponse) {

				// Define the callback
				var callback = function(opts) {

					// Remove from the store
					utils.store(p.name, null);

					// Emit events by default
					promise.fulfill(hello.utils.merge({network:p.name}, opts || {}));
				};

				// Run an async operation to remove the users session
				var _opts = {};
				if (p.options.force) {
					var logout = _this.services[p.name].logout;
					if (logout) {
						// Convert logout to URL string,
						// If no string is returned, then this function will handle the logout async style
						if (typeof (logout) === 'function') {
							logout = logout(callback, p);
						}

						// If logout is a string then assume URL and open in iframe.
						if (typeof (logout) === 'string') {
							utils.iframe(logout);
							_opts.force = null;
							_opts.message = 'Logout success on providers site was indeterminate';
						}
						else if (logout === undefined) {
							// The callback function will handle the response.
							return promise.proxy;
						}
					}
				}

				// Remove local credentials
				callback(_opts);
			}
			else {
				promise.reject(error('invalid_session', 'There was no session to remove'));
			}

			return promise.proxy;
		},

		// Returns all the sessions that are subscribed too
		// @param string optional, name of the service to get information about.
		getAuthResponse: function(service) {

			// If the service doesn't exist
			service = service || this.settings.default_service;

			if (!service || !(service in this.services)) {
				return null;
			}

			return this.utils.store(service) || null;
		},

		// Events: placeholder for the events
		events: {}
	});

	// Core utilities
	hello.utils.extend(hello.utils, {

		// Error
		error: function(code, message) {
			return {
				error: {
					code: code,
					message: message
				}
			};
		},

		// Append the querystring to a url
		// @param string url
		// @param object parameters
		qs: function(url, params, formatFunction) {

			if (params) {

				// Set default formatting function
				formatFunction = formatFunction || encodeURIComponent;

				// Override the items in the URL which already exist
				for (var x in params) {
					var str = '([\\?\\&])' + x + '=[^\\&]*';
					var reg = new RegExp(str);
					if (url.match(reg)) {
						url = url.replace(reg, '$1' + x + '=' + formatFunction(params[x]));
						delete params[x];
					}
				}
			}

			if (!this.isEmpty(params)) {
				return url + (url.indexOf('?') > -1 ? '&' : '?') + this.param(params, formatFunction);
			}

			return url;
		},

		// Param
		// Explode/encode the parameters of an URL string/object
		// @param string s, string to decode
		param: function(s, formatFunction) {
			var b;
			var a = {};
			var m;

			if (typeof (s) === 'string') {

				formatFunction = formatFunction || decodeURIComponent;

				m = s.replace(/^[\#\?]/, '').match(/([^=\/\&]+)=([^\&]+)/g);
				if (m) {
					for (var i = 0; i < m.length; i++) {
						b = m[i].match(/([^=]+)=(.*)/);
						a[b[1]] = formatFunction(b[2]);
					}
				}

				return a;
			}
			else {

				formatFunction = formatFunction || encodeURIComponent;

				var o = s;

				a = [];

				for (var x in o) {if (o.hasOwnProperty(x)) {
					if (o.hasOwnProperty(x)) {
						a.push([x, o[x] === '?' ? '?' : formatFunction(o[x])].join('='));
					}
				}}

				return a.join('&');
			}
		},

		// Local storage facade
		store: (function() {

			var a = ['localStorage', 'sessionStorage'];
			var i = -1;
			var prefix = 'test';

			// Set LocalStorage
			var localStorage;

			while (a[++i]) {
				try {
					// In Chrome with cookies blocked, calling localStorage throws an error
					localStorage = window[a[i]];
					localStorage.setItem(prefix + i, i);
					localStorage.removeItem(prefix + i);
					break;
				}
				catch (e) {
					localStorage = null;
				}
			}

			if (!localStorage) {

				var cache = null;

				localStorage = {
					getItem: function(prop) {
						prop = prop + '=';
						var m = document.cookie.split(';');
						for (var i = 0; i < m.length; i++) {
							var _m = m[i].replace(/(^\s+|\s+$)/, '');
							if (_m && _m.indexOf(prop) === 0) {
								return _m.substr(prop.length);
							}
						}

						return cache;
					},

					setItem: function(prop, value) {
						cache = value;
						document.cookie = prop + '=' + value;
					}
				};

				// Fill the cache up
				cache = localStorage.getItem('hello');
			}

			function get() {
				var json = {};
				try {
					json = JSON.parse(localStorage.getItem('hello')) || {};
				}
				catch (e) {}

				return json;
			}

			function set(json) {
				localStorage.setItem('hello', JSON.stringify(json));
			}

			// Check if the browser support local storage
			return function(name, value, days) {

				// Local storage
				var json = get();

				if (name && value === undefined) {
					return json[name] || null;
				}
				else if (name && value === null) {
					try {
						delete json[name];
					}
					catch (e) {
						json[name] = null;
					}
				}
				else if (name) {
					json[name] = value;
				}
				else {
					return json;
				}

				set(json);

				return json || null;
			};

		})(),

		// Create and Append new DOM elements
		// @param node string
		// @param attr object literal
		// @param dom/string
		append: function(node, attr, target) {

			var n = typeof (node) === 'string' ? document.createElement(node) : node;

			if (typeof (attr) === 'object') {
				if ('tagName' in attr) {
					target = attr;
				}
				else {
					for (var x in attr) {if (attr.hasOwnProperty(x)) {
						if (typeof (attr[x]) === 'object') {
							for (var y in attr[x]) {if (attr[x].hasOwnProperty(y)) {
								n[x][y] = attr[x][y];
							}}
						}
						else if (x === 'html') {
							n.innerHTML = attr[x];
						}

						// IE doesn't like us setting methods with setAttribute
						else if (!/^on/.test(x)) {
							n.setAttribute(x, attr[x]);
						}
						else {
							n[x] = attr[x];
						}
					}}
				}
			}

			if (target === 'body') {
				(function self() {
					if (document.body) {
						document.body.appendChild(n);
					}
					else {
						setTimeout(self, 16);
					}
				})();
			}
			else if (typeof (target) === 'object') {
				target.appendChild(n);
			}
			else if (typeof (target) === 'string') {
				document.getElementsByTagName(target)[0].appendChild(n);
			}

			return n;
		},

		// An easy way to create a hidden iframe
		// @param string src
		iframe: function(src) {
			this.append('iframe', {src: src, style: {position:'absolute', left: '-1000px', bottom: 0, height: '1px', width: '1px'}}, 'body');
		},

		// Recursive merge two objects into one, second parameter overides the first
		// @param a array
		merge: function(/* Args: a, b, c, .. n */) {
			var args = Array.prototype.slice.call(arguments);
			args.unshift({});
			return this.extend.apply(null, args);
		},

		// Makes it easier to assign parameters, where some are optional
		// @param o object
		// @param a arguments
		args: function(o, args) {

			var p = {};
			var i = 0;
			var t = null;
			var x = null;

			// 'x' is the first key in the list of object parameters
			for (x in o) {if (o.hasOwnProperty(x)) {
				break;
			}}

			// Passing in hash object of arguments?
			// Where the first argument can't be an object
			if ((args.length === 1) && (typeof (args[0]) === 'object') && o[x] != 'o!') {

				// Could this object still belong to a property?
				// Check the object keys if they match any of the property keys
				for (x in args[0]) {if (o.hasOwnProperty(x)) {
					// Does this key exist in the property list?
					if (x in o) {
						// Yes this key does exist so its most likely this function has been invoked with an object parameter
						// Return first argument as the hash of all arguments
						return args[0];
					}
				}}
			}

			// Else loop through and account for the missing ones.
			for (x in o) {if (o.hasOwnProperty(x)) {

				t = typeof (args[i]);

				if ((typeof (o[x]) === 'function' && o[x].test(args[i])) || (typeof (o[x]) === 'string' && (
				(o[x].indexOf('s') > -1 && t === 'string') ||
				(o[x].indexOf('o') > -1 && t === 'object') ||
				(o[x].indexOf('i') > -1 && t === 'number') ||
				(o[x].indexOf('a') > -1 && t === 'object') ||
				(o[x].indexOf('f') > -1 && t === 'function')
				))
				) {
					p[x] = args[i++];
				}

				else if (typeof (o[x]) === 'string' && o[x].indexOf('!') > -1) {
					return false;
				}
			}}

			return p;
		},

		// Returns a URL instance
		url: function(path) {

			// If the path is empty
			if (!path) {
				return window.location;
			}

			// Chrome and FireFox support new URL() to extract URL objects
			else if (window.URL && URL instanceof Function && URL.length !== 0) {
				return new URL(path, window.location);
			}

			// Ugly shim, it works!
			else {
				var a = document.createElement('a');
				a.href = path;
				return a.cloneNode(false);
			}
		},

		diff: function(a, b) {
			return b.filter(function(item) {
				return a.indexOf(item) === -1;
			});
		},

		// Get the different hash of properties unique to `a`, and not in `b`
		diffKey: function(a, b) {
			if (a || !b) {
				var r = {};
				for (var x in a) {
					// Does the property not exist?
					if (!(x in b)) {
						r[x] = a[x];
					}
				}

				return r;
			}

			return a;
		},

		// Unique
		// Remove duplicate and null values from an array
		// @param a array
		unique: function(a) {
			if (!Array.isArray(a)) { return []; }

			return a.filter(function(item, index) {
				// Is this the first location of item
				return a.indexOf(item) === index;
			});
		},

		isEmpty: function(obj) {

			// Scalar
			if (!obj)
				return true;

			// Array
			if (Array.isArray(obj)) {
				return !obj.length;
			}
			else if (typeof (obj) === 'object') {
				// Object
				for (var key in obj) {
					if (obj.hasOwnProperty(key)) {
						return false;
					}
				}
			}

			return true;
		},

		//jscs:disable

		/*!
		 **  Thenable -- Embeddable Minimum Strictly-Compliant Promises/A+ 1.1.1 Thenable
		 **  Copyright (c) 2013-2014 Ralf S. Engelschall <http://engelschall.com>
		 **  Licensed under The MIT License <http://opensource.org/licenses/MIT>
		 **  Source-Code distributed on <http://github.com/rse/thenable>
		 */
		Promise: (function(){
			/*  promise states [Promises/A+ 2.1]  */
			var STATE_PENDING   = 0;                                         /*  [Promises/A+ 2.1.1]  */
			var STATE_FULFILLED = 1;                                         /*  [Promises/A+ 2.1.2]  */
			var STATE_REJECTED  = 2;                                         /*  [Promises/A+ 2.1.3]  */

			/*  promise object constructor  */
			var api = function (executor) {
				/*  optionally support non-constructor/plain-function call  */
				if (!(this instanceof api))
					return new api(executor);

				/*  initialize object  */
				this.id           = "Thenable/1.0.6";
				this.state        = STATE_PENDING; /*  initial state  */
				this.fulfillValue = undefined;     /*  initial value  */     /*  [Promises/A+ 1.3, 2.1.2.2]  */
				this.rejectReason = undefined;     /*  initial reason */     /*  [Promises/A+ 1.5, 2.1.3.2]  */
				this.onFulfilled  = [];            /*  initial handlers  */
				this.onRejected   = [];            /*  initial handlers  */

				/*  provide optional information-hiding proxy  */
				this.proxy = {
					then: this.then.bind(this)
				};

				/*  support optional executor function  */
				if (typeof executor === "function")
					executor.call(this, this.fulfill.bind(this), this.reject.bind(this));
			};

			/*  promise API methods  */
			api.prototype = {
				/*  promise resolving methods  */
				fulfill: function (value) { return deliver(this, STATE_FULFILLED, "fulfillValue", value); },
				reject:  function (value) { return deliver(this, STATE_REJECTED,  "rejectReason", value); },

				/*  "The then Method" [Promises/A+ 1.1, 1.2, 2.2]  */
				then: function (onFulfilled, onRejected) {
					var curr = this;
					var next = new api();                                    /*  [Promises/A+ 2.2.7]  */
					curr.onFulfilled.push(
						resolver(onFulfilled, next, "fulfill"));             /*  [Promises/A+ 2.2.2/2.2.6]  */
					curr.onRejected.push(
						resolver(onRejected,  next, "reject" ));             /*  [Promises/A+ 2.2.3/2.2.6]  */
					execute(curr);
					return next.proxy;                                       /*  [Promises/A+ 2.2.7, 3.3]  */
				}
			};

			/*  deliver an action  */
			var deliver = function (curr, state, name, value) {
				if (curr.state === STATE_PENDING) {
					curr.state = state;                                      /*  [Promises/A+ 2.1.2.1, 2.1.3.1]  */
					curr[name] = value;                                      /*  [Promises/A+ 2.1.2.2, 2.1.3.2]  */
					execute(curr);
				}
				return curr;
			};

			/*  execute all handlers  */
			var execute = function (curr) {
				if (curr.state === STATE_FULFILLED)
					execute_handlers(curr, "onFulfilled", curr.fulfillValue);
				else if (curr.state === STATE_REJECTED)
					execute_handlers(curr, "onRejected",  curr.rejectReason);
			};

			/*  execute particular set of handlers  */
			var execute_handlers = function (curr, name, value) {
				/* global process: true */
				/* global setImmediate: true */
				/* global setTimeout: true */

				/*  short-circuit processing  */
				if (curr[name].length === 0)
					return;

				/*  iterate over all handlers, exactly once  */
				var handlers = curr[name];
				curr[name] = [];                                             /*  [Promises/A+ 2.2.2.3, 2.2.3.3]  */
				var func = function () {
					for (var i = 0; i < handlers.length; i++)
						handlers[i](value);                                  /*  [Promises/A+ 2.2.5]  */
				};

				/*  execute procedure asynchronously  */                     /*  [Promises/A+ 2.2.4, 3.1]  */
				if (typeof process === "object" && typeof process.nextTick === "function")
					process.nextTick(func);
				else if (typeof setImmediate === "function")
					setImmediate(func);
				else
					setTimeout(func, 0);
			};

			/*  generate a resolver function  */
			var resolver = function (cb, next, method) {
				return function (value) {
					if (typeof cb !== "function")                            /*  [Promises/A+ 2.2.1, 2.2.7.3, 2.2.7.4]  */
						next[method].call(next, value);                      /*  [Promises/A+ 2.2.7.3, 2.2.7.4]  */
					else {
						var result;
						try { result = cb(value); }                          /*  [Promises/A+ 2.2.2.1, 2.2.3.1, 2.2.5, 3.2]  */
						catch (e) {
							next.reject(e);                                  /*  [Promises/A+ 2.2.7.2]  */
							return;
						}
						resolve(next, result);                               /*  [Promises/A+ 2.2.7.1]  */
					}
				};
			};

			/*  "Promise Resolution Procedure"  */                           /*  [Promises/A+ 2.3]  */
			var resolve = function (promise, x) {
				/*  sanity check arguments  */                               /*  [Promises/A+ 2.3.1]  */
				if (promise === x || promise.proxy === x) {
					promise.reject(new TypeError("cannot resolve promise with itself"));
					return;
				}

				/*  surgically check for a "then" method
					(mainly to just call the "getter" of "then" only once)  */
				var then;
				if ((typeof x === "object" && x !== null) || typeof x === "function") {
					try { then = x.then; }                                   /*  [Promises/A+ 2.3.3.1, 3.5]  */
					catch (e) {
						promise.reject(e);                                   /*  [Promises/A+ 2.3.3.2]  */
						return;
					}
				}

				/*  handle own Thenables    [Promises/A+ 2.3.2]
					and similar "thenables" [Promises/A+ 2.3.3]  */
				if (typeof then === "function") {
					var resolved = false;
					try {
						/*  call retrieved "then" method */                  /*  [Promises/A+ 2.3.3.3]  */
						then.call(x,
							/*  resolvePromise  */                           /*  [Promises/A+ 2.3.3.3.1]  */
							function (y) {
								if (resolved) return; resolved = true;       /*  [Promises/A+ 2.3.3.3.3]  */
								if (y === x)                                 /*  [Promises/A+ 3.6]  */
									promise.reject(new TypeError("circular thenable chain"));
								else
									resolve(promise, y);
							},

							/*  rejectPromise  */                            /*  [Promises/A+ 2.3.3.3.2]  */
							function (r) {
								if (resolved) return; resolved = true;       /*  [Promises/A+ 2.3.3.3.3]  */
								promise.reject(r);
							}
						);
					}
					catch (e) {
						if (!resolved)                                       /*  [Promises/A+ 2.3.3.3.3]  */
							promise.reject(e);                               /*  [Promises/A+ 2.3.3.3.4]  */
					}
					return;
				}

				/*  handle other values  */
				promise.fulfill(x);                                          /*  [Promises/A+ 2.3.4, 2.3.3.4]  */
			};

			/*  export API  */
			return api;
		})(),

		//jscs:enable

		// Event
		// A contructor superclass for adding event menthods, on, off, emit.
		Event: function() {

			var separator = /[\s\,]+/;

			// If this doesn't support getPrototype then we can't get prototype.events of the parent
			// So lets get the current instance events, and add those to a parent property
			this.parent = {
				events: this.events,
				findEvents: this.findEvents,
				parent: this.parent,
				utils: this.utils
			};

			this.events = {};

			// On, subscribe to events
			// @param evt   string
			// @param callback  function
			this.on = function(evt, callback) {

				if (callback && typeof (callback) === 'function') {
					var a = evt.split(separator);
					for (var i = 0; i < a.length; i++) {

						// Has this event already been fired on this instance?
						this.events[a[i]] = [callback].concat(this.events[a[i]] || []);
					}
				}

				return this;
			};

			// Off, unsubscribe to events
			// @param evt   string
			// @param callback  function
			this.off = function(evt, callback) {

				this.findEvents(evt, function(name, index) {
					if (!callback || this.events[name][index] === callback) {
						this.events[name][index] = null;
					}
				});

				return this;
			};

			// Emit
			// Triggers any subscribed events
			this.emit = function(evt /*, data, ... */) {

				// Get arguments as an Array, knock off the first one
				var args = Array.prototype.slice.call(arguments, 1);
				args.push(evt);

				// Handler
				var handler = function(name, index) {

					// Replace the last property with the event name
					args[args.length - 1] = (name === '*' ? evt : name);

					// Trigger
					this.events[name][index].apply(this, args);
				};

				// Find the callbacks which match the condition and call
				var _this = this;
				while (_this && _this.findEvents) {

					// Find events which match
					_this.findEvents(evt + ',*', handler);
					_this = _this.parent;
				}

				return this;
			};

			//
			// Easy functions
			this.emitAfter = function() {
				var _this = this;
				var args = arguments;
				setTimeout(function() {
					_this.emit.apply(_this, args);
				}, 0);

				return this;
			};

			this.findEvents = function(evt, callback) {

				var a = evt.split(separator);

				for (var name in this.events) {if (this.events.hasOwnProperty(name)) {

					if (a.indexOf(name) > -1) {

						for (var i = 0; i < this.events[name].length; i++) {

							// Does the event handler exist?
							if (this.events[name][i]) {
								// Emit on the local instance of this
								callback.call(this, name, i);
							}
						}
					}
				}}
			};

			return this;
		},

		// Global Events
		// Attach the callback to the window object
		// Return its unique reference
		globalEvent: function(callback, guid) {
			// If the guid has not been supplied then create a new one.
			guid = guid || '_hellojs_' + parseInt(Math.random() * 1e12, 10).toString(36);

			// Define the callback function
			window[guid] = function() {
				// Trigger the callback
				try {
					if (callback.apply(this, arguments)) {
						delete window[guid];
					}
				}
				catch (e) {
					console.error(e);
				}
			};

			return guid;
		},

		// Trigger a clientside popup
		// This has been augmented to support PhoneGap
		popup: function(url, redirectUri, options) {

			var documentElement = document.documentElement;

			// Multi Screen Popup Positioning (http://stackoverflow.com/a/16861050)
			// Credit: http://www.xtf.dk/2011/08/center-new-popup-window-even-on.html
			// Fixes dual-screen position                         Most browsers      Firefox

			if (options.height) {
				var dualScreenTop = window.screenTop !== undefined ? window.screenTop : screen.top;
				var height = screen.height || window.innerHeight || documentElement.clientHeight;
				options.top = parseInt((height - options.height) / 2, 10) + dualScreenTop;
			}

			if (options.width) {
				var dualScreenLeft = window.screenLeft !== undefined ? window.screenLeft : screen.left;
				var width = screen.width || window.innerWidth || documentElement.clientWidth;
				options.left = parseInt((width - options.width) / 2, 10) + dualScreenLeft;
			}

			// Convert options into an array
			var optionsArray = [];
			Object.keys(options).forEach(function(name) {
				var value = options[name];
				optionsArray.push(name + (value !== null ? '=' + value : ''));
			});

			// Call the open() function with the initial path
			//
			// OAuth redirect, fixes URI fragments from being lost in Safari
			// (URI Fragments within 302 Location URI are lost over HTTPS)
			// Loading the redirect.html before triggering the OAuth Flow seems to fix it.
			//
			// Firefox  decodes URL fragments when calling location.hash.
			//  - This is bad if the value contains break points which are escaped
			//  - Hence the url must be encoded twice as it contains breakpoints.
			if (navigator.userAgent.indexOf('Safari') !== -1 && navigator.userAgent.indexOf('Chrome') === -1) {
				url = redirectUri + '#oauth_redirect=' + encodeURIComponent(encodeURIComponent(url));
			}

			var popup = window.open(
				url,
				'_blank',
				optionsArray.join(',')
			);

			if (popup && popup.focus) {
				popup.focus();
			}

			return popup;
		},

		// OAuth and API response handler
		responseHandler: function(window, parent) {

			var _this = this;
			var p;
			var location = window.location;

			// Is this an auth relay message which needs to call the proxy?
			p = _this.param(location.search);

			// OAuth2 or OAuth1 server response?
			if (p && p.state && (p.code || p.oauth_token)) {

				var state = JSON.parse(p.state);

				// Add this path as the redirect_uri
				p.redirect_uri = state.redirect_uri || location.href.replace(/[\?\#].*$/, '');

				// Redirect to the host
				var path = state.oauth_proxy + '?' + _this.param(p);

				location.assign(path);

				return;
			}

			// Save session, from redirected authentication
			// #access_token has come in?
			//
			// FACEBOOK is returning auth errors within as a query_string... thats a stickler for consistency.
			// SoundCloud is the state in the querystring and the token in the hashtag, so we'll mix the two together

			p = _this.merge(_this.param(location.search || ''), _this.param(location.hash || ''));

			// If p.state
			if (p && 'state' in p) {

				// Remove any addition information
				// E.g. p.state = 'facebook.page';
				try {
					var a = JSON.parse(p.state);
					_this.extend(p, a);
				}
				catch (e) {
					console.error('Could not decode state parameter');
				}

				// Access_token?
				if (('access_token' in p && p.access_token) && p.network) {

					if (!p.expires_in || parseInt(p.expires_in, 10) === 0) {
						// If p.expires_in is unset, set to 0
						p.expires_in = 0;
					}

					p.expires_in = parseInt(p.expires_in, 10);
					p.expires = ((new Date()).getTime() / 1e3) + (p.expires_in || (60 * 60 * 24 * 365));

					// Lets use the "state" to assign it to one of our networks
					authCallback(p, window, parent);
				}

				// Error=?
				// &error_description=?
				// &state=?
				else if (('error' in p && p.error) && p.network) {

					p.error = {
						code: p.error,
						message: p.error_message || p.error_description
					};

					// Let the state handler handle it
					authCallback(p, window, parent);
				}

				// API call, or a cancelled login
				// Result is serialized JSON string
				else if (p.callback && p.callback in parent) {

					// Trigger a function in the parent
					var res = 'result' in p && p.result ? JSON.parse(p.result) : false;

					// Trigger the callback on the parent
					callback(parent, p.callback)(res);
					closeWindow();
				}

				// If this page is still open
				if (p.page_uri) {
					location.assign(p.page_uri);
				}
			}

			// OAuth redirect, fixes URI fragments from being lost in Safari
			// (URI Fragments within 302 Location URI are lost over HTTPS)
			// Loading the redirect.html before triggering the OAuth Flow seems to fix it.
			else if ('oauth_redirect' in p) {

				location.assign(decodeURIComponent(p.oauth_redirect));
				return;
			}

			// Trigger a callback to authenticate
			function authCallback(obj, window, parent) {

				var cb = obj.callback;
				var network = obj.network;

				// Trigger the callback on the parent
				_this.store(network, obj);

				// If this is a page request it has no parent or opener window to handle callbacks
				if (('display' in obj) && obj.display === 'page') {
					return;
				}

				// Remove from session object
				if (parent && cb && cb in parent) {

					try {
						delete obj.callback;
					}
					catch (e) {}

					// Update store
					_this.store(network, obj);

					// Call the globalEvent function on the parent
					// It's safer to pass back a string to the parent,
					// Rather than an object/array (better for IE8)
					var str = JSON.stringify(obj);

					try {
						callback(parent, cb)(str);
					}
					catch (e) {
						// Error thrown whilst executing parent callback
					}
				}

				closeWindow();
			}

			function callback(parent, callbackID) {
				if (callbackID.indexOf('_hellojs_') !== 0) {
					return function() {
						throw 'Could not execute callback ' + callbackID;
					};
				}

				return parent[callbackID];
			}

			function closeWindow() {

				if (window.frameElement) {
					// Inside an iframe, remove from parent
					parent.document.body.removeChild(window.frameElement);
				}
				else {
					// Close this current window
					try {
						window.close();
					}
					catch (e) {}

					// IOS bug wont let us close a popup if still loading
					if (window.addEventListener) {
						window.addEventListener('load', function() {
							window.close();
						});
					}
				}

			}
		}
	});

	// Events
	// Extend the hello object with its own event instance
	hello.utils.Event.call(hello);

	///////////////////////////////////
	// Monitoring session state
	// Check for session changes
	///////////////////////////////////

	(function(hello) {

		// Monitor for a change in state and fire
		var oldSessions = {};

		// Hash of expired tokens
		var expired = {};

		// Listen to other triggers to Auth events, use these to update this
		hello.on('auth.login, auth.logout', function(auth) {
			if (auth && typeof (auth) === 'object' && auth.network) {
				oldSessions[auth.network] = hello.utils.store(auth.network) || {};
			}
		});

		(function self() {

			var CURRENT_TIME = ((new Date()).getTime() / 1e3);
			var emit = function(eventName) {
				hello.emit('auth.' + eventName, {
					network: name,
					authResponse: session
				});
			};

			// Loop through the services
			for (var name in hello.services) {if (hello.services.hasOwnProperty(name)) {

				if (!hello.services[name].id) {
					// We haven't attached an ID so dont listen.
					continue;
				}

				// Get session
				var session = hello.utils.store(name) || {};
				var provider = hello.services[name];
				var oldSess = oldSessions[name] || {};

				// Listen for globalEvents that did not get triggered from the child
				if (session && 'callback' in session) {

					// To do remove from session object...
					var cb = session.callback;
					try {
						delete session.callback;
					}
					catch (e) {}

					// Update store
					// Removing the callback
					hello.utils.store(name, session);

					// Emit global events
					try {
						window[cb](session);
					}
					catch (e) {}
				}

				// Refresh token
				if (session && ('expires' in session) && session.expires < CURRENT_TIME) {

					// If auto refresh is possible
					// Either the browser supports
					var refresh = provider.refresh || session.refresh_token;

					// Has the refresh been run recently?
					if (refresh && (!(name in expired) || expired[name] < CURRENT_TIME)) {
						// Try to resignin
						hello.emit('notice', name + ' has expired trying to resignin');
						hello.login(name, {display: 'none', force: false});

						// Update expired, every 10 minutes
						expired[name] = CURRENT_TIME + 600;
					}

					// Does this provider not support refresh
					else if (!refresh && !(name in expired)) {
						// Label the event
						emit('expired');
						expired[name] = true;
					}

					// If session has expired then we dont want to store its value until it can be established that its been updated
					continue;
				}

				// Has session changed?
				else if (oldSess.access_token === session.access_token &&
				oldSess.expires === session.expires) {
					continue;
				}

				// Access_token has been removed
				else if (!session.access_token && oldSess.access_token) {
					emit('logout');
				}

				// Access_token has been created
				else if (session.access_token && !oldSess.access_token) {
					emit('login');
				}

				// Access_token has been updated
				else if (session.expires !== oldSess.expires) {
					emit('update');
				}

				// Updated stored session
				oldSessions[name] = session;

				// Remove the expired flags
				if (name in expired) {
					delete expired[name];
				}
			}}

			// Check error events
			setTimeout(self, 1000);
		})();

	})(hello);

	// EOF CORE lib
	//////////////////////////////////

	/////////////////////////////////////////
	// API
	// @param path    string
	// @param query   object (optional)
	// @param method  string (optional)
	// @param data    object (optional)
	// @param timeout integer (optional)
	// @param callback  function (optional)

	hello.api = function() {

		// Shorthand
		var _this = this;
		var utils = _this.utils;
		var error = utils.error;

		// Construct a new Promise object
		var promise = utils.Promise();

		// Arguments
		var p = utils.args({path: 's!', query: 'o', method: 's', data: 'o', timeout: 'i', callback: 'f'}, arguments);

		// Method
		p.method = (p.method || 'get').toLowerCase();

		// Headers
		p.headers = p.headers || {};

		// Query
		p.query = p.query || {};

		// If get, put all parameters into query
		if (p.method === 'get' || p.method === 'delete') {
			utils.extend(p.query, p.data);
			p.data = {};
		}

		var data = p.data = p.data || {};

		// Completed event callback
		promise.then(p.callback, p.callback);

		// Remove the network from path, e.g. facebook:/me/friends
		// Results in { network : facebook, path : me/friends }
		if (!p.path) {
			return promise.reject(error('invalid_path', 'Missing the path parameter from the request'));
		}

		p.path = p.path.replace(/^\/+/, '');
		var a = (p.path.split(/[\/\:]/, 2) || [])[0].toLowerCase();

		if (a in _this.services) {
			p.network = a;
			var reg = new RegExp('^' + a + ':?\/?');
			p.path = p.path.replace(reg, '');
		}

		// Network & Provider
		// Define the network that this request is made for
		p.network = _this.settings.default_service = p.network || _this.settings.default_service;
		var o = _this.services[p.network];

		// INVALID
		// Is there no service by the given network name?
		if (!o) {
			return promise.reject(error('invalid_network', 'Could not match the service requested: ' + p.network));
		}

		// PATH
		// As long as the path isn't flagged as unavaiable, e.g. path == false

		if (!(!(p.method in o) || !(p.path in o[p.method]) || o[p.method][p.path] !== false)) {
			return promise.reject(error('invalid_path', 'The provided path is not available on the selected network'));
		}

		// PROXY
		// OAuth1 calls always need a proxy

		if (!p.oauth_proxy) {
			p.oauth_proxy = _this.settings.oauth_proxy;
		}

		if (!('proxy' in p)) {
			p.proxy = p.oauth_proxy && o.oauth && parseInt(o.oauth.version, 10) === 1;
		}

		// TIMEOUT
		// Adopt timeout from global settings by default

		if (!('timeout' in p)) {
			p.timeout = _this.settings.timeout;
		}

		// Format response
		// Whether to run the raw response through post processing.
		if (!('formatResponse' in p)) {
			p.formatResponse = true;
		}

		// Get the current session
		// Append the access_token to the query
		p.authResponse = _this.getAuthResponse(p.network);
		if (p.authResponse && p.authResponse.access_token) {
			p.query.access_token = p.authResponse.access_token;
		}

		var url = p.path;
		var m;

		// Store the query as options
		// This is used to populate the request object before the data is augmented by the prewrap handlers.
		p.options = utils.clone(p.query);

		// Clone the data object
		// Prevent this script overwriting the data of the incoming object.
		// Ensure that everytime we run an iteration the callbacks haven't removed some data
		p.data = utils.clone(data);

		// URL Mapping
		// Is there a map for the given URL?
		var actions = o[{'delete': 'del'}[p.method] || p.method] || {};

		// Extrapolate the QueryString
		// Provide a clean path
		// Move the querystring into the data
		if (p.method === 'get') {

			var query = url.split(/[\?#]/)[1];
			if (query) {
				utils.extend(p.query, utils.param(query));

				// Remove the query part from the URL
				url = url.replace(/\?.*?(#|$)/, '$1');
			}
		}

		// Is the hash fragment defined
		if ((m = url.match(/#(.+)/, ''))) {
			url = url.split('#')[0];
			p.path = m[1];
		}
		else if (url in actions) {
			p.path = url;
			url = actions[url];
		}
		else if ('default' in actions) {
			url = actions['default'];
		}

		// Redirect Handler
		// This defines for the Form+Iframe+Hash hack where to return the results too.
		p.redirect_uri = _this.settings.redirect_uri;

		// Define FormatHandler
		// The request can be procesed in a multitude of ways
		// Here's the options - depending on the browser and endpoint
		p.xhr = o.xhr;
		p.jsonp = o.jsonp;
		p.form = o.form;

		// Make request
		if (typeof (url) === 'function') {
			// Does self have its own callback?
			url(p, getPath);
		}
		else {
			// Else the URL is a string
			getPath(url);
		}

		return promise.proxy;

		// If url needs a base
		// Wrap everything in
		function getPath(url) {

			// Format the string if it needs it
			url = url.replace(/\@\{([a-z\_\-]+)(\|.*?)?\}/gi, function(m, key, defaults) {
				var val = defaults ? defaults.replace(/^\|/, '') : '';
				if (key in p.query) {
					val = p.query[key];
					delete p.query[key];
				}
				else if (p.data && key in p.data) {
					val = p.data[key];
					delete p.data[key];
				}
				else if (!defaults) {
					promise.reject(error('missing_attribute', 'The attribute ' + key + ' is missing from the request'));
				}

				return val;
			});

			// Add base
			if (!url.match(/^https?:\/\//)) {
				url = o.base + url;
			}

			// Define the request URL
			p.url = url;

			// Make the HTTP request with the curated request object
			// CALLBACK HANDLER
			// @ response object
			// @ statusCode integer if available
			utils.request(p, function(r, headers) {

				// Is this a raw response?
				if (!p.formatResponse) {
					// Bad request? error statusCode or otherwise contains an error response vis JSONP?
					if (typeof headers === 'object' ? (headers.statusCode >= 400) : (typeof r === 'object' && 'error' in r)) {
						promise.reject(r);
					}
					else {
						promise.fulfill(r);
					}

					return;
				}

				// Should this be an object
				if (r === true) {
					r = {success:true};
				}
				else if (!r) {
					r = {};
				}

				// The delete callback needs a better response
				if (p.method === 'delete') {
					r = (!r || utils.isEmpty(r)) ? {success:true} : r;
				}

				// FORMAT RESPONSE?
				// Does self request have a corresponding formatter
				if (o.wrap && ((p.path in o.wrap) || ('default' in o.wrap))) {
					var wrap = (p.path in o.wrap ? p.path : 'default');
					var time = (new Date()).getTime();

					// FORMAT RESPONSE
					var b = o.wrap[wrap](r, headers, p);

					// Has the response been utterly overwritten?
					// Typically self augments the existing object.. but for those rare occassions
					if (b) {
						r = b;
					}
				}

				// Is there a next_page defined in the response?
				if (r && 'paging' in r && r.paging.next) {

					// Add the relative path if it is missing from the paging/next path
					if (r.paging.next[0] === '?') {
						r.paging.next = p.path + r.paging.next;
					}

					// The relative path has been defined, lets markup the handler in the HashFragment
					else {
						r.paging.next += '#' + p.path;
					}
				}

				// Dispatch to listeners
				// Emit events which pertain to the formatted response
				if (!r || 'error' in r) {
					promise.reject(r);
				}
				else {
					promise.fulfill(r);
				}
			});
		}
	};

	// API utilities
	hello.utils.extend(hello.utils, {

		// Make an HTTP request
		request: function(p, callback) {

			var _this = this;
			var error = _this.error;

			// This has to go through a POST request
			if (!_this.isEmpty(p.data) && !('FileList' in window) && _this.hasBinary(p.data)) {

				// Disable XHR and JSONP
				p.xhr = false;
				p.jsonp = false;
			}

			// Check if the browser and service support CORS
			var cors = this.request_cors(function() {
				// If it does then run this...
				return ((p.xhr === undefined) || (p.xhr && (typeof (p.xhr) !== 'function' || p.xhr(p, p.query))));
			});

			if (cors) {

				formatUrl(p, function(url) {

					var x = _this.xhr(p.method, url, p.headers, p.data, callback);
					x.onprogress = p.onprogress || null;

					// Windows Phone does not support xhr.upload, see #74
					// Feature detect
					if (x.upload && p.onuploadprogress) {
						x.upload.onprogress = p.onuploadprogress;
					}

				});

				return;
			}

			// Clone the query object
			// Each request modifies the query object and needs to be tared after each one.
			var _query = p.query;

			p.query = _this.clone(p.query);

			// Assign a new callbackID
			p.callbackID = _this.globalEvent();

			// JSONP
			if (p.jsonp !== false) {

				// Clone the query object
				p.query.callback = p.callbackID;

				// If the JSONP is a function then run it
				if (typeof (p.jsonp) === 'function') {
					p.jsonp(p, p.query);
				}

				// Lets use JSONP if the method is 'get'
				if (p.method === 'get') {

					formatUrl(p, function(url) {
						_this.jsonp(url, callback, p.callbackID, p.timeout);
					});

					return;
				}
				else {
					// It's not compatible reset query
					p.query = _query;
				}

			}

			// Otherwise we're on to the old school, iframe hacks and JSONP
			if (p.form !== false) {

				// Add some additional query parameters to the URL
				// We're pretty stuffed if the endpoint doesn't like these
				p.query.redirect_uri = p.redirect_uri;
				p.query.state = JSON.stringify({callback:p.callbackID});

				var opts;

				if (typeof (p.form) === 'function') {

					// Format the request
					opts = p.form(p, p.query);
				}

				if (p.method === 'post' && opts !== false) {

					formatUrl(p, function(url) {
						_this.post(url, p.data, opts, callback, p.callbackID, p.timeout);
					});

					return;
				}
			}

			// None of the methods were successful throw an error
			callback(error('invalid_request', 'There was no mechanism for handling this request'));

			return;

			// Format URL
			// Constructs the request URL, optionally wraps the URL through a call to a proxy server
			// Returns the formatted URL
			function formatUrl(p, callback) {

				// Are we signing the request?
				var sign;

				// OAuth1
				// Remove the token from the query before signing
				if (p.authResponse && p.authResponse.oauth && parseInt(p.authResponse.oauth.version, 10) === 1) {

					// OAUTH SIGNING PROXY
					sign = p.query.access_token;

					// Remove the access_token
					delete p.query.access_token;

					// Enfore use of Proxy
					p.proxy = true;
				}

				// POST body to querystring
				if (p.data && (p.method === 'get' || p.method === 'delete')) {
					// Attach the p.data to the querystring.
					_this.extend(p.query, p.data);
					p.data = null;
				}

				// Construct the path
				var path = _this.qs(p.url, p.query);

				// Proxy the request through a server
				// Used for signing OAuth1
				// And circumventing services without Access-Control Headers
				if (p.proxy) {
					// Use the proxy as a path
					path = _this.qs(p.oauth_proxy, {
						path: path,
						access_token: sign || '',

						// This will prompt the request to be signed as though it is OAuth1
						then: p.proxy_response_type || (p.method.toLowerCase() === 'get' ? 'redirect' : 'proxy'),
						method: p.method.toLowerCase(),
						suppress_response_codes: true
					});
				}

				callback(path);
			}
		},

		// Test whether the browser supports the CORS response
		request_cors: function(callback) {
			return 'withCredentials' in new XMLHttpRequest() && callback();
		},

		// Return the type of DOM object
		domInstance: function(type, data) {
			var test = 'HTML' + (type || '').replace(
				/^[a-z]/,
				function(m) {
					return m.toUpperCase();
				}

			) + 'Element';

			if (!data) {
				return false;
			}

			if (window[test]) {
				return data instanceof window[test];
			}
			else if (window.Element) {
				return data instanceof window.Element && (!type || (data.tagName && data.tagName.toLowerCase() === type));
			}
			else {
				return (!(data instanceof Object || data instanceof Array || data instanceof String || data instanceof Number) && data.tagName && data.tagName.toLowerCase() === type);
			}
		},

		// Create a clone of an object
		clone: function(obj) {
			// Does not clone DOM elements, nor Binary data, e.g. Blobs, Filelists
			if (obj === null || typeof (obj) !== 'object' || obj instanceof Date || 'nodeName' in obj || this.isBinary(obj) || (typeof FormData === 'function' && obj instanceof FormData)) {
				return obj;
			}

			if (Array.isArray(obj)) {
				// Clone each item in the array
				return obj.map(this.clone.bind(this));
			}

			// But does clone everything else.
			var clone = {};
			for (var x in obj) {
				clone[x] = this.clone(obj[x]);
			}

			return clone;
		},

		// XHR: uses CORS to make requests
		xhr: function(method, url, headers, data, callback) {

			var r = new XMLHttpRequest();
			var error = this.error;

			// Binary?
			var binary = false;
			if (method === 'blob') {
				binary = method;
				method = 'GET';
			}

			method = method.toUpperCase();

			// Xhr.responseType 'json' is not supported in any of the vendors yet.
			r.onload = function(e) {
				var json = r.response;
				try {
					json = JSON.parse(r.responseText);
				}
				catch (_e) {
					if (r.status === 401) {
						json = error('access_denied', r.statusText);
					}
				}

				var headers = headersToJSON(r.getAllResponseHeaders());
				headers.statusCode = r.status;

				callback(json || (method === 'GET' ? error('empty_response', 'Could not get resource') : {}), headers);
			};

			r.onerror = function(e) {
				var json = r.responseText;
				try {
					json = JSON.parse(r.responseText);
				}
				catch (_e) {}

				callback(json || error('access_denied', 'Could not get resource'));
			};

			var x;

			// Should we add the query to the URL?
			if (method === 'GET' || method === 'DELETE') {
				data = null;
			}
			else if (data && typeof (data) !== 'string' && !(data instanceof FormData) && !(data instanceof File) && !(data instanceof Blob)) {
				// Loop through and add formData
				var f = new FormData();
				for (x in data) if (data.hasOwnProperty(x)) {
					if (data[x] instanceof HTMLInputElement) {
						if ('files' in data[x] && data[x].files.length > 0) {
							f.append(x, data[x].files[0]);
						}
					}
					else if (data[x] instanceof Blob) {
						f.append(x, data[x], data.name);
					}
					else {
						f.append(x, data[x]);
					}
				}

				data = f;
			}

			// Open the path, async
			r.open(method, url, true);

			if (binary) {
				if ('responseType' in r) {
					r.responseType = binary;
				}
				else {
					r.overrideMimeType('text/plain; charset=x-user-defined');
				}
			}

			// Set any bespoke headers
			if (headers) {
				for (x in headers) {
					r.setRequestHeader(x, headers[x]);
				}
			}

			r.send(data);

			return r;

			// Headers are returned as a string
			function headersToJSON(s) {
				var r = {};
				var reg = /([a-z\-]+):\s?(.*);?/gi;
				var m;
				while ((m = reg.exec(s))) {
					r[m[1]] = m[2];
				}

				return r;
			}
		},

		// JSONP
		// Injects a script tag into the DOM to be executed and appends a callback function to the window object
		// @param string/function pathFunc either a string of the URL or a callback function pathFunc(querystringhash, continueFunc);
		// @param function callback a function to call on completion;
		jsonp: function(url, callback, callbackID, timeout) {

			var _this = this;
			var error = _this.error;

			// Change the name of the callback
			var bool = 0;
			var head = document.getElementsByTagName('head')[0];
			var operaFix;
			var result = error('server_error', 'server_error');
			var cb = function() {
				if (!(bool++)) {
					window.setTimeout(function() {
						callback(result);
						head.removeChild(script);
					}, 0);
				}

			};

			// Add callback to the window object
			callbackID = _this.globalEvent(function(json) {
				result = json;
				return true;

				// Mark callback as done
			}, callbackID);

			// The URL is a function for some cases and as such
			// Determine its value with a callback containing the new parameters of this function.
			url = url.replace(new RegExp('=\\?(&|$)'), '=' + callbackID + '$1');

			// Build script tag
			var script = _this.append('script', {
				id: callbackID,
				name: callbackID,
				src: url,
				async: true,
				onload: cb,
				onerror: cb,
				onreadystatechange: function() {
					if (/loaded|complete/i.test(this.readyState)) {
						cb();
					}
				}
			});

			// Opera fix error
			// Problem: If an error occurs with script loading Opera fails to trigger the script.onerror handler we specified
			//
			// Fix:
			// By setting the request to synchronous we can trigger the error handler when all else fails.
			// This action will be ignored if we've already called the callback handler "cb" with a successful onload event
			if (window.navigator.userAgent.toLowerCase().indexOf('opera') > -1) {
				operaFix = _this.append('script', {
					text: 'document.getElementById(\'' + callbackID + '\').onerror();'
				});
				script.async = false;
			}

			// Add timeout
			if (timeout) {
				window.setTimeout(function() {
					result = error('timeout', 'timeout');
					cb();
				}, timeout);
			}

			// TODO: add fix for IE,
			// However: unable recreate the bug of firing off the onreadystatechange before the script content has been executed and the value of "result" has been defined.
			// Inject script tag into the head element
			head.appendChild(script);

			// Append Opera Fix to run after our script
			if (operaFix) {
				head.appendChild(operaFix);
			}
		},

		// Post
		// Send information to a remote location using the post mechanism
		// @param string uri path
		// @param object data, key value data to send
		// @param function callback, function to execute in response
		post: function(url, data, options, callback, callbackID, timeout) {

			var _this = this;
			var error = _this.error;
			var doc = document;

			// This hack needs a form
			var form = null;
			var reenableAfterSubmit = [];
			var newform;
			var i = 0;
			var x = null;
			var bool = 0;
			var cb = function(r) {
				if (!(bool++)) {
					callback(r);
				}
			};

			// What is the name of the callback to contain
			// We'll also use this to name the iframe
			_this.globalEvent(cb, callbackID);

			// Build the iframe window
			var win;
			try {
				// IE7 hack, only lets us define the name here, not later.
				win = doc.createElement('<iframe name="' + callbackID + '">');
			}
			catch (e) {
				win = doc.createElement('iframe');
			}

			win.name = callbackID;
			win.id = callbackID;
			win.style.display = 'none';

			// Override callback mechanism. Triggger a response onload/onerror
			if (options && options.callbackonload) {
				// Onload is being fired twice
				win.onload = function() {
					cb({
						response: 'posted',
						message: 'Content was posted'
					});
				};
			}

			if (timeout) {
				setTimeout(function() {
					cb(error('timeout', 'The post operation timed out'));
				}, timeout);
			}

			doc.body.appendChild(win);

			// If we are just posting a single item
			if (_this.domInstance('form', data)) {
				// Get the parent form
				form = data.form;

				// Loop through and disable all of its siblings
				for (i = 0; i < form.elements.length; i++) {
					if (form.elements[i] !== data) {
						form.elements[i].setAttribute('disabled', true);
					}
				}

				// Move the focus to the form
				data = form;
			}

			// Posting a form
			if (_this.domInstance('form', data)) {
				// This is a form element
				form = data;

				// Does this form need to be a multipart form?
				for (i = 0; i < form.elements.length; i++) {
					if (!form.elements[i].disabled && form.elements[i].type === 'file') {
						form.encoding = form.enctype = 'multipart/form-data';
						form.elements[i].setAttribute('name', 'file');
					}
				}
			}
			else {
				// Its not a form element,
				// Therefore it must be a JSON object of Key=>Value or Key=>Element
				// If anyone of those values are a input type=file we shall shall insert its siblings into the form for which it belongs.
				for (x in data) if (data.hasOwnProperty(x)) {
					// Is this an input Element?
					if (_this.domInstance('input', data[x]) && data[x].type === 'file') {
						form = data[x].form;
						form.encoding = form.enctype = 'multipart/form-data';
					}
				}

				// Do If there is no defined form element, lets create one.
				if (!form) {
					// Build form
					form = doc.createElement('form');
					doc.body.appendChild(form);
					newform = form;
				}

				var input;

				// Add elements to the form if they dont exist
				for (x in data) if (data.hasOwnProperty(x)) {

					// Is this an element?
					var el = (_this.domInstance('input', data[x]) || _this.domInstance('textArea', data[x]) || _this.domInstance('select', data[x]));

					// Is this not an input element, or one that exists outside the form.
					if (!el || data[x].form !== form) {

						// Does an element have the same name?
						var inputs = form.elements[x];
						if (input) {
							// Remove it.
							if (!(inputs instanceof NodeList)) {
								inputs = [inputs];
							}

							for (i = 0; i < inputs.length; i++) {
								inputs[i].parentNode.removeChild(inputs[i]);
							}

						}

						// Create an input element
						input = doc.createElement('input');
						input.setAttribute('type', 'hidden');
						input.setAttribute('name', x);

						// Does it have a value attribute?
						if (el) {
							input.value = data[x].value;
						}
						else if (_this.domInstance(null, data[x])) {
							input.value = data[x].innerHTML || data[x].innerText;
						}
						else {
							input.value = data[x];
						}

						form.appendChild(input);
					}

					// It is an element, which exists within the form, but the name is wrong
					else if (el && data[x].name !== x) {
						data[x].setAttribute('name', x);
						data[x].name = x;
					}
				}

				// Disable elements from within the form if they weren't specified
				for (i = 0; i < form.elements.length; i++) {

					input = form.elements[i];

					// Does the same name and value exist in the parent
					if (!(input.name in data) && input.getAttribute('disabled') !== true) {
						// Disable
						input.setAttribute('disabled', true);

						// Add re-enable to callback
						reenableAfterSubmit.push(input);
					}
				}
			}

			// Set the target of the form
			form.setAttribute('method', 'POST');
			form.setAttribute('target', callbackID);
			form.target = callbackID;

			// Update the form URL
			form.setAttribute('action', url);

			// Submit the form
			// Some reason this needs to be offset from the current window execution
			setTimeout(function() {
				form.submit();

				setTimeout(function() {
					try {
						// Remove the iframe from the page.
						//win.parentNode.removeChild(win);
						// Remove the form
						if (newform) {
							newform.parentNode.removeChild(newform);
						}
					}
					catch (e) {
						try {
							console.error('HelloJS: could not remove iframe');
						}
						catch (ee) {}
					}

					// Reenable the disabled form
					for (var i = 0; i < reenableAfterSubmit.length; i++) {
						if (reenableAfterSubmit[i]) {
							reenableAfterSubmit[i].setAttribute('disabled', false);
							reenableAfterSubmit[i].disabled = false;
						}
					}
				}, 0);
			}, 100);
		},

		// Some of the providers require that only multipart is used with non-binary forms.
		// This function checks whether the form contains binary data
		hasBinary: function(data) {
			for (var x in data) if (data.hasOwnProperty(x)) {
				if (this.isBinary(data[x])) {
					return true;
				}
			}

			return false;
		},

		// Determines if a variable Either Is or like a FormInput has the value of a Blob

		isBinary: function(data) {

			return data instanceof Object && (
			(this.domInstance('input', data) && data.type === 'file') ||
			('FileList' in window && data instanceof window.FileList) ||
			('File' in window && data instanceof window.File) ||
			('Blob' in window && data instanceof window.Blob));

		},

		// Convert Data-URI to Blob string
		toBlob: function(dataURI) {
			var reg = /^data\:([^;,]+(\;charset=[^;,]+)?)(\;base64)?,/i;
			var m = dataURI.match(reg);
			if (!m) {
				return dataURI;
			}

			var binary = atob(dataURI.replace(reg, ''));
			var array = [];
			for (var i = 0; i < binary.length; i++) {
				array.push(binary.charCodeAt(i));
			}

			return new Blob([new Uint8Array(array)], {type: m[1]});
		}

	});

	// EXTRA: Convert FormElement to JSON for POSTing
	// Wrappers to add additional functionality to existing functions
	(function(hello) {

		// Copy original function
		var api = hello.api;
		var utils = hello.utils;

		utils.extend(utils, {

			// DataToJSON
			// This takes a FormElement|NodeList|InputElement|MixedObjects and convers the data object to JSON.
			dataToJSON: function(p) {

				var _this = this;
				var w = window;
				var data = p.data;

				// Is data a form object
				if (_this.domInstance('form', data)) {
					data = _this.nodeListToJSON(data.elements);
				}
				else if ('NodeList' in w && data instanceof NodeList) {
					data = _this.nodeListToJSON(data);
				}
				else if (_this.domInstance('input', data)) {
					data = _this.nodeListToJSON([data]);
				}

				// Is data a blob, File, FileList?
				if (('File' in w && data instanceof w.File) ||
					('Blob' in w && data instanceof w.Blob) ||
					('FileList' in w && data instanceof w.FileList)) {
					data = {file: data};
				}

				// Loop through data if it's not form data it must now be a JSON object
				if (!('FormData' in w && data instanceof w.FormData)) {

					for (var x in data) if (data.hasOwnProperty(x)) {

						if ('FileList' in w && data[x] instanceof w.FileList) {
							if (data[x].length === 1) {
								data[x] = data[x][0];
							}
						}
						else if (_this.domInstance('input', data[x]) && data[x].type === 'file') {
							continue;
						}
						else if (_this.domInstance('input', data[x]) ||
							_this.domInstance('select', data[x]) ||
							_this.domInstance('textArea', data[x])) {
							data[x] = data[x].value;
						}
						else if (_this.domInstance(null, data[x])) {
							data[x] = data[x].innerHTML || data[x].innerText;
						}
					}
				}

				p.data = data;
				return data;
			},

			// NodeListToJSON
			// Given a list of elements extrapolate their values and return as a json object
			nodeListToJSON: function(nodelist) {

				var json = {};

				// Create a data string
				for (var i = 0; i < nodelist.length; i++) {

					var input = nodelist[i];

					// If the name of the input is empty or diabled, dont add it.
					if (input.disabled || !input.name) {
						continue;
					}

					// Is this a file, does the browser not support 'files' and 'FormData'?
					if (input.type === 'file') {
						json[input.name] = input;
					}
					else {
						json[input.name] = input.value || input.innerHTML;
					}
				}

				return json;
			}
		});

		// Replace it
		hello.api = function() {

			// Get arguments
			var p = utils.args({path: 's!', method: 's', data:'o', timeout: 'i', callback: 'f'}, arguments);

			// Change for into a data object
			if (p.data) {
				utils.dataToJSON(p);
			}

			return api.call(this, p);
		};

	})(hello);

	/////////////////////////////////////
	//
	// Save any access token that is in the current page URL
	// Handle any response solicited through iframe hash tag following an API request
	//
	/////////////////////////////////////

	hello.utils.responseHandler(window, window.opener || window.parent);

	// Script to support ChromeApps
	// This overides the hello.utils.popup method to support chrome.identity.launchWebAuthFlow
	// See https://developer.chrome.com/apps/app_identity#non

	// Is this a chrome app?

	if (typeof chrome === 'object' && typeof chrome.identity === 'object' && chrome.identity.launchWebAuthFlow) {

		(function() {

			// Swap the popup method
			hello.utils.popup = function(url) {

				return _open(url, true);

			};

			// Swap the hidden iframe method
			hello.utils.iframe = function(url) {

				_open(url, false);

			};

			// Swap the request_cors method
			hello.utils.request_cors = function(callback) {

				callback();

				// Always run as CORS

				return true;
			};

			// Swap the storage method
			var _cache = {};
			chrome.storage.local.get('hello', function(r) {
				// Update the cache
				_cache = r.hello || {};
			});

			hello.utils.store = function(name, value) {

				// Get all
				if (arguments.length === 0) {
					return _cache;
				}

				// Get
				if (arguments.length === 1) {
					return _cache[name] || null;
				}

				// Set
				if (value) {
					_cache[name] = value;
					chrome.storage.local.set({hello: _cache});
					return value;
				}

				// Delete
				if (value === null) {
					delete _cache[name];
					chrome.storage.local.set({hello: _cache});
					return null;
				}
			};

			// Open function
			function _open(url, interactive) {

				// Launch
				var ref = {
					closed: false
				};

				// Launch the webAuthFlow
				chrome.identity.launchWebAuthFlow({
					url: url,
					interactive: interactive
				}, function(responseUrl) {

					// Did the user cancel this prematurely
					if (responseUrl === undefined) {
						ref.closed = true;
						return;
					}

					// Split appart the URL
					var a = hello.utils.url(responseUrl);

					// The location can be augmented in to a location object like so...
					// We dont have window operations on the popup so lets create some
					var _popup = {
						location: {

							// Change the location of the popup
							assign: function(url) {

								// If there is a secondary reassign
								// In the case of OAuth1
								// Trigger this in non-interactive mode.
								_open(url, false);
							},

							search: a.search,
							hash: a.hash,
							href: a.href
						},
						close: function() {}
					};

					// Then this URL contains information which HelloJS must process
					// URL string
					// Window - any action such as window relocation goes here
					// Opener - the parent window which opened this, aka this script

					hello.utils.responseHandler(_popup, window);
				});

				// Return the reference
				return ref;
			}

		})();
	}

	// Phonegap override for hello.phonegap.js
	(function() {

		// Is this a phonegap implementation?
		if (!(/^file:\/{3}[^\/]/.test(window.location.href) && window.cordova)) {
			// Cordova is not included.
			return;
		}

		// Augment the hidden iframe method
		hello.utils.iframe = function(url, redirectUri) {
			hello.utils.popup(url, redirectUri, {hidden: 'yes'});
		};

		// Augment the popup
		var utilPopup = hello.utils.popup;

		// Replace popup
		hello.utils.popup = function(url, redirectUri, options) {

			// Run the standard
			var popup = utilPopup.call(this, url, redirectUri, options);

			// Create a function for reopening the popup, and assigning events to the new popup object
			// PhoneGap support
			// Add an event listener to listen to the change in the popup windows URL
			// This must appear before popup.focus();
			try {
				if (popup && popup.addEventListener) {

					// Get the origin of the redirect URI

					var a = hello.utils.url(redirectUri);
					var redirectUriOrigin = a.origin || (a.protocol + '//' + a.hostname);

					// Listen to changes in the InAppBrowser window

					popup.addEventListener('loadstart', function(e) {

						var url = e.url;

						// Is this the path, as given by the redirectUri?
						// Check the new URL agains the redirectUriOrigin.
						// According to #63 a user could click 'cancel' in some dialog boxes ....
						// The popup redirects to another page with the same origin, yet we still wish it to close.

						if (url.indexOf(redirectUriOrigin) !== 0) {
							return;
						}

						// Split appart the URL
						var a = hello.utils.url(url);

						// We dont have window operations on the popup so lets create some
						// The location can be augmented in to a location object like so...

						var _popup = {
							location: {
								// Change the location of the popup
								assign: function(location) {

									// Unfourtunatly an app is may not change the location of a InAppBrowser window.
									// So to shim this, just open a new one.
									popup.executeScript({code: 'window.location.href = "' + location + ';"'});
								},

								search: a.search,
								hash: a.hash,
								href: a.href
							},
							close: function() {
								if (popup.close) {
									popup.close();
									try {
										popup.closed = true;
									}
									catch (_e) {}
								}
							}
						};

						// Then this URL contains information which HelloJS must process
						// URL string
						// Window - any action such as window relocation goes here
						// Opener - the parent window which opened this, aka this script

						hello.utils.responseHandler(_popup, window);

					});
				}
			}
			catch (e) {}

			return popup;
		};

	})();

	(function(hello) {

		// OAuth1
		var OAuth1Settings = {
			version: '1.0',
			auth: 'https://www.dropbox.com/1/oauth/authorize',
			request: 'https://api.dropbox.com/1/oauth/request_token',
			token: 'https://api.dropbox.com/1/oauth/access_token'
		};

		// OAuth2 Settings
		var OAuth2Settings = {
			version: 2,
			auth: 'https://www.dropbox.com/1/oauth2/authorize',
			grant: 'https://api.dropbox.com/1/oauth2/token'
		};

		// Initiate the Dropbox module
		hello.init({

			dropbox: {

				name: 'Dropbox',

				oauth: OAuth2Settings,

				login: function(p) {
					// OAuth2 non-standard adjustments
					p.qs.scope = '';

					// Should this be run as OAuth1?
					// If the redirect_uri is is HTTP (non-secure) then its required to revert to the OAuth1 endpoints
					var redirect = decodeURIComponent(p.qs.redirect_uri);
					if (redirect.indexOf('http:') === 0 && redirect.indexOf('http://localhost/') !== 0) {

						// Override the dropbox OAuth settings.
						hello.services.dropbox.oauth = OAuth1Settings;
					}
					else {
						// Override the dropbox OAuth settings.
						hello.services.dropbox.oauth = OAuth2Settings;
					}

					// The dropbox login window is a different size
					p.options.popup.width = 1000;
					p.options.popup.height = 1000;
				},

				/*
					Dropbox does not allow insecure HTTP URI's in the redirect_uri field
					...otherwise I'd love to use OAuth2

					Follow request https://forums.dropbox.com/topic.php?id=106505

					p.qs.response_type = 'code';
					oauth: {
						version: 2,
						auth: 'https://www.dropbox.com/1/oauth2/authorize',
						grant: 'https://api.dropbox.com/1/oauth2/token'
					}
				*/

				// API Base URL
				base: 'https://api.dropbox.com/1/',

				// Bespoke setting: this is states whether to use the custom environment of Dropbox or to use their own environment
				// Because it's notoriously difficult for Dropbox too provide access from other webservices, this defaults to Sandbox
				root: 'sandbox',

				// Map GET requests
				get: {
					me: 'account/info',

					// Https://www.dropbox.com/developers/core/docs#metadata
					'me/files': req('metadata/auto/@{parent|}'),
					'me/folder': req('metadata/auto/@{id}'),
					'me/folders': req('metadata/auto/'),

					'default': function(p, callback) {
						if (p.path.match('https://api-content.dropbox.com/1/files/')) {
							// This is a file, return binary data
							p.method = 'blob';
						}

						callback(p.path);
					}
				},

				post: {
					'me/files': function(p, callback) {

						var path = p.data.parent;
						var fileName = p.data.name;

						p.data = {
							file: p.data.file
						};

						// Does this have a data-uri to upload as a file?
						if (typeof (p.data.file) === 'string') {
							p.data.file = hello.utils.toBlob(p.data.file);
						}

						callback('https://api-content.dropbox.com/1/files_put/auto/' + path + '/' + fileName);
					},

					'me/folders': function(p, callback) {

						var name = p.data.name;
						p.data = {};

						callback('fileops/create_folder?root=@{root|sandbox}&' + hello.utils.param({
							path: name
						}));
					}
				},

				// Map DELETE requests
				del: {
					'me/files': 'fileops/delete?root=@{root|sandbox}&path=@{id}',
					'me/folder': 'fileops/delete?root=@{root|sandbox}&path=@{id}'
				},

				wrap: {
					me: function(o) {
						formatError(o);
						if (!o.uid) {
							return o;
						}

						o.name = o.display_name;
						var m = o.name.split(' ');
						o.first_name = m.shift();
						o.last_name = m.join(' ');
						o.id = o.uid;
						delete o.uid;
						delete o.display_name;
						return o;
					},

					'default': function(o, headers, req) {
						formatError(o);
						if (o.is_dir && o.contents) {
							o.data = o.contents;
							delete o.contents;

							o.data.forEach(function(item) {
								item.root = o.root;
								formatFile(item, headers, req);
							});
						}

						formatFile(o, headers, req);

						if (o.is_deleted) {
							o.success = true;
						}

						return o;
					}
				},

				// Doesn't return the CORS headers
				xhr: function(p) {

					// The proxy supports allow-cross-origin-resource
					// Alas that's the only thing we're using.
					if (p.data && p.data.file) {
						var file = p.data.file;
						if (file) {
							if (file.files) {
								p.data = file.files[0];
							}
							else {
								p.data = file;
							}
						}
					}

					if (p.method === 'delete') {
						p.method = 'post';
					}

					return true;
				},

				form: function(p, qs) {
					delete qs.state;
					delete qs.redirect_uri;
				}
			}
		});

		function formatError(o) {
			if (o && 'error' in o) {
				o.error = {
					code: 'server_error',
					message: o.error.message || o.error
				};
			}
		}

		function formatFile(o, headers, req) {

			if (typeof o !== 'object' ||
				(typeof Blob !== 'undefined' && o instanceof Blob) ||
				(typeof ArrayBuffer !== 'undefined' && o instanceof ArrayBuffer)) {
				// This is a file, let it through unformatted
				return;
			}

			if ('error' in o) {
				return;
			}

			var path = (o.root !== 'app_folder' ? o.root : '') + o.path.replace(/\&/g, '%26');
			path = path.replace(/^\//, '');
			if (o.thumb_exists) {
				o.thumbnail = req.oauth_proxy + '?path=' +
				encodeURIComponent('https://api-content.dropbox.com/1/thumbnails/auto/' + path + '?format=jpeg&size=m') + '&access_token=' + req.options.access_token;
			}

			o.type = (o.is_dir ? 'folder' : o.mime_type);
			o.name = o.path.replace(/.*\//g, '');
			if (o.is_dir) {
				o.files = path.replace(/^\//, '');
			}
			else {
				o.downloadLink = hello.settings.oauth_proxy + '?path=' +
				encodeURIComponent('https://api-content.dropbox.com/1/files/auto/' + path) + '&access_token=' + req.options.access_token;
				o.file = 'https://api-content.dropbox.com/1/files/auto/' + path;
			}

			if (!o.id) {
				o.id = o.path.replace(/^\//, '');
			}

			// O.media = 'https://api-content.dropbox.com/1/files/' + path;
		}

		function req(str) {
			return function(p, cb) {
				delete p.query.limit;
				cb(str);
			};
		}

	})(hello);

	(function(hello) {

		hello.init({

			facebook: {

				name: 'Facebook',

				// SEE https://developers.facebook.com/docs/facebook-login/manually-build-a-login-flow/v2.1
				oauth: {
					version: 2,
					auth: 'https://www.facebook.com/dialog/oauth/',
					grant: 'https://graph.facebook.com/oauth/access_token'
				},

				// Authorization scopes
				scope: {
					basic: 'public_profile',
					email: 'email',
					share: 'user_posts',
					birthday: 'user_birthday',
					events: 'user_events',
					photos: 'user_photos',
					videos: 'user_videos',
					friends: 'user_friends',
					files: 'user_photos,user_videos',
					publish_files: 'user_photos,user_videos,publish_actions',
					publish: 'publish_actions',

					// Deprecated in v2.0
					// Create_event	: 'create_event',

					offline_access: ''
				},

				// Refresh the access_token
				refresh: false,

				login: function(p) {

					// Reauthenticate
					// https://developers.facebook.com/docs/facebook-login/reauthentication
					if (p.options.force) {
						p.qs.auth_type = 'reauthenticate';
					}

					// Set the display value
					p.qs.display = p.options.display || 'popup';
				},

				logout: function(callback, options) {
					// Assign callback to a global handler
					var callbackID = hello.utils.globalEvent(callback);
					var redirect = encodeURIComponent(hello.settings.redirect_uri + '?' + hello.utils.param({callback:callbackID, result: JSON.stringify({force:true}), state: '{}'}));
					var token = (options.authResponse || {}).access_token;
					hello.utils.iframe('https://www.facebook.com/logout.php?next=' + redirect + '&access_token=' + token);

					// Possible responses:
					// String URL	- hello.logout should handle the logout
					// Undefined	- this function will handle the callback
					// True - throw a success, this callback isn't handling the callback
					// False - throw a error
					if (!token) {
						// If there isn't a token, the above wont return a response, so lets trigger a response
						return false;
					}
				},

				// API Base URL
				base: 'https://graph.facebook.com/v2.7/',

				// Map GET requests
				get: {
					me: 'me?fields=email,first_name,last_name,name,timezone,verified',
					'me/friends': 'me/friends',
					'me/following': 'me/friends',
					'me/followers': 'me/friends',
					'me/share': 'me/feed',
					'me/like': 'me/likes',
					'me/files': 'me/albums',
					'me/albums': 'me/albums?fields=cover_photo,name',
					'me/album': '@{id}/photos?fields=picture',
					'me/photos': 'me/photos',
					'me/photo': '@{id}',
					'friend/albums': '@{id}/albums',
					'friend/photos': '@{id}/photos'

					// Pagination
					// Https://developers.facebook.com/docs/reference/api/pagination/
				},

				// Map POST requests
				post: {
					'me/share': 'me/feed',
					'me/photo': '@{id}'

					// Https://developers.facebook.com/docs/graph-api/reference/v2.2/object/likes/
				},

				wrap: {
					me: formatUser,
					'me/friends': formatFriends,
					'me/following': formatFriends,
					'me/followers': formatFriends,
					'me/albums': format,
					'me/photos': format,
					'me/files': format,
					'default': format
				},

				// Special requirements for handling XHR
				xhr: function(p, qs) {
					if (p.method === 'get' || p.method === 'post') {
						qs.suppress_response_codes = true;
					}

					// Is this a post with a data-uri?
					if (p.method === 'post' && p.data && typeof (p.data.file) === 'string') {
						// Convert the Data-URI to a Blob
						p.data.file = hello.utils.toBlob(p.data.file);
					}

					return true;
				},

				// Special requirements for handling JSONP fallback
				jsonp: function(p, qs) {
					var m = p.method;
					if (m !== 'get' && !hello.utils.hasBinary(p.data)) {
						p.data.method = m;
						p.method = 'get';
					}
					else if (p.method === 'delete') {
						qs.method = 'delete';
						p.method = 'post';
					}
				},

				// Special requirements for iframe form hack
				form: function(p) {
					return {
						// Fire the callback onload
						callbackonload: true
					};
				}
			}
		});

		var base = 'https://graph.facebook.com/';

		function formatUser(o) {
			if (o.id) {
				o.thumbnail = o.picture = 'https://graph.facebook.com/' + o.id + '/picture';
			}

			return o;
		}

		function formatFriends(o) {
			if ('data' in o) {
				o.data.forEach(formatUser);
			}

			return o;
		}

		function format(o, headers, req) {
			if (typeof o === 'boolean') {
				o = {success: o};
			}

			if (o && 'data' in o) {
				var token = req.query.access_token;

				if (!(o.data instanceof Array)) {
					var data = o.data;
					delete o.data;
					o.data = [data];
				}

				o.data.forEach(function(d) {

					if (d.picture) {
						d.thumbnail = d.picture;
					}

					d.pictures = (d.images || [])
						.sort(function(a, b) {
							return a.width - b.width;
						});

					if (d.cover_photo && d.cover_photo.id) {
						d.thumbnail = base + d.cover_photo.id + '/picture?access_token=' + token;
					}

					if (d.type === 'album') {
						d.files = d.photos = base + d.id + '/photos';
					}

					if (d.can_upload) {
						d.upload_location = base + d.id + '/photos';
					}
				});
			}

			return o;
		}

	})(hello);

	(function(hello) {

		hello.init({

			flickr: {

				name: 'Flickr',

				// Ensure that you define an oauth_proxy
				oauth: {
					version: '1.0a',
					auth: 'https://www.flickr.com/services/oauth/authorize?perms=read',
					request: 'https://www.flickr.com/services/oauth/request_token',
					token: 'https://www.flickr.com/services/oauth/access_token'
				},

				// API base URL
				base: 'https://api.flickr.com/services/rest',

				// Map GET resquests
				get: {
					me: sign('flickr.people.getInfo'),
					'me/friends': sign('flickr.contacts.getList', {per_page:'@{limit|50}'}),
					'me/following': sign('flickr.contacts.getList', {per_page:'@{limit|50}'}),
					'me/followers': sign('flickr.contacts.getList', {per_page:'@{limit|50}'}),
					'me/albums': sign('flickr.photosets.getList', {per_page:'@{limit|50}'}),
					'me/album': sign('flickr.photosets.getPhotos', {photoset_id: '@{id}'}),
					'me/photos': sign('flickr.people.getPhotos', {per_page:'@{limit|50}'})
				},

				wrap: {
					me: function(o) {
						formatError(o);
						o = checkResponse(o, 'person');
						if (o.id) {
							if (o.realname) {
								o.name = o.realname._content;
								var m = o.name.split(' ');
								o.first_name = m.shift();
								o.last_name = m.join(' ');
							}

							o.thumbnail = getBuddyIcon(o, 'l');
							o.picture = getBuddyIcon(o, 'l');
						}

						return o;
					},

					'me/friends': formatFriends,
					'me/followers': formatFriends,
					'me/following': formatFriends,
					'me/albums': function(o) {
						formatError(o);
						o = checkResponse(o, 'photosets');
						paging(o);
						if (o.photoset) {
							o.data = o.photoset;
							o.data.forEach(function(item) {
								item.name = item.title._content;
								item.photos = 'https://api.flickr.com/services/rest' + getApiUrl('flickr.photosets.getPhotos', {photoset_id: item.id}, true);
							});

							delete o.photoset;
						}

						return o;
					},

					'me/photos': function(o) {
						formatError(o);
						return formatPhotos(o);
					},

					'default': function(o) {
						formatError(o);
						return formatPhotos(o);
					}
				},

				xhr: false,

				jsonp: function(p, qs) {
					if (p.method == 'get') {
						delete qs.callback;
						qs.jsoncallback = p.callbackID;
					}
				}
			}
		});

		function getApiUrl(method, extraParams, skipNetwork) {
			var url = ((skipNetwork) ? '' : 'flickr:') +
				'?method=' + method +
				'&api_key=' + hello.services.flickr.id +
				'&format=json';
			for (var param in extraParams) {
				if (extraParams.hasOwnProperty(param)) {
					url += '&' + param + '=' + extraParams[param];
				}
			}

			return url;
		}

		// This is not exactly neat but avoid to call
		// The method 'flickr.test.login' for each api call

		function withUser(cb) {
			var auth = hello.getAuthResponse('flickr');
			cb(auth && auth.user_nsid ? auth.user_nsid : null);
		}

		function sign(url, params) {
			if (!params) {
				params = {};
			}

			return function(p, callback) {
				withUser(function(userId) {
					params.user_id = userId;
					callback(getApiUrl(url, params, true));
				});
			};
		}

		function getBuddyIcon(profile, size) {
			var url = 'https://www.flickr.com/images/buddyicon.gif';
			if (profile.nsid && profile.iconserver && profile.iconfarm) {
				url = 'https://farm' + profile.iconfarm + '.staticflickr.com/' +
					profile.iconserver + '/' +
					'buddyicons/' + profile.nsid +
					((size) ? '_' + size : '') + '.jpg';
			}

			return url;
		}

		// See: https://www.flickr.com/services/api/misc.urls.html
		function createPhotoUrl(id, farm, server, secret, size) {
			size = (size) ? '_' + size : '';
			return 'https://farm' + farm + '.staticflickr.com/' + server + '/' + id + '_' + secret + size + '.jpg';
		}

		function formatUser(o) {
		}

		function formatError(o) {
			if (o && o.stat && o.stat.toLowerCase() != 'ok') {
				o.error = {
					code: 'invalid_request',
					message: o.message
				};
			}
		}

		function formatPhotos(o) {
			if (o.photoset || o.photos) {
				var set = ('photoset' in o) ? 'photoset' : 'photos';
				o = checkResponse(o, set);
				paging(o);
				o.data = o.photo;
				delete o.photo;
				for (var i = 0; i < o.data.length; i++) {
					var photo = o.data[i];
					photo.name = photo.title;
					photo.picture = createPhotoUrl(photo.id, photo.farm, photo.server, photo.secret, '');
					photo.pictures = createPictures(photo.id, photo.farm, photo.server, photo.secret);
					photo.source = createPhotoUrl(photo.id, photo.farm, photo.server, photo.secret, 'b');
					photo.thumbnail = createPhotoUrl(photo.id, photo.farm, photo.server, photo.secret, 'm');
				}
			}

			return o;
		}

		// See: https://www.flickr.com/services/api/misc.urls.html
		function createPictures(id, farm, server, secret) {

			var NO_LIMIT = 2048;
			var sizes = [
				{id: 't', max: 100},
				{id: 'm', max: 240},
				{id: 'n', max: 320},
				{id: '', max: 500},
				{id: 'z', max: 640},
				{id: 'c', max: 800},
				{id: 'b', max: 1024},
				{id: 'h', max: 1600},
				{id: 'k', max: 2048},
				{id: 'o', max: NO_LIMIT}
			];

			return sizes.map(function(size) {
				return {
					source: createPhotoUrl(id, farm, server, secret, size.id),

					// Note: this is a guess that's almost certain to be wrong (unless square source)
					width: size.max,
					height: size.max
				};
			});
		}

		function checkResponse(o, key) {

			if (key in o) {
				o = o[key];
			}
			else if (!('error' in o)) {
				o.error = {
					code: 'invalid_request',
					message: o.message || 'Failed to get data from Flickr'
				};
			}

			return o;
		}

		function formatFriends(o) {
			formatError(o);
			if (o.contacts) {
				o = checkResponse(o, 'contacts');
				paging(o);
				o.data = o.contact;
				delete o.contact;
				for (var i = 0; i < o.data.length; i++) {
					var item = o.data[i];
					item.id = item.nsid;
					item.name = item.realname || item.username;
					item.thumbnail = getBuddyIcon(item, 'm');
				}
			}

			return o;
		}

		function paging(res) {
			if (res.page && res.pages && res.page !== res.pages) {
				res.paging = {
					next: '?page=' + (++res.page)
				};
			}
		}

	})(hello);

	(function(hello) {

		hello.init({

			foursquare: {

				name: 'Foursquare',

				oauth: {
					// See: https://developer.foursquare.com/overview/auth
					version: 2,
					auth: 'https://foursquare.com/oauth2/authenticate',
					grant: 'https://foursquare.com/oauth2/access_token'
				},

				// Refresh the access_token once expired
				refresh: true,

				base: 'https://api.foursquare.com/v2/',

				get: {
					me: 'users/self',
					'me/friends': 'users/self/friends',
					'me/followers': 'users/self/friends',
					'me/following': 'users/self/friends'
				},

				wrap: {
					me: function(o) {
						formatError(o);
						if (o && o.response) {
							o = o.response.user;
							formatUser(o);
						}

						return o;
					},

					'default': function(o) {
						formatError(o);

						// Format friends
						if (o && 'response' in o && 'friends' in o.response && 'items' in o.response.friends) {
							o.data = o.response.friends.items;
							o.data.forEach(formatUser);
							delete o.response;
						}

						return o;
					}
				},

				xhr: formatRequest,
				jsonp: formatRequest
			}
		});

		function formatError(o) {
			if (o.meta && (o.meta.code === 400 || o.meta.code === 401)) {
				o.error = {
					code: 'access_denied',
					message: o.meta.errorDetail
				};
			}
		}

		function formatUser(o) {
			if (o && o.id) {
				o.thumbnail = o.photo.prefix + '100x100' + o.photo.suffix;
				o.name = o.firstName + ' ' + o.lastName;
				o.first_name = o.firstName;
				o.last_name = o.lastName;
				if (o.contact) {
					if (o.contact.email) {
						o.email = o.contact.email;
					}
				}
			}
		}

		function formatRequest(p, qs) {
			var token = qs.access_token;
			delete qs.access_token;
			qs.oauth_token = token;
			qs.v = 20121125;
			return true;
		}

	})(hello);

	(function(hello) {

		hello.init({

			github: {

				name: 'GitHub',

				oauth: {
					version: 2,
					auth: 'https://github.com/login/oauth/authorize',
					grant: 'https://github.com/login/oauth/access_token',
					response_type: 'code'
				},

				scope: {
					email: 'user:email'
				},

				base: 'https://api.github.com/',

				get: {
					me: 'user',
					'me/friends': 'user/following?per_page=@{limit|100}',
					'me/following': 'user/following?per_page=@{limit|100}',
					'me/followers': 'user/followers?per_page=@{limit|100}',
					'me/like': 'user/starred?per_page=@{limit|100}'
				},

				wrap: {
					me: function(o, headers) {

						formatError(o, headers);
						formatUser(o);

						return o;
					},

					'default': function(o, headers, req) {

						formatError(o, headers);

						if (Array.isArray(o)) {
							o = {data:o};
						}

						if (o.data) {
							paging(o, headers, req);
							o.data.forEach(formatUser);
						}

						return o;
					}
				},

				xhr: function(p) {

					if (p.method !== 'get' && p.data) {

						// Serialize payload as JSON
						p.headers = p.headers || {};
						p.headers['Content-Type'] = 'application/json';
						if (typeof (p.data) === 'object') {
							p.data = JSON.stringify(p.data);
						}
					}

					return true;
				}
			}
		});

		function formatError(o, headers) {
			var code = headers ? headers.statusCode : (o && 'meta' in o && 'status' in o.meta && o.meta.status);
			if ((code === 401 || code === 403)) {
				o.error = {
					code: 'access_denied',
					message: o.message || (o.data ? o.data.message : 'Could not get response')
				};
				delete o.message;
			}
		}

		function formatUser(o) {
			if (o.id) {
				o.thumbnail = o.picture = o.avatar_url;
				o.name = o.login;
			}
		}

		function paging(res, headers, req) {
			if (res.data && res.data.length && headers && headers.Link) {
				var next = headers.Link.match(/<(.*?)>;\s*rel=\"next\"/);
				if (next) {
					res.paging = {
						next: next[1]
					};
				}
			}
		}

	})(hello);

	(function(hello) {

		var contactsUrl = 'https://www.google.com/m8/feeds/contacts/default/full?v=3.0&alt=json&max-results=@{limit|1000}&start-index=@{start|1}';

		hello.init({

			google: {

				name: 'Google Plus',

				// See: http://code.google.com/apis/accounts/docs/OAuth2UserAgent.html
				oauth: {
					version: 2,
					auth: 'https://accounts.google.com/o/oauth2/auth',
					grant: 'https://accounts.google.com/o/oauth2/token'
				},

				// Authorization scopes
				scope: {
					basic: 'https://www.googleapis.com/auth/plus.me profile',
					email: 'email',
					birthday: '',
					events: '',
					photos: 'https://picasaweb.google.com/data/',
					videos: 'http://gdata.youtube.com',
					friends: 'https://www.google.com/m8/feeds, https://www.googleapis.com/auth/plus.login',
					files: 'https://www.googleapis.com/auth/drive.readonly',
					publish: '',
					publish_files: 'https://www.googleapis.com/auth/drive',
					share: '',
					create_event: '',
					offline_access: ''
				},

				scope_delim: ' ',

				login: function(p) {

					if (p.qs.response_type === 'code') {

						// Let's set this to an offline access to return a refresh_token
						p.qs.access_type = 'offline';
					}

					// Reauthenticate
					// https://developers.google.com/identity/protocols/
					if (p.options.force) {
						p.qs.approval_prompt = 'force';
					}
				},

				// API base URI
				base: 'https://www.googleapis.com/',

				// Map GET requests
				get: {
					me: 'plus/v1/people/me',

					// Deprecated Sept 1, 2014
					//'me': 'oauth2/v1/userinfo?alt=json',

					// See: https://developers.google.com/+/api/latest/people/list
					'me/friends': 'plus/v1/people/me/people/visible?maxResults=@{limit|100}',
					'me/following': contactsUrl,
					'me/followers': contactsUrl,
					'me/contacts': contactsUrl,
					'me/share': 'plus/v1/people/me/activities/public?maxResults=@{limit|100}',
					'me/feed': 'plus/v1/people/me/activities/public?maxResults=@{limit|100}',
					'me/albums': 'https://picasaweb.google.com/data/feed/api/user/default?alt=json&max-results=@{limit|100}&start-index=@{start|1}',
					'me/album': function(p, callback) {
						var key = p.query.id;
						delete p.query.id;
						callback(key.replace('/entry/', '/feed/'));
					},

					'me/photos': 'https://picasaweb.google.com/data/feed/api/user/default?alt=json&kind=photo&max-results=@{limit|100}&start-index=@{start|1}',

					// See: https://developers.google.com/drive/v2/reference/files/list
					'me/file': 'drive/v2/files/@{id}',
					'me/files': 'drive/v2/files?q=%22@{parent|root}%22+in+parents+and+trashed=false&maxResults=@{limit|100}',

					// See: https://developers.google.com/drive/v2/reference/files/list
					'me/folders': 'drive/v2/files?q=%22@{id|root}%22+in+parents+and+mimeType+=+%22application/vnd.google-apps.folder%22+and+trashed=false&maxResults=@{limit|100}',

					// See: https://developers.google.com/drive/v2/reference/files/list
					'me/folder': 'drive/v2/files?q=%22@{id|root}%22+in+parents+and+trashed=false&maxResults=@{limit|100}'
				},

				// Map POST requests
				post: {

					// Google Drive
					'me/files': uploadDrive,
					'me/folders': function(p, callback) {
						p.data = {
							title: p.data.name,
							parents: [{id: p.data.parent || 'root'}],
							mimeType: 'application/vnd.google-apps.folder'
						};
						callback('drive/v2/files');
					}
				},

				// Map PUT requests
				put: {
					'me/files': uploadDrive
				},

				// Map DELETE requests
				del: {
					'me/files': 'drive/v2/files/@{id}',
					'me/folder': 'drive/v2/files/@{id}'
				},

				// Map PATCH requests
				patch: {
					'me/file': 'drive/v2/files/@{id}'
				},

				wrap: {
					me: function(o) {
						if (o.id) {
							o.last_name = o.family_name || (o.name ? o.name.familyName : null);
							o.first_name = o.given_name || (o.name ? o.name.givenName : null);

							if (o.emails && o.emails.length) {
								o.email = o.emails[0].value;
							}

							formatPerson(o);
						}

						return o;
					},

					'me/friends': function(o) {
						if (o.items) {
							paging(o);
							o.data = o.items;
							o.data.forEach(formatPerson);
							delete o.items;
						}

						return o;
					},

					'me/contacts': formatFriends,
					'me/followers': formatFriends,
					'me/following': formatFriends,
					'me/share': formatFeed,
					'me/feed': formatFeed,
					'me/albums': gEntry,
					'me/photos': formatPhotos,
					'default': gEntry
				},

				xhr: function(p) {

					if (p.method === 'post' || p.method === 'put') {
						toJSON(p);
					}
					else if (p.method === 'patch') {
						hello.utils.extend(p.query, p.data);
						p.data = null;
					}

					return true;
				},

				// Don't even try submitting via form.
				// This means no POST operations in <=IE9
				form: false
			}
		});

		function toInt(s) {
			return parseInt(s, 10);
		}

		function formatFeed(o) {
			paging(o);
			o.data = o.items;
			delete o.items;
			return o;
		}

		// Format: ensure each record contains a name, id etc.
		function formatItem(o) {
			if (o.error) {
				return;
			}

			if (!o.name) {
				o.name = o.title || o.message;
			}

			if (!o.picture) {
				o.picture = o.thumbnailLink;
			}

			if (!o.thumbnail) {
				o.thumbnail = o.thumbnailLink;
			}

			if (o.mimeType === 'application/vnd.google-apps.folder') {
				o.type = 'folder';
				o.files = 'https://www.googleapis.com/drive/v2/files?q=%22' + o.id + '%22+in+parents';
			}

			return o;
		}

		function formatImage(image) {
			return {
				source: image.url,
				width: image.width,
				height: image.height
			};
		}

		function formatPhotos(o) {
			o.data = o.feed.entry.map(formatEntry);
			delete o.feed;
		}

		// Google has a horrible JSON API
		function gEntry(o) {
			paging(o);

			if ('feed' in o && 'entry' in o.feed) {
				o.data = o.feed.entry.map(formatEntry);
				delete o.feed;
			}

			// Old style: Picasa, etc.
			else if ('entry' in o) {
				return formatEntry(o.entry);
			}

			// New style: Google Drive & Plus
			else if ('items' in o) {
				o.data = o.items.map(formatItem);
				delete o.items;
			}
			else {
				formatItem(o);
			}

			return o;
		}

		function formatPerson(o) {
			o.name = o.displayName || o.name;
			o.picture = o.picture || (o.image ? o.image.url : null);
			o.thumbnail = o.picture;
		}

		function formatFriends(o, headers, req) {
			paging(o);
			var r = [];
			if ('feed' in o && 'entry' in o.feed) {
				var token = req.query.access_token;
				for (var i = 0; i < o.feed.entry.length; i++) {
					var a = o.feed.entry[i];

					a.id	= a.id.$t;
					a.name	= a.title.$t;
					delete a.title;
					if (a.gd$email) {
						a.email	= (a.gd$email && a.gd$email.length > 0) ? a.gd$email[0].address : null;
						a.emails = a.gd$email;
						delete a.gd$email;
					}

					if (a.updated) {
						a.updated = a.updated.$t;
					}

					if (a.link) {

						var pic = (a.link.length > 0) ? a.link[0].href : null;
						if (pic && a.link[0].gd$etag) {
							pic += (pic.indexOf('?') > -1 ? '&' : '?') + 'access_token=' + token;
							a.picture = pic;
							a.thumbnail = pic;
						}

						delete a.link;
					}

					if (a.category) {
						delete a.category;
					}
				}

				o.data = o.feed.entry;
				delete o.feed;
			}

			return o;
		}

		function formatEntry(a) {

			var group = a.media$group;
			var photo = group.media$content.length ? group.media$content[0] : {};
			var mediaContent = group.media$content || [];
			var mediaThumbnail = group.media$thumbnail || [];

			var pictures = mediaContent
				.concat(mediaThumbnail)
				.map(formatImage)
				.sort(function(a, b) {
					return a.width - b.width;
				});

			var i = 0;
			var _a;
			var p = {
				id: a.id.$t,
				name: a.title.$t,
				description: a.summary.$t,
				updated_time: a.updated.$t,
				created_time: a.published.$t,
				picture: photo ? photo.url : null,
				pictures: pictures,
				images: [],
				thumbnail: photo ? photo.url : null,
				width: photo.width,
				height: photo.height
			};

			// Get feed/children
			if ('link' in a) {
				for (i = 0; i < a.link.length; i++) {
					var d = a.link[i];
					if (d.rel.match(/\#feed$/)) {
						p.upload_location = p.files = p.photos = d.href;
						break;
					}
				}
			}

			// Get images of different scales
			if ('category' in a && a.category.length) {
				_a = a.category;
				for (i = 0; i < _a.length; i++) {
					if (_a[i].scheme && _a[i].scheme.match(/\#kind$/)) {
						p.type = _a[i].term.replace(/^.*?\#/, '');
					}
				}
			}

			// Get images of different scales
			if ('media$thumbnail' in group && group.media$thumbnail.length) {
				_a = group.media$thumbnail;
				p.thumbnail = _a[0].url;
				p.images = _a.map(formatImage);
			}

			_a = group.media$content;

			if (_a && _a.length) {
				p.images.push(formatImage(_a[0]));
			}

			return p;
		}

		function paging(res) {

			// Contacts V2
			if ('feed' in res && res.feed.openSearch$itemsPerPage) {
				var limit = toInt(res.feed.openSearch$itemsPerPage.$t);
				var start = toInt(res.feed.openSearch$startIndex.$t);
				var total = toInt(res.feed.openSearch$totalResults.$t);

				if ((start + limit) < total) {
					res.paging = {
						next: '?start=' + (start + limit)
					};
				}
			}
			else if ('nextPageToken' in res) {
				res.paging = {
					next: '?pageToken=' + res.nextPageToken
				};
			}
		}

		// Construct a multipart message
		function Multipart() {

			// Internal body
			var body = [];
			var boundary = (Math.random() * 1e10).toString(32);
			var counter = 0;
			var lineBreak = '\r\n';
			var delim = lineBreak + '--' + boundary;
			var ready = function() {};

			var dataUri = /^data\:([^;,]+(\;charset=[^;,]+)?)(\;base64)?,/i;

			// Add file
			function addFile(item) {
				var fr = new FileReader();
				fr.onload = function(e) {
					addContent(btoa(e.target.result), item.type + lineBreak + 'Content-Transfer-Encoding: base64');
				};

				fr.readAsBinaryString(item);
			}

			// Add content
			function addContent(content, type) {
				body.push(lineBreak + 'Content-Type: ' + type + lineBreak + lineBreak + content);
				counter--;
				ready();
			}

			// Add new things to the object
			this.append = function(content, type) {

				// Does the content have an array
				if (typeof (content) === 'string' || !('length' in Object(content))) {
					// Converti to multiples
					content = [content];
				}

				for (var i = 0; i < content.length; i++) {

					counter++;

					var item = content[i];

					// Is this a file?
					// Files can be either Blobs or File types
					if (
						(typeof (File) !== 'undefined' && item instanceof File) ||
						(typeof (Blob) !== 'undefined' && item instanceof Blob)
					) {
						// Read the file in
						addFile(item);
					}

					// Data-URI?
					// Data:[<mime type>][;charset=<charset>][;base64],<encoded data>
					// /^data\:([^;,]+(\;charset=[^;,]+)?)(\;base64)?,/i
					else if (typeof (item) === 'string' && item.match(dataUri)) {
						var m = item.match(dataUri);
						addContent(item.replace(dataUri, ''), m[1] + lineBreak + 'Content-Transfer-Encoding: base64');
					}

					// Regular string
					else {
						addContent(item, type);
					}
				}
			};

			this.onready = function(fn) {
				ready = function() {
					if (counter === 0) {
						// Trigger ready
						body.unshift('');
						body.push('--');
						fn(body.join(delim), boundary);
						body = [];
					}
				};

				ready();
			};
		}

		// Upload to Drive
		// If this is PUT then only augment the file uploaded
		// PUT https://developers.google.com/drive/v2/reference/files/update
		// POST https://developers.google.com/drive/manage-uploads
		function uploadDrive(p, callback) {

			var data = {};

			// Test for DOM element
			if (p.data &&
				(typeof (HTMLInputElement) !== 'undefined' && p.data instanceof HTMLInputElement)
			) {
				p.data = {file: p.data};
			}

			if (!p.data.name && Object(Object(p.data.file).files).length && p.method === 'post') {
				p.data.name = p.data.file.files[0].name;
			}

			if (p.method === 'post') {
				p.data = {
					title: p.data.name,
					parents: [{id: p.data.parent || 'root'}],
					file: p.data.file
				};
			}
			else {

				// Make a reference
				data = p.data;
				p.data = {};

				// Add the parts to change as required
				if (data.parent) {
					p.data.parents = [{id: p.data.parent || 'root'}];
				}

				if (data.file) {
					p.data.file = data.file;
				}

				if (data.name) {
					p.data.title = data.name;
				}
			}

			// Extract the file, if it exists from the data object
			// If the File is an INPUT element lets just concern ourselves with the NodeList
			var file;
			if ('file' in p.data) {
				file = p.data.file;
				delete p.data.file;

				if (typeof (file) === 'object' && 'files' in file) {
					// Assign the NodeList
					file = file.files;
				}

				if (!file || !file.length) {
					callback({
						error: {
							code: 'request_invalid',
							message: 'There were no files attached with this request to upload'
						}
					});
					return;
				}
			}

			// Set type p.data.mimeType = Object(file[0]).type || 'application/octet-stream';

			// Construct a multipart message
			var parts = new Multipart();
			parts.append(JSON.stringify(p.data), 'application/json');

			// Read the file into a  base64 string... yep a hassle, i know
			// FormData doesn't let us assign our own Multipart headers and HTTP Content-Type
			// Alas GoogleApi need these in a particular format
			if (file) {
				parts.append(file);
			}

			parts.onready(function(body, boundary) {

				p.headers['content-type'] = 'multipart/related; boundary="' + boundary + '"';
				p.data = body;

				callback('upload/drive/v2/files' + (data.id ? '/' + data.id : '') + '?uploadType=multipart');
			});

		}

		function toJSON(p) {
			if (typeof (p.data) === 'object') {
				// Convert the POST into a javascript object
				try {
					p.data = JSON.stringify(p.data);
					p.headers['content-type'] = 'application/json';
				}
				catch (e) {}
			}
		}

	})(hello);

	(function(hello) {

		hello.init({

			instagram: {

				name: 'Instagram',

				oauth: {
					// See: http://instagram.com/developer/authentication/
					version: 2,
					auth: 'https://instagram.com/oauth/authorize/',
					grant: 'https://api.instagram.com/oauth/access_token'
				},

				// Refresh the access_token once expired
				refresh: true,

				scope: {
					basic: 'basic',
					photos: '',
					friends: 'relationships',
					publish: 'likes comments',
					email: '',
					share: '',
					publish_files: '',
					files: '',
					videos: '',
					offline_access: ''
				},

				scope_delim: ' ',

				base: 'https://api.instagram.com/v1/',

				get: {
					me: 'users/self',
					'me/feed': 'users/self/feed?count=@{limit|100}',
					'me/photos': 'users/self/media/recent?min_id=0&count=@{limit|100}',
					'me/friends': 'users/self/follows?count=@{limit|100}',
					'me/following': 'users/self/follows?count=@{limit|100}',
					'me/followers': 'users/self/followed-by?count=@{limit|100}',
					'friend/photos': 'users/@{id}/media/recent?min_id=0&count=@{limit|100}'
				},

				post: {
					'me/like': function(p, callback) {
						var id = p.data.id;
						p.data = {};
						callback('media/' + id + '/likes');
					}
				},

				del: {
					'me/like': 'media/@{id}/likes'
				},

				wrap: {
					me: function(o) {

						formatError(o);

						if ('data' in o) {
							o.id = o.data.id;
							o.thumbnail = o.data.profile_picture;
							o.name = o.data.full_name || o.data.username;
						}

						return o;
					},

					'me/friends': formatFriends,
					'me/following': formatFriends,
					'me/followers': formatFriends,
					'me/photos': function(o) {

						formatError(o);
						paging(o);

						if ('data' in o) {
							o.data = o.data.filter(function(d) {
								return d.type === 'image';
							});

							o.data.forEach(function(d) {
								d.name = d.caption ? d.caption.text : null;
								d.thumbnail = d.images.thumbnail.url;
								d.picture = d.images.standard_resolution.url;
								d.pictures = Object.keys(d.images)
									.map(function(key) {
										var image = d.images[key];
										return formatImage(image);
									})
									.sort(function(a, b) {
										return a.width - b.width;
									});
							});
						}

						return o;
					},

					'default': function(o) {
						o = formatError(o);
						paging(o);
						return o;
					}
				},

				// Instagram does not return any CORS Headers
				// So besides JSONP we're stuck with proxy
				xhr: function(p, qs) {

					var method = p.method;
					var proxy = method !== 'get';

					if (proxy) {

						if ((method === 'post' || method === 'put') && p.query.access_token) {
							p.data.access_token = p.query.access_token;
							delete p.query.access_token;
						}

						// No access control headers
						// Use the proxy instead
						p.proxy = proxy;
					}

					return proxy;
				},

				// No form
				form: false
			}
		});

		function formatImage(image) {
			return {
				source: image.url,
				width: image.width,
				height: image.height
			};
		}

		function formatError(o) {
			if (typeof o === 'string') {
				return {
					error: {
						code: 'invalid_request',
						message: o
					}
				};
			}

			if (o && 'meta' in o && 'error_type' in o.meta) {
				o.error = {
					code: o.meta.error_type,
					message: o.meta.error_message
				};
			}

			return o;
		}

		function formatFriends(o) {
			paging(o);
			if (o && 'data' in o) {
				o.data.forEach(formatFriend);
			}

			return o;
		}

		function formatFriend(o) {
			if (o.id) {
				o.thumbnail = o.profile_picture;
				o.name = o.full_name || o.username;
			}
		}

		// See: http://instagram.com/developer/endpoints/
		function paging(res) {
			if ('pagination' in res) {
				res.paging = {
					next: res.pagination.next_url
				};
				delete res.pagination;
			}
		}

	})(hello);

	(function(hello) {

		hello.init({

			joinme: {

				name: 'join.me',

				oauth: {
					version: 2,
					auth: 'https://secure.join.me/api/public/v1/auth/oauth2',
					grant: 'https://secure.join.me/api/public/v1/auth/oauth2'
				},

				refresh: false,

				scope: {
					basic: 'user_info',
					user: 'user_info',
					scheduler: 'scheduler',
					start: 'start_meeting',
					email: '',
					friends: '',
					share: '',
					publish: '',
					photos: '',
					publish_files: '',
					files: '',
					videos: '',
					offline_access: ''
				},

				scope_delim: ' ',

				login: function(p) {
					p.options.popup.width = 400;
					p.options.popup.height = 700;
				},

				base: 'https://api.join.me/v1/',

				get: {
					me: 'user',
					meetings: 'meetings',
					'meetings/info': 'meetings/@{id}'
				},

				post: {
					'meetings/start/adhoc': function(p, callback) {
						callback('meetings/start');
					},

					'meetings/start/scheduled': function(p, callback) {
						var meetingId = p.data.meetingId;
						p.data = {};
						callback('meetings/' + meetingId + '/start');
					},

					'meetings/schedule': function(p, callback) {
						callback('meetings');
					}
				},

				patch: {
					'meetings/update': function(p, callback) {
						callback('meetings/' + p.data.meetingId);
					}
				},

				del: {
					'meetings/delete': 'meetings/@{id}'
				},

				wrap: {
					me: function(o, headers) {
						formatError(o, headers);

						if (!o.email) {
							return o;
						}

						o.name = o.fullName;
						o.first_name = o.name.split(' ')[0];
						o.last_name = o.name.split(' ')[1];
						o.id = o.email;

						return o;
					},

					'default': function(o, headers) {
						formatError(o, headers);

						return o;
					}
				},

				xhr: formatRequest

			}
		});

		function formatError(o, headers) {
			var errorCode;
			var message;
			var details;

			if (o && ('Message' in o)) {
				message = o.Message;
				delete o.Message;

				if ('ErrorCode' in o) {
					errorCode = o.ErrorCode;
					delete o.ErrorCode;
				}
				else {
					errorCode = getErrorCode(headers);
				}

				o.error = {
					code: errorCode,
					message: message,
					details: o
				};
			}

			return o;
		}

		function formatRequest(p, qs) {
			// Move the access token from the request body to the request header
			var token = qs.access_token;
			delete qs.access_token;
			p.headers.Authorization = 'Bearer ' + token;

			// Format non-get requests to indicate json body
			if (p.method !== 'get' && p.data) {
				p.headers['Content-Type'] = 'application/json';
				if (typeof (p.data) === 'object') {
					p.data = JSON.stringify(p.data);
				}
			}

			if (p.method === 'put') {
				p.method = 'patch';
			}

			return true;
		}

		function getErrorCode(headers) {
			switch (headers.statusCode) {
				case 400:
					return 'invalid_request';
				case 403:
					return 'stale_token';
				case 401:
					return 'invalid_token';
				case 500:
					return 'server_error';
				default:
					return 'server_error';
			}
		}

	}(hello));

	(function(hello) {

		hello.init({

			linkedin: {

				oauth: {
					version: 2,
					response_type: 'code',
					auth: 'https://www.linkedin.com/uas/oauth2/authorization',
					grant: 'https://www.linkedin.com/uas/oauth2/accessToken'
				},

				// Refresh the access_token once expired
				refresh: true,

				scope: {
					basic: 'r_basicprofile',
					email: 'r_emailaddress',
					files: '',
					friends: '',
					photos: '',
					publish: 'w_share',
					publish_files: 'w_share',
					share: '',
					videos: '',
					offline_access: ''
				},
				scope_delim: ' ',

				base: 'https://api.linkedin.com/v1/',

				get: {
					me: 'people/~:(picture-url,first-name,last-name,id,formatted-name,email-address)',

					// See: http://developer.linkedin.com/documents/get-network-updates-and-statistics-api
					'me/share': 'people/~/network/updates?count=@{limit|250}'
				},

				post: {

					// See: https://developer.linkedin.com/documents/api-requests-json
					'me/share': function(p, callback) {
						var data = {
							visibility: {
								code: 'anyone'
							}
						};

						if (p.data.id) {

							data.attribution = {
								share: {
									id: p.data.id
								}
							};

						}
						else {
							data.comment = p.data.message;
							if (p.data.picture && p.data.link) {
								data.content = {
									'submitted-url': p.data.link,
									'submitted-image-url': p.data.picture
								};
							}
						}

						p.data = JSON.stringify(data);

						callback('people/~/shares?format=json');
					},

					'me/like': like
				},

				del:{
					'me/like': like
				},

				wrap: {
					me: function(o) {
						formatError(o);
						formatUser(o);
						return o;
					},

					'me/friends': formatFriends,
					'me/following': formatFriends,
					'me/followers': formatFriends,
					'me/share': function(o) {
						formatError(o);
						paging(o);
						if (o.values) {
							o.data = o.values.map(formatUser);
							o.data.forEach(function(item) {
								item.message = item.headline;
							});

							delete o.values;
						}

						return o;
					},

					'default': function(o, headers) {
						formatError(o);
						empty(o, headers);
						paging(o);
					}
				},

				jsonp: function(p, qs) {
					formatQuery(qs);
					if (p.method === 'get') {
						qs.format = 'jsonp';
						qs['error-callback'] = p.callbackID;
					}
				},

				xhr: function(p, qs) {
					if (p.method !== 'get') {
						formatQuery(qs);
						p.headers['Content-Type'] = 'application/json';

						// Note: x-li-format ensures error responses are not returned in XML
						p.headers['x-li-format'] = 'json';
						p.proxy = true;
						return true;
					}

					return false;
				}
			}
		});

		function formatError(o) {
			if (o && 'errorCode' in o) {
				o.error = {
					code: o.status,
					message: o.message
				};
			}
		}

		function formatUser(o) {
			if (o.error) {
				return;
			}

			o.first_name = o.firstName;
			o.last_name = o.lastName;
			o.name = o.formattedName || (o.first_name + ' ' + o.last_name);
			o.thumbnail = o.pictureUrl;
			o.email = o.emailAddress;
			return o;
		}

		function formatFriends(o) {
			formatError(o);
			paging(o);
			if (o.values) {
				o.data = o.values.map(formatUser);
				delete o.values;
			}

			return o;
		}

		function paging(res) {
			if ('_count' in res && '_start' in res && (res._count + res._start) < res._total) {
				res.paging = {
					next: '?start=' + (res._start + res._count) + '&count=' + res._count
				};
			}
		}

		function empty(o, headers) {
			if (JSON.stringify(o) === '{}' && headers.statusCode === 200) {
				o.success = true;
			}
		}

		function formatQuery(qs) {
			// LinkedIn signs requests with the parameter 'oauth2_access_token'
			// ... yeah another one who thinks they should be different!
			if (qs.access_token) {
				qs.oauth2_access_token = qs.access_token;
				delete qs.access_token;
			}
		}

		function like(p, callback) {
			p.headers['x-li-format'] = 'json';
			var id = p.data.id;
			p.data = (p.method !== 'delete').toString();
			p.method = 'put';
			callback('people/~/network/updates/key=' + id + '/is-liked');
		}

	})(hello);

	// See: https://developers.soundcloud.com/docs/api/reference
	(function(hello) {

		hello.init({

			soundcloud: {
				name: 'SoundCloud',

				oauth: {
					version: 2,
					auth: 'https://soundcloud.com/connect',
					grant: 'https://soundcloud.com/oauth2/token'
				},

				// Request path translated
				base: 'https://api.soundcloud.com/',
				get: {
					me: 'me.json',

					// Http://developers.soundcloud.com/docs/api/reference#me
					'me/friends': 'me/followings.json',
					'me/followers': 'me/followers.json',
					'me/following': 'me/followings.json',

					// See: http://developers.soundcloud.com/docs/api/reference#activities
					'default': function(p, callback) {

						// Include '.json at the end of each request'
						callback(p.path + '.json');
					}
				},

				// Response handlers
				wrap: {
					me: function(o) {
						formatUser(o);
						return o;
					},

					'default': function(o) {
						if (Array.isArray(o)) {
							o = {
								data: o.map(formatUser)
							};
						}

						paging(o);
						return o;
					}
				},

				xhr: formatRequest,
				jsonp: formatRequest
			}
		});

		function formatRequest(p, qs) {
			// Alter the querystring
			var token = qs.access_token;
			delete qs.access_token;
			qs.oauth_token = token;
			qs['_status_code_map[302]'] = 200;
			return true;
		}

		function formatUser(o) {
			if (o.id) {
				o.picture = o.avatar_url;
				o.thumbnail = o.avatar_url;
				o.name = o.username || o.full_name;
			}

			return o;
		}

		// See: http://developers.soundcloud.com/docs/api/reference#activities
		function paging(res) {
			if ('next_href' in res) {
				res.paging = {
					next: res.next_href
				};
			}
		}

	})(hello);

	(function(hello) {

		var base = 'https://api.twitter.com/';

		hello.init({

			twitter: {

				// Ensure that you define an oauth_proxy
				oauth: {
					version: '1.0a',
					auth: base + 'oauth/authenticate',
					request: base + 'oauth/request_token',
					token: base + 'oauth/access_token'
				},

				login: function(p) {
					// Reauthenticate
					// https://dev.twitter.com/oauth/reference/get/oauth/authenticate
					var prefix = '?force_login=true';
					this.oauth.auth = this.oauth.auth.replace(prefix, '') + (p.options.force ? prefix : '');
				},

				base: base + '1.1/',

				get: {
					me: 'account/verify_credentials.json',
					'me/friends': 'friends/list.json?count=@{limit|200}',
					'me/following': 'friends/list.json?count=@{limit|200}',
					'me/followers': 'followers/list.json?count=@{limit|200}',

					// Https://dev.twitter.com/docs/api/1.1/get/statuses/user_timeline
					'me/share': 'statuses/user_timeline.json?count=@{limit|200}',

					// Https://dev.twitter.com/rest/reference/get/favorites/list
					'me/like': 'favorites/list.json?count=@{limit|200}'
				},

				post: {
					'me/share': function(p, callback) {

						var data = p.data;
						p.data = null;

						var status = [];

						// Change message to status
						if (data.message) {
							status.push(data.message);
							delete data.message;
						}

						// If link is given
						if (data.link) {
							status.push(data.link);
							delete data.link;
						}

						if (data.picture) {
							status.push(data.picture);
							delete data.picture;
						}

						// Compound all the components
						if (status.length) {
							data.status = status.join(' ');
						}

						// Tweet media
						if (data.file) {
							data['media[]'] = data.file;
							delete data.file;
							p.data = data;
							callback('statuses/update_with_media.json');
						}

						// Retweet?
						else if ('id' in data) {
							callback('statuses/retweet/' + data.id + '.json');
						}

						// Tweet
						else {
							// Assign the post body to the query parameters
							hello.utils.extend(p.query, data);
							callback('statuses/update.json?include_entities=1');
						}
					},

					// See: https://dev.twitter.com/rest/reference/post/favorites/create
					'me/like': function(p, callback) {
						var id = p.data.id;
						p.data = null;
						callback('favorites/create.json?id=' + id);
					}
				},

				del: {

					// See: https://dev.twitter.com/rest/reference/post/favorites/destroy
					'me/like': function() {
						p.method = 'post';
						var id = p.data.id;
						p.data = null;
						callback('favorites/destroy.json?id=' + id);
					}
				},

				wrap: {
					me: function(res) {
						formatError(res);
						formatUser(res);
						return res;
					},

					'me/friends': formatFriends,
					'me/followers': formatFriends,
					'me/following': formatFriends,

					'me/share': function(res) {
						formatError(res);
						paging(res);
						if (!res.error && 'length' in res) {
							return {data: res};
						}

						return res;
					},

					'default': function(res) {
						res = arrayToDataResponse(res);
						paging(res);
						return res;
					}
				},
				xhr: function(p) {

					// Rely on the proxy for non-GET requests.
					return (p.method !== 'get');
				}
			}
		});

		function formatUser(o) {
			if (o.id) {
				if (o.name) {
					var m = o.name.split(' ');
					o.first_name = m.shift();
					o.last_name = m.join(' ');
				}

				// See: https://dev.twitter.com/overview/general/user-profile-images-and-banners
				o.thumbnail = o.profile_image_url_https || o.profile_image_url;
			}

			return o;
		}

		function formatFriends(o) {
			formatError(o);
			paging(o);
			if (o.users) {
				o.data = o.users.map(formatUser);
				delete o.users;
			}

			return o;
		}

		function formatError(o) {
			if (o.errors) {
				var e = o.errors[0];
				o.error = {
					code: 'request_failed',
					message: e.message
				};
			}
		}

		// Take a cursor and add it to the path
		function paging(res) {
			// Does the response include a 'next_cursor_string'
			if ('next_cursor_str' in res) {
				// See: https://dev.twitter.com/docs/misc/cursoring
				res.paging = {
					next: '?cursor=' + res.next_cursor_str
				};
			}
		}

		function arrayToDataResponse(res) {
			return Array.isArray(res) ? {data: res} : res;
		}

		/**
		// The documentation says to define user in the request
		// Although its not actually required.

		var user_id;

		function withUserId(callback){
			if(user_id){
				callback(user_id);
			}
			else{
				hello.api('twitter:/me', function(o){
					user_id = o.id;
					callback(o.id);
				});
			}
		}

		function sign(url){
			return function(p, callback){
				withUserId(function(user_id){
					callback(url+'?user_id='+user_id);
				});
			};
		}
		*/

	})(hello);

	// Vkontakte (vk.com)
	(function(hello) {

		hello.init({

			vk: {
				name: 'Vk',

				// See https://vk.com/dev/oauth_dialog
				oauth: {
					version: 2,
					auth: 'https://oauth.vk.com/authorize',
					grant: 'https://oauth.vk.com/access_token'
				},

				// Authorization scopes
				// See https://vk.com/dev/permissions
				scope: {
					email: 'email',
					friends: 'friends',
					photos: 'photos',
					videos: 'video',
					share: 'share',
					offline_access: 'offline'
				},

				// Refresh the access_token
				refresh: true,

				login: function(p) {
					p.qs.display = window.navigator &&
						window.navigator.userAgent &&
						/ipad|phone|phone|android/.test(window.navigator.userAgent.toLowerCase()) ? 'mobile' : 'popup';
				},

				// API Base URL
				base: 'https://api.vk.com/method/',

				// Map GET requests
				get: {
					me: function(p, callback) {
						p.query.fields = 'id,first_name,last_name,photo_max';
						callback('users.get');
					}
				},

				wrap: {
					me: function(res, headers, req) {
						formatError(res);
						return formatUser(res, req);
					}
				},

				// No XHR
				xhr: false,

				// All requests should be JSONP as of missing CORS headers in https://api.vk.com/method/*
				jsonp: true,

				// No form
				form: false
			}
		});

		function formatUser(o, req) {

			if (o !== null && 'response' in o && o.response !== null && o.response.length) {
				o = o.response[0];
				o.id = o.uid;
				o.thumbnail = o.picture = o.photo_max;
				o.name = o.first_name + ' ' + o.last_name;

				if (req.authResponse && req.authResponse.email !== null)
					o.email = req.authResponse.email;
			}

			return o;
		}

		function formatError(o) {

			if (o.error) {
				var e = o.error;
				o.error = {
					code: e.error_code,
					message: e.error_msg
				};
			}
		}

	})(hello);

	(function(hello) {

		hello.init({
			windows: {
				name: 'Windows live',

				// REF: http://msdn.microsoft.com/en-us/library/hh243641.aspx
				oauth: {
					version: 2,
					auth: 'https://login.live.com/oauth20_authorize.srf',
					grant: 'https://login.live.com/oauth20_token.srf'
				},

				// Refresh the access_token once expired
				refresh: true,

				logout: function() {
					return 'http://login.live.com/oauth20_logout.srf?ts=' + (new Date()).getTime();
				},

				// Authorization scopes
				scope: {
					basic: 'wl.signin,wl.basic',
					email: 'wl.emails',
					birthday: 'wl.birthday',
					events: 'wl.calendars',
					photos: 'wl.photos',
					videos: 'wl.photos',
					friends: 'wl.contacts_emails',
					files: 'wl.skydrive',
					publish: 'wl.share',
					publish_files: 'wl.skydrive_update',
					share: 'wl.share',
					create_event: 'wl.calendars_update,wl.events_create',
					offline_access: 'wl.offline_access'
				},

				// API base URL
				base: 'https://apis.live.net/v5.0/',

				// Map GET requests
				get: {

					// Friends
					me: 'me',
					'me/friends': 'me/friends',
					'me/following': 'me/contacts',
					'me/followers': 'me/friends',
					'me/contacts': 'me/contacts',

					'me/albums': 'me/albums',

					// Include the data[id] in the path
					'me/album': '@{id}/files',
					'me/photo': '@{id}',

					// Files
					'me/files': '@{parent|me/skydrive}/files',
					'me/folders': '@{id|me/skydrive}/files',
					'me/folder': '@{id|me/skydrive}/files'
				},

				// Map POST requests
				post: {
					'me/albums': 'me/albums',
					'me/album': '@{id}/files/',

					'me/folders': '@{id|me/skydrive/}',
					'me/files': '@{parent|me/skydrive}/files'
				},

				// Map DELETE requests
				del: {
					// Include the data[id] in the path
					'me/album': '@{id}',
					'me/photo': '@{id}',
					'me/folder': '@{id}',
					'me/files': '@{id}'
				},

				wrap: {
					me: formatUser,

					'me/friends': formatFriends,
					'me/contacts': formatFriends,
					'me/followers': formatFriends,
					'me/following': formatFriends,
					'me/albums': formatAlbums,
					'me/photos': formatDefault,
					'default': formatDefault
				},

				xhr: function(p) {
					if (p.method !== 'get' && p.method !== 'delete' && !hello.utils.hasBinary(p.data)) {

						// Does this have a data-uri to upload as a file?
						if (typeof (p.data.file) === 'string') {
							p.data.file = hello.utils.toBlob(p.data.file);
						}
						else {
							p.data = JSON.stringify(p.data);
							p.headers = {
								'Content-Type': 'application/json'
							};
						}
					}

					return true;
				},

				jsonp: function(p) {
					if (p.method !== 'get' && !hello.utils.hasBinary(p.data)) {
						p.data.method = p.method;
						p.method = 'get';
					}
				}
			}
		});

		function formatDefault(o) {
			if ('data' in o) {
				o.data.forEach(function(d) {
					if (d.picture) {
						d.thumbnail = d.picture;
					}

					if (d.images) {
						d.pictures = d.images
							.map(formatImage)
							.sort(function(a, b) {
								return a.width - b.width;
							});
					}
				});
			}

			return o;
		}

		function formatImage(image) {
			return {
				width: image.width,
				height: image.height,
				source: image.source
			};
		}

		function formatAlbums(o) {
			if ('data' in o) {
				o.data.forEach(function(d) {
					d.photos = d.files = 'https://apis.live.net/v5.0/' + d.id + '/photos';
				});
			}

			return o;
		}

		function formatUser(o, headers, req) {
			if (o.id) {
				var token = req.query.access_token;
				if (o.emails) {
					o.email = o.emails.preferred;
				}

				// If this is not an non-network friend
				if (o.is_friend !== false) {
					// Use the id of the user_id if available
					var id = (o.user_id || o.id);
					o.thumbnail = o.picture = 'https://apis.live.net/v5.0/' + id + '/picture?access_token=' + token;
				}
			}

			return o;
		}

		function formatFriends(o, headers, req) {
			if ('data' in o) {
				o.data.forEach(function(d) {
					formatUser(d, headers, req);
				});
			}

			return o;
		}

	})(hello);

	(function(hello) {

		hello.init({

			yahoo: {

				// Ensure that you define an oauth_proxy
				oauth: {
					version: '1.0a',
					auth: 'https://api.login.yahoo.com/oauth/v2/request_auth',
					request: 'https://api.login.yahoo.com/oauth/v2/get_request_token',
					token: 'https://api.login.yahoo.com/oauth/v2/get_token'
				},

				// Login handler
				login: function(p) {
					// Change the default popup window to be at least 560
					// Yahoo does dynamically change it on the fly for the signin screen (only, what if your already signed in)
					p.options.popup.width = 560;

					// Yahoo throws an parameter error if for whatever reason the state.scope contains a comma, so lets remove scope
					try {delete p.qs.state.scope;}
					catch (e) {}
				},

				base: 'https://social.yahooapis.com/v1/',

				get: {
					me: yql('select * from social.profile(0) where guid=me'),
					'me/friends': yql('select * from social.contacts(0) where guid=me'),
					'me/following': yql('select * from social.contacts(0) where guid=me')
				},
				wrap: {
					me: formatUser,

					// Can't get IDs
					// It might be better to loop through the social.relationship table with has unique IDs of users.
					'me/friends': formatFriends,
					'me/following': formatFriends,
					'default': paging
				}
			}
		});

		/*
			// Auto-refresh fix: bug in Yahoo can't get this to work with node-oauth-shim
			login : function(o){
				// Is the user already logged in
				var auth = hello('yahoo').getAuthResponse();

				// Is this a refresh token?
				if(o.options.display==='none'&&auth&&auth.access_token&&auth.refresh_token){
					// Add the old token and the refresh token, including path to the query
					// See http://developer.yahoo.com/oauth/guide/oauth-refreshaccesstoken.html
					o.qs.access_token = auth.access_token;
					o.qs.refresh_token = auth.refresh_token;
					o.qs.token_url = 'https://api.login.yahoo.com/oauth/v2/get_token';
				}
			},
		*/

		function formatError(o) {
			if (o && 'meta' in o && 'error_type' in o.meta) {
				o.error = {
					code: o.meta.error_type,
					message: o.meta.error_message
				};
			}
		}

		function formatUser(o) {

			formatError(o);
			if (o.query && o.query.results && o.query.results.profile) {
				o = o.query.results.profile;
				o.id = o.guid;
				o.last_name = o.familyName;
				o.first_name = o.givenName || o.nickname;
				var a = [];
				if (o.first_name) {
					a.push(o.first_name);
				}

				if (o.last_name) {
					a.push(o.last_name);
				}

				o.name = a.join(' ');
				o.email = (o.emails && o.emails[0]) ? o.emails[0].handle : null;
				o.thumbnail = o.image ? o.image.imageUrl : null;
			}

			return o;
		}

		function formatFriends(o, headers, request) {
			formatError(o);
			paging(o, headers, request);
			var contact;
			var field;
			if (o.query && o.query.results && o.query.results.contact) {
				o.data = o.query.results.contact;
				delete o.query;

				if (!Array.isArray(o.data)) {
					o.data = [o.data];
				}

				o.data.forEach(formatFriend);
			}

			return o;
		}

		function formatFriend(contact) {
			contact.id = null;

			// #362: Reports of responses returning a single item, rather than an Array of items.
			// Format the contact.fields to be an array.
			if (contact.fields && !(contact.fields instanceof Array)) {
				contact.fields = [contact.fields];
			}

			(contact.fields || []).forEach(function(field) {
				if (field.type === 'email') {
					contact.email = field.value;
				}

				if (field.type === 'name') {
					contact.first_name = field.value.givenName;
					contact.last_name = field.value.familyName;
					contact.name = field.value.givenName + ' ' + field.value.familyName;
				}

				if (field.type === 'yahooid') {
					contact.id = field.value;
				}
			});
		}

		function paging(res, headers, request) {

			// See: http://developer.yahoo.com/yql/guide/paging.html#local_limits
			if (res.query && res.query.count && request.options) {
				res.paging = {
					next: '?start=' + (res.query.count + (+request.options.start || 1))
				};
			}

			return res;
		}

		function yql(q) {
			return 'https://query.yahooapis.com/v1/yql?q=' + (q + ' limit @{limit|100} offset @{start|0}').replace(/\s/g, '%20') + '&format=json';
		}

	})(hello);

	// Register as anonymous AMD module
	if (true) {
		!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
			return hello;
		}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}

	// CommonJS module for browserify
	if (typeof module === 'object' && module.exports) {
		module.exports = hello;
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4), __webpack_require__(416).setImmediate, __webpack_require__(2)))

/***/ },
/* 416 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(setImmediate, clearImmediate) {var nextTick = __webpack_require__(4).nextTick;
	var apply = Function.prototype.apply;
	var slice = Array.prototype.slice;
	var immediateIds = {};
	var nextImmediateId = 0;

	// DOM APIs, for completeness

	exports.setTimeout = function() {
	  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
	};
	exports.setInterval = function() {
	  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
	};
	exports.clearTimeout =
	exports.clearInterval = function(timeout) { timeout.close(); };

	function Timeout(id, clearFn) {
	  this._id = id;
	  this._clearFn = clearFn;
	}
	Timeout.prototype.unref = Timeout.prototype.ref = function() {};
	Timeout.prototype.close = function() {
	  this._clearFn.call(window, this._id);
	};

	// Does not start the time, just sets up the members needed.
	exports.enroll = function(item, msecs) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = msecs;
	};

	exports.unenroll = function(item) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = -1;
	};

	exports._unrefActive = exports.active = function(item) {
	  clearTimeout(item._idleTimeoutId);

	  var msecs = item._idleTimeout;
	  if (msecs >= 0) {
	    item._idleTimeoutId = setTimeout(function onTimeout() {
	      if (item._onTimeout)
	        item._onTimeout();
	    }, msecs);
	  }
	};

	// That's not how node.js implements it but the exposed api is the same.
	exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
	  var id = nextImmediateId++;
	  var args = arguments.length < 2 ? false : slice.call(arguments, 1);

	  immediateIds[id] = true;

	  nextTick(function onNextTick() {
	    if (immediateIds[id]) {
	      // fn.call() is faster so we optimize for the common use-case
	      // @see http://jsperf.com/call-apply-segu
	      if (args) {
	        fn.apply(null, args);
	      } else {
	        fn.call(null);
	      }
	      // Prevent ids from leaking
	      exports.clearImmediate(id);
	    }
	  });

	  return id;
	};

	exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
	  delete immediateIds[id];
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(416).setImmediate, __webpack_require__(416).clearImmediate))

/***/ },
/* 417 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Google = undefined;

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _social = __webpack_require__(414);

	var _enums = __webpack_require__(412);

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * @private
	 */
	var Google = exports.Google = function (_Social) {
	  _inherits(Google, _Social);

	  function Google() {
	    _classCallCheck(this, Google);

	    return _possibleConstructorReturn(this, (Google.__proto__ || Object.getPrototypeOf(Google)).apply(this, arguments));
	  }

	  _createClass(Google, [{
	    key: 'identity',
	    get: function get() {
	      return _enums.SocialIdentity.Google;
	    }
	  }], [{
	    key: 'identity',
	    get: function get() {
	      return _enums.SocialIdentity.Google;
	    }
	  }]);

	  return Google;
	}(_social.Social);

/***/ },
/* 418 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.LinkedIn = undefined;

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _social = __webpack_require__(414);

	var _enums = __webpack_require__(412);

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * @private
	 */
	var LinkedIn = exports.LinkedIn = function (_Social) {
	  _inherits(LinkedIn, _Social);

	  function LinkedIn() {
	    _classCallCheck(this, LinkedIn);

	    return _possibleConstructorReturn(this, (LinkedIn.__proto__ || Object.getPrototypeOf(LinkedIn)).apply(this, arguments));
	  }

	  _createClass(LinkedIn, [{
	    key: 'identity',
	    get: function get() {
	      return _enums.SocialIdentity.LinkedIn;
	    }
	  }], [{
	    key: 'identity',
	    get: function get() {
	      return _enums.SocialIdentity.LinkedIn;
	    }
	  }]);

	  return LinkedIn;
	}(_social.Social);

/***/ },
/* 419 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.MobileIdentityConnect = exports.AuthorizationGrant = undefined;

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _social = __webpack_require__(414);

	var _enums = __webpack_require__(412);

	var _request = __webpack_require__(219);

	var _errors = __webpack_require__(11);

	var _utils = __webpack_require__(13);

	var _promise = __webpack_require__(286);

	var _promise2 = _interopRequireDefault(_promise);

	var _regeneratorRuntime = __webpack_require__(148);

	var _regeneratorRuntime2 = _interopRequireDefault(_regeneratorRuntime);

	var _path = __webpack_require__(420);

	var _path2 = _interopRequireDefault(_path);

	var _url = __webpack_require__(206);

	var _url2 = _interopRequireDefault(_url);

	var _isString = __webpack_require__(217);

	var _isString2 = _interopRequireDefault(_isString);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new _promise2.default(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return _promise2.default.resolve(value).then(function (value) { return step("next", value); }, function (err) { return step("throw", err); }); } } return step("next"); }); }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // eslint-disable-line no-unused-vars


	var authPathname = process && process.env && process.env.KINVEY_MIC_AUTH_PATHNAME || '/oauth/auth' || '/oauth/auth';
	var tokenPathname = process && process.env && process.env.KINVEY_MIC_TOKEN_PATHNAME || '/oauth/token' || '/oauth/token';
	var invalidatePathname = process && process.env && process.env.KINVEY_MIC_INVALIDATE_PATHNAME || '/oauth/invalidate' || '/oauth/invalidate';

	/**
	 * Enum for Mobile Identity Connect authorization grants.
	 * @property  {string}    AuthorizationCodeLoginPage   AuthorizationCodeLoginPage grant
	 * @property  {string}    AuthorizationCodeAPI         AuthorizationCodeAPI grant
	 */
	var AuthorizationGrant = {
	  AuthorizationCodeLoginPage: 'AuthorizationCodeLoginPage',
	  AuthorizationCodeAPI: 'AuthorizationCodeAPI'
	};
	Object.freeze(AuthorizationGrant);
	exports.AuthorizationGrant = AuthorizationGrant;

	/**
	 * @private
	 */

	var MobileIdentityConnect = exports.MobileIdentityConnect = function (_Social) {
	  _inherits(MobileIdentityConnect, _Social);

	  function MobileIdentityConnect() {
	    _classCallCheck(this, MobileIdentityConnect);

	    return _possibleConstructorReturn(this, (MobileIdentityConnect.__proto__ || Object.getPrototypeOf(MobileIdentityConnect)).apply(this, arguments));
	  }

	  _createClass(MobileIdentityConnect, [{
	    key: 'login',
	    value: function login(redirectUri) {
	      var _this2 = this;

	      var authorizationGrant = arguments.length <= 1 || arguments[1] === undefined ? AuthorizationGrant.AuthorizationCodeLoginPage : arguments[1];
	      var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

	      var clientId = this.client.appKey;

	      var promise = _promise2.default.resolve().then(function () {
	        if (authorizationGrant === AuthorizationGrant.AuthorizationCodeLoginPage) {
	          // Step 1: Request a code
	          return _this2.requestCodeWithPopup(clientId, redirectUri, options);
	        } else if (authorizationGrant === AuthorizationGrant.AuthorizationCodeAPI) {
	          // Step 1a: Request a temp login url
	          return _this2.requestTempLoginUrl(clientId, redirectUri, options).then(function (url) {
	            return _this2.requestCodeWithUrl(url, clientId, redirectUri, options);
	          }); // Step 1b: Request a code
	        }

	        throw new _errors.KinveyError('The authorization grant ' + authorizationGrant + ' is unsupported. ' + 'Please use a supported authorization grant.');
	      }).then(function (code) {
	        return _this2.requestToken(code, clientId, redirectUri, options);
	      }) // Step 3: Request a token
	      .then(function (session) {
	        session.client_id = clientId;
	        session.redirect_uri = redirectUri;
	        session.protocol = _this2.client.micProtocol;
	        session.host = _this2.client.micHost;
	        return session;
	      });

	      return promise;
	    }
	  }, {
	    key: 'requestTempLoginUrl',
	    value: function requestTempLoginUrl(clientId, redirectUri) {
	      var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

	      var pathname = '/';

	      if (options.version) {
	        var version = options.version;

	        if (!(0, _isString2.default)(version)) {
	          version = String(version);
	        }

	        pathname = _path2.default.join(pathname, version.indexOf('v') === 0 ? version : 'v' + version);
	      }

	      var request = new _request.KinveyRequest({
	        method: _request.RequestMethod.POST,
	        headers: {
	          'Content-Type': 'application/x-www-form-urlencoded'
	        },
	        url: _url2.default.format({
	          protocol: this.client.micProtocol,
	          host: this.client.micHost,
	          pathname: _path2.default.join(pathname, authPathname)
	        }),
	        properties: options.properties,
	        body: {
	          client_id: clientId,
	          redirect_uri: redirectUri,
	          response_type: 'code'
	        }
	      });
	      return request.execute().then(function (response) {
	        return response.data.temp_login_uri;
	      });
	    }
	  }, {
	    key: 'requestCodeWithPopup',
	    value: function requestCodeWithPopup(clientId, redirectUri) {
	      var _this3 = this;

	      var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

	      var promise = _promise2.default.resolve().then(function () {
	        var pathname = '/';

	        if (options.version) {
	          var version = options.version;

	          if (!(0, _isString2.default)(version)) {
	            version = String(version);
	          }

	          pathname = _path2.default.join(pathname, version.indexOf('v') === 0 ? version : 'v' + version);
	        }

	        if (_utils.Popup) {
	          var popup = new _utils.Popup();
	          return popup.open(_url2.default.format({
	            protocol: _this3.client.micProtocol,
	            host: _this3.client.micHost,
	            pathname: _path2.default.join(pathname, authPathname),
	            query: {
	              client_id: clientId,
	              redirect_uri: redirectUri,
	              response_type: 'code'
	            }
	          }));
	        }

	        throw new _errors.KinveyError('Popup is undefined.' + (' Unable to login using authorization grant ' + AuthorizationGrant.AuthorizationCodeLoginPage + '.'));
	      }).then(function (popup) {
	        var promise = new _promise2.default(function (resolve, reject) {
	          var redirected = false;

	          function loadCallback(event) {
	            try {
	              if (event.url && event.url.indexOf(redirectUri) === 0 && redirected === false) {
	                redirected = true;
	                popup.removeAllListeners();
	                popup.close();
	                resolve(_url2.default.parse(event.url, true).query.code);
	              }
	            } catch (error) {
	              // Just catch the error
	            }
	          }

	          function errorCallback(event) {
	            try {
	              if (event.url && event.url.indexOf(redirectUri) === 0 && redirected === false) {
	                redirected = true;
	                popup.removeAllListeners();
	                popup.close();
	                resolve(_url2.default.parse(event.url, true).query.code);
	              } else if (redirected === false) {
	                popup.removeAllListeners();
	                popup.close();
	                reject(new _errors.KinveyError(event.message, '', event.code));
	              }
	            } catch (error) {
	              // Just catch the error
	            }
	          }

	          function closedCallback() {
	            if (redirected === false) {
	              popup.removeAllListeners();
	              reject(new _errors.KinveyError('Login has been cancelled.'));
	            }
	          }

	          popup.on('loadstart', loadCallback);
	          popup.on('loadstop', loadCallback);
	          popup.on('error', errorCallback);
	          popup.on('closed', closedCallback);
	        });
	        return promise;
	      });

	      return promise;
	    }
	  }, {
	    key: 'requestCodeWithUrl',
	    value: function requestCodeWithUrl(loginUrl, clientId, redirectUri) {
	      var options = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];

	      var promise = _promise2.default.resolve().then(function () {
	        var request = new _request.KinveyRequest({
	          method: _request.RequestMethod.POST,
	          headers: {
	            'Content-Type': 'application/x-www-form-urlencoded'
	          },
	          url: loginUrl,
	          properties: options.properties,
	          body: {
	            client_id: clientId,
	            redirect_uri: redirectUri,
	            response_type: 'code',
	            username: options.username,
	            password: options.password
	          },
	          followRedirect: false
	        });
	        return request.execute();
	      }).then(function (response) {
	        var location = response.getHeader('location');

	        if (location) {
	          return _url2.default.parse(location, true).query.code;
	        }

	        throw new _errors.KinveyError('Unable to authorize user with username ' + options.username + '.', 'A location header was not provided with a code to exchange for an auth token.');
	      });

	      return promise;
	    }
	  }, {
	    key: 'requestToken',
	    value: function requestToken(code, clientId, redirectUri) {
	      var options = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];

	      var request = new _request.KinveyRequest({
	        method: _request.RequestMethod.POST,
	        headers: {
	          'Content-Type': 'application/x-www-form-urlencoded'
	        },
	        authType: _request.AuthType.App,
	        url: _url2.default.format({
	          protocol: this.client.micProtocol,
	          host: this.client.micHost,
	          pathname: tokenPathname
	        }),
	        properties: options.properties,
	        body: {
	          grant_type: 'authorization_code',
	          client_id: clientId,
	          redirect_uri: redirectUri,
	          code: code
	        }
	      });
	      var promise = request.execute().then(function (response) {
	        return response.data;
	      });
	      return promise;
	    }
	  }, {
	    key: 'logout',
	    value: function () {
	      var _ref = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee(user) {
	        var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
	        var request, response;
	        return _regeneratorRuntime2.default.wrap(function _callee$(_context) {
	          while (1) {
	            switch (_context.prev = _context.next) {
	              case 0:
	                request = new _request.KinveyRequest({
	                  method: _request.RequestMethod.GET,
	                  headers: {
	                    'Content-Type': 'application/x-www-form-urlencoded'
	                  },
	                  authType: _request.AuthType.App,
	                  url: _url2.default.format({
	                    protocol: this.client.micProtocol,
	                    host: this.client.micHost,
	                    pathname: invalidatePathname,
	                    query: { user: user._id }
	                  }),
	                  properties: options.properties
	                });
	                _context.next = 3;
	                return request.execute();

	              case 3:
	                response = _context.sent;
	                return _context.abrupt('return', response.data);

	              case 5:
	              case 'end':
	                return _context.stop();
	            }
	          }
	        }, _callee, this);
	      }));

	      function logout(_x7, _x8) {
	        return _ref.apply(this, arguments);
	      }

	      return logout;
	    }()
	  }, {
	    key: 'identity',
	    get: function get() {
	      return _enums.SocialIdentity.MobileIdentityConnect;
	    }
	  }], [{
	    key: 'identity',
	    get: function get() {
	      return _enums.SocialIdentity.MobileIdentityConnect;
	    }
	  }]);

	  return MobileIdentityConnect;
	}(_social.Social);
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 420 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	// resolves . and .. elements in a path array with directory names there
	// must be no slashes, empty elements, or device names (c:\) in the array
	// (so also no leading and trailing slashes - it does not distinguish
	// relative and absolute paths)
	function normalizeArray(parts, allowAboveRoot) {
	  // if the path tries to go above the root, `up` ends up > 0
	  var up = 0;
	  for (var i = parts.length - 1; i >= 0; i--) {
	    var last = parts[i];
	    if (last === '.') {
	      parts.splice(i, 1);
	    } else if (last === '..') {
	      parts.splice(i, 1);
	      up++;
	    } else if (up) {
	      parts.splice(i, 1);
	      up--;
	    }
	  }

	  // if the path is allowed to go above the root, restore leading ..s
	  if (allowAboveRoot) {
	    for (; up--; up) {
	      parts.unshift('..');
	    }
	  }

	  return parts;
	}

	// Split a filename into [root, dir, basename, ext], unix version
	// 'root' is just a slash, or nothing.
	var splitPathRe =
	    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
	var splitPath = function(filename) {
	  return splitPathRe.exec(filename).slice(1);
	};

	// path.resolve([from ...], to)
	// posix version
	exports.resolve = function() {
	  var resolvedPath = '',
	      resolvedAbsolute = false;

	  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
	    var path = (i >= 0) ? arguments[i] : process.cwd();

	    // Skip empty and invalid entries
	    if (typeof path !== 'string') {
	      throw new TypeError('Arguments to path.resolve must be strings');
	    } else if (!path) {
	      continue;
	    }

	    resolvedPath = path + '/' + resolvedPath;
	    resolvedAbsolute = path.charAt(0) === '/';
	  }

	  // At this point the path should be resolved to a full absolute path, but
	  // handle relative paths to be safe (might happen when process.cwd() fails)

	  // Normalize the path
	  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
	    return !!p;
	  }), !resolvedAbsolute).join('/');

	  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
	};

	// path.normalize(path)
	// posix version
	exports.normalize = function(path) {
	  var isAbsolute = exports.isAbsolute(path),
	      trailingSlash = substr(path, -1) === '/';

	  // Normalize the path
	  path = normalizeArray(filter(path.split('/'), function(p) {
	    return !!p;
	  }), !isAbsolute).join('/');

	  if (!path && !isAbsolute) {
	    path = '.';
	  }
	  if (path && trailingSlash) {
	    path += '/';
	  }

	  return (isAbsolute ? '/' : '') + path;
	};

	// posix version
	exports.isAbsolute = function(path) {
	  return path.charAt(0) === '/';
	};

	// posix version
	exports.join = function() {
	  var paths = Array.prototype.slice.call(arguments, 0);
	  return exports.normalize(filter(paths, function(p, index) {
	    if (typeof p !== 'string') {
	      throw new TypeError('Arguments to path.join must be strings');
	    }
	    return p;
	  }).join('/'));
	};


	// path.relative(from, to)
	// posix version
	exports.relative = function(from, to) {
	  from = exports.resolve(from).substr(1);
	  to = exports.resolve(to).substr(1);

	  function trim(arr) {
	    var start = 0;
	    for (; start < arr.length; start++) {
	      if (arr[start] !== '') break;
	    }

	    var end = arr.length - 1;
	    for (; end >= 0; end--) {
	      if (arr[end] !== '') break;
	    }

	    if (start > end) return [];
	    return arr.slice(start, end - start + 1);
	  }

	  var fromParts = trim(from.split('/'));
	  var toParts = trim(to.split('/'));

	  var length = Math.min(fromParts.length, toParts.length);
	  var samePartsLength = length;
	  for (var i = 0; i < length; i++) {
	    if (fromParts[i] !== toParts[i]) {
	      samePartsLength = i;
	      break;
	    }
	  }

	  var outputParts = [];
	  for (var i = samePartsLength; i < fromParts.length; i++) {
	    outputParts.push('..');
	  }

	  outputParts = outputParts.concat(toParts.slice(samePartsLength));

	  return outputParts.join('/');
	};

	exports.sep = '/';
	exports.delimiter = ':';

	exports.dirname = function(path) {
	  var result = splitPath(path),
	      root = result[0],
	      dir = result[1];

	  if (!root && !dir) {
	    // No dirname whatsoever
	    return '.';
	  }

	  if (dir) {
	    // It has a dirname, strip trailing slash
	    dir = dir.substr(0, dir.length - 1);
	  }

	  return root + dir;
	};


	exports.basename = function(path, ext) {
	  var f = splitPath(path)[2];
	  // TODO: make this comparison case-insensitive on windows?
	  if (ext && f.substr(-1 * ext.length) === ext) {
	    f = f.substr(0, f.length - ext.length);
	  }
	  return f;
	};


	exports.extname = function(path) {
	  return splitPath(path)[3];
	};

	function filter (xs, f) {
	    if (xs.filter) return xs.filter(f);
	    var res = [];
	    for (var i = 0; i < xs.length; i++) {
	        if (f(xs[i], i, xs)) res.push(xs[i]);
	    }
	    return res;
	}

	// String.prototype.substr - negative index don't work in IE8
	var substr = 'ab'.substr(-1) === 'b'
	    ? function (str, start, len) { return str.substr(start, len) }
	    : function (str, start, len) {
	        if (start < 0) start = str.length + start;
	        return str.substr(start, len);
	    }
	;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 421 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Windows = undefined;

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _social = __webpack_require__(414);

	var _enums = __webpack_require__(412);

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * @private
	 */
	var Windows = exports.Windows = function (_Social) {
	  _inherits(Windows, _Social);

	  function Windows() {
	    _classCallCheck(this, Windows);

	    return _possibleConstructorReturn(this, (Windows.__proto__ || Object.getPrototypeOf(Windows)).apply(this, arguments));
	  }

	  _createClass(Windows, [{
	    key: 'identity',
	    get: function get() {
	      return _enums.SocialIdentity.Windows;
	    }
	  }], [{
	    key: 'identity',
	    get: function get() {
	      return _enums.SocialIdentity.Windows;
	    }
	  }]);

	  return Windows;
	}(_social.Social);

/***/ },
/* 422 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Query = undefined;

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _errors = __webpack_require__(11);

	var _utils = __webpack_require__(13);

	var _sift = __webpack_require__(423);

	var _sift2 = _interopRequireDefault(_sift);

	var _assign = __webpack_require__(211);

	var _assign2 = _interopRequireDefault(_assign);

	var _isArray = __webpack_require__(35);

	var _isArray2 = _interopRequireDefault(_isArray);

	var _isNumber = __webpack_require__(232);

	var _isNumber2 = _interopRequireDefault(_isNumber);

	var _isString = __webpack_require__(217);

	var _isString2 = _interopRequireDefault(_isString);

	var _isObject = __webpack_require__(32);

	var _isObject2 = _interopRequireDefault(_isObject);

	var _isRegExp = __webpack_require__(424);

	var _isRegExp2 = _interopRequireDefault(_isRegExp);

	var _isEmpty = __webpack_require__(359);

	var _isEmpty2 = _interopRequireDefault(_isEmpty);

	var _forEach = __webpack_require__(19);

	var _forEach2 = _interopRequireDefault(_forEach);

	var _findKey = __webpack_require__(426);

	var _findKey2 = _interopRequireDefault(_findKey);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var unsupportedFilters = ['$nearSphere'];

	/**
	 * The Query class is used to query for a subset of
	 * entities using the Kinvey API.
	 *
	 * @example
	 * var query = new Kinvey.Query();
	 * query.equalTo('name', 'Kinvey');
	 */

	var Query = function () {
	  /**
	   * Create an instance of the Query class.
	   *
	   * @param {Object} options Options
	   * @param {string[]} [options.fields=[]] Fields to select.
	   * @param {Object} [options.filter={}] MongoDB query.
	   * @param {Object} [options.sort={}] The sorting order.
	   * @param {?number} [options.limit=null] Number of entities to select.
	   * @param {number} [options.skip=0] Number of entities to skip from the start.
	   * @return {Query} The query.
	   */
	  function Query(options) {
	    _classCallCheck(this, Query);

	    options = (0, _assign2.default)({
	      fields: [],
	      filter: {},
	      sort: {},
	      limit: null,
	      skip: 0
	    }, options);

	    /**
	     * Fields to select.
	     *
	     * @type {string[]}
	     */
	    this.fields = options.fields;

	    /**
	     * The MongoDB query.
	     *
	     * @type {Object}
	     */
	    this.filter = options.filter;

	    /**
	     * The sorting order.
	     *
	     * @type {Object}
	     */
	    this.sort = options.sort;

	    /**
	     * Number of entities to select.
	     *
	     * @type {?number}
	     */
	    this.limit = options.limit;

	    /**
	     * Number of entities to skip from the start.
	     *
	     * @type {number}
	     */
	    this.skip = options.skip;

	    /**
	     * Maintain reference to the parent query in case the query is part of a
	     * join.
	     *
	     * @type {?Query}
	     */
	    this._parent = null;
	  }

	  /**
	   * @type {string[]}
	   */


	  _createClass(Query, [{
	    key: 'isSupportedOffline',


	    /**
	     * Checks if the query is able to be run offline on the local cache.
	     * @return {Boolean} True if it is able to be run offline otherwise false.
	     */
	    value: function isSupportedOffline() {
	      var _this = this;

	      var supported = true;

	      (0, _forEach2.default)(unsupportedFilters, function (filter) {
	        supported = !(0, _findKey2.default)(_this.filter, filter);
	        return supported;
	      });

	      return supported;
	    }

	    /**
	     * Adds an equal to filter to the query. Requires `field` to equal `value`.
	     * Any existing filters on `field` will be discarded.
	     * @see https://docs.mongodb.com/manual/reference/operator/query/#comparison
	     *
	     * @param {string} field Field
	     * @param {*} value Value
	     * @returns {Query} The query.
	     */

	  }, {
	    key: 'equalTo',
	    value: function equalTo(field, value) {
	      return this.addFilter(field, value);
	    }

	    /**
	     * Adds a contains filter to the query. Requires `field` to contain at least
	     * one of the members of `list`.
	     * @see https://docs.mongodb.com/manual/reference/operator/query/in
	     *
	     * @param {string} field Field
	     * @param {array} values List of values.
	     * @throws {QueryError} `values` must be of type `Array`.
	     * @returns {Query} The query.
	     */

	  }, {
	    key: 'contains',
	    value: function contains(field, values) {
	      if (!(0, _isArray2.default)(values)) {
	        values = [values];
	      }

	      return this.addFilter(field, '$in', values);
	    }

	    /**
	     * Adds a contains all filter to the query. Requires `field` to contain all
	     * members of `list`.
	     * @see https://docs.mongodb.com/manual/reference/operator/query/all
	     *
	     * @param {string} field Field
	     * @param {Array} values List of values.
	     * @throws {QueryError} `values` must be of type `Array`.
	     * @returns {Query} The query.
	     */

	  }, {
	    key: 'containsAll',
	    value: function containsAll(field, values) {
	      if (!(0, _isArray2.default)(values)) {
	        values = [values];
	      }

	      return this.addFilter(field, '$all', values);
	    }

	    /**
	     * Adds a greater than filter to the query. Requires `field` to be greater
	     * than `value`.
	     * @see https://docs.mongodb.com/manual/reference/operator/query/gt
	     *
	     * @param {string} field Field
	     * @param {number|string} value Value
	     * @throws {QueryError} `value` must be of type `number` or `string`.
	     * @returns {Query} The query.
	     */

	  }, {
	    key: 'greaterThan',
	    value: function greaterThan(field, value) {
	      if (!(0, _isNumber2.default)(value) && !(0, _isString2.default)(value)) {
	        throw new _errors.QueryError('You must supply a number or string.');
	      }

	      return this.addFilter(field, '$gt', value);
	    }

	    /**
	     * Adds a greater than or equal to filter to the query. Requires `field` to
	     * be greater than or equal to `value`.
	     * @see https://docs.mongodb.com/manual/reference/operator/query/gte
	     *
	     * @param {string} field Field.
	     * @param {number|string} value Value.
	     * @throws {QueryError} `value` must be of type `number` or `string`.
	     * @returns {Query} The query.
	     */

	  }, {
	    key: 'greaterThanOrEqualTo',
	    value: function greaterThanOrEqualTo(field, value) {
	      if (!(0, _isNumber2.default)(value) && !(0, _isString2.default)(value)) {
	        throw new _errors.QueryError('You must supply a number or string.');
	      }

	      return this.addFilter(field, '$gte', value);
	    }

	    /**
	     * Adds a less than filter to the query. Requires `field` to be less than
	     * `value`.
	     * @see https://docs.mongodb.com/manual/reference/operator/query/lt
	     *
	     * @param {string} field Field
	     * @param {number|string} value Value
	     * @throws {QueryError} `value` must be of type `number` or `string`.
	     * @returns {Query} The query.
	     */

	  }, {
	    key: 'lessThan',
	    value: function lessThan(field, value) {
	      if (!(0, _isNumber2.default)(value) && !(0, _isString2.default)(value)) {
	        throw new _errors.QueryError('You must supply a number or string.');
	      }

	      return this.addFilter(field, '$lt', value);
	    }

	    /**
	     * Adds a less than or equal to filter to the query. Requires `field` to be
	     * less than or equal to `value`.
	     * @see https://docs.mongodb.com/manual/reference/operator/query/lte
	     *
	     * @param {string} field Field
	     * @param {number|string} value Value
	     * @throws {QueryError} `value` must be of type `number` or `string`.
	     * @returns {Query} The query.
	     */

	  }, {
	    key: 'lessThanOrEqualTo',
	    value: function lessThanOrEqualTo(field, value) {
	      if (!(0, _isNumber2.default)(value) && !(0, _isString2.default)(value)) {
	        throw new _errors.QueryError('You must supply a number or string.');
	      }

	      return this.addFilter(field, '$lte', value);
	    }

	    /**
	     * Adds a not equal to filter to the query. Requires `field` not to equal
	     * `value`.
	     * @see https://docs.mongodb.com/manual/reference/operator/query/ne
	     *
	     * @param {string} field Field
	     * @param {*} value Value
	     * @returns {Query} The query.
	     */

	  }, {
	    key: 'notEqualTo',
	    value: function notEqualTo(field, value) {
	      return this.addFilter(field, '$ne', value);
	    }

	    /**
	     * Adds a not contained in filter to the query. Requires `field` not to
	     * contain any of the members of `list`.
	     * @see https://docs.mongodb.com/manual/reference/operator/query/nin
	     *
	     * @param {string} field Field
	     * @param {Array} values List of values.
	     * @throws {QueryError} `values` must be of type `Array`.
	     * @returns {Query} The query.
	     */

	  }, {
	    key: 'notContainedIn',
	    value: function notContainedIn(field, values) {
	      if (!(0, _isArray2.default)(values)) {
	        values = [values];
	      }

	      return this.addFilter(field, '$nin', values);
	    }

	    /**
	     * Performs a logical AND operation on the query and the provided queries.
	     * @see https://docs.mongodb.com/manual/reference/operator/query/and
	     *
	     * @param {...Query|...Object} args Queries
	     * @throws {QueryError} `query` must be of type `Array<Query>` or `Array<Object>`.
	     * @returns {Query} The query.
	     */

	  }, {
	    key: 'and',
	    value: function and() {
	      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	        args[_key] = arguments[_key];
	      }

	      // AND has highest precedence. Therefore, even if this query is part of a
	      // JOIN already, apply it on this query.
	      return this.join('$and', args);
	    }

	    /**
	     * Performs a logical NOR operation on the query and the provided queries.
	     * @see https://docs.mongodb.com/manual/reference/operator/query/nor
	     *
	     * @param {...Query|...Object} args Queries
	     * @throws {QueryError} `query` must be of type `Array<Query>` or `Array<Object>`.
	     * @returns {Query} The query.
	     */

	  }, {
	    key: 'nor',
	    value: function nor() {
	      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
	        args[_key2] = arguments[_key2];
	      }

	      // NOR is preceded by AND. Therefore, if this query is part of an AND-join,
	      // apply the NOR onto the parent to make sure AND indeed precedes NOR.
	      if (this._parent && this._parent.filter.$and) {
	        var _parent;

	        return (_parent = this._parent).nor.apply(_parent, args);
	      }

	      return this.join('$nor', args);
	    }

	    /**
	     * Performs a logical OR operation on the query and the provided queries.
	     * @see https://docs.mongodb.com/manual/reference/operator/query/or
	     *
	     * @param {...Query|...Object} args Queries.
	     * @throws {QueryError} `query` must be of type `Array<Query>` or `Array<Object>`.
	     * @returns {Query} The query.
	     */

	  }, {
	    key: 'or',
	    value: function or() {
	      for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
	        args[_key3] = arguments[_key3];
	      }

	      // OR has lowest precedence. Therefore, if this query is part of any join,
	      // apply the OR onto the parent to make sure OR has indeed the lowest
	      // precedence.
	      if (this._parent) {
	        var _parent2;

	        return (_parent2 = this._parent).or.apply(_parent2, args);
	      }

	      return this.join('$or', args);
	    }

	    /**
	     * Adds an exists filter to the query. Requires `field` to exist if `flag` is
	     * `true`, or not to exist if `flag` is `false`.
	     * @see https://docs.mongodb.com/manual/reference/operator/query/exists
	     *
	     * @param {string} field Field
	     * @param {boolean} [flag=true] The exists flag.
	     * @returns {Query} The query.
	     */

	  }, {
	    key: 'exists',
	    value: function exists(field, flag) {
	      flag = typeof flag === 'undefined' ? true : flag || false;
	      return this.addFilter(field, '$exists', flag);
	    }

	    /**
	     * Adds a modulus filter to the query. Requires `field` modulo `divisor` to
	     * have remainder `remainder`.
	     * @see https://docs.mongodb.com/manual/reference/operator/query/mod
	     *
	     * @param {string} field Field
	     * @param {number} divisor Divisor
	     * @param {number} [remainder=0] Remainder
	     * @throws {QueryError} `divisor` must be of type: `number`.
	     * @throws {QueryError} `remainder` must be of type: `number`.
	     * @returns {Query} The query.
	     */

	  }, {
	    key: 'mod',
	    value: function mod(field, divisor) {
	      var remainder = arguments.length <= 2 || arguments[2] === undefined ? 0 : arguments[2];

	      if ((0, _isString2.default)(divisor)) {
	        divisor = parseFloat(divisor);
	      }

	      if ((0, _isString2.default)(remainder)) {
	        remainder = parseFloat(remainder);
	      }

	      if (!(0, _isNumber2.default)(divisor)) {
	        throw new _errors.QueryError('divisor must be a number');
	      }

	      if (!(0, _isNumber2.default)(remainder)) {
	        throw new _errors.QueryError('remainder must be a number');
	      }

	      return this.addFilter(field, '$mod', [divisor, remainder]);
	    }

	    /**
	     * Adds a match filter to the query. Requires `field` to match `regExp`.
	     * @see https://docs.mongodb.com/manual/reference/operator/query/regex
	     *
	     * @param {string} field Field
	     * @param {RegExp|string} regExp Regular expression.
	     * @param {Object} [options] Options
	     * @param {boolean} [options.ignoreCase=inherit] Toggles case-insensitivity.
	     * @param {boolean} [options.multiline=inherit] Toggles multiline matching.
	     * @param {boolean} [options.extended=false] Toggles extended capability.
	     * @param {boolean} [options.dotMatchesAll=false] Toggles dot matches all.
	     * @returns {Query} The query.
	     */

	  }, {
	    key: 'matches',
	    value: function matches(field, regExp) {
	      var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

	      if (!(0, _isRegExp2.default)(regExp)) {
	        regExp = new RegExp(regExp);
	      }

	      if ((regExp.ignoreCase || options.ignoreCase) && options.ignoreCase !== false) {
	        throw new _errors.QueryError('ignoreCase glag is not supported.');
	      }

	      if (regExp.source.indexOf('^') !== 0) {
	        throw new _errors.QueryError('regExp must have `^` at the beginning of the expression ' + 'to make it an anchored expression.');
	      }

	      var flags = [];

	      if ((regExp.multiline || options.multiline) && options.multiline !== false) {
	        flags.push('m');
	      }

	      if (options.extended) {
	        flags.push('x');
	      }

	      if (options.dotMatchesAll) {
	        flags.push('s');
	      }

	      var result = this.addFilter(field, '$regex', regExp.source);

	      if (flags.length) {
	        this.addFilter(field, '$options', flags.join(''));
	      }

	      return result;
	    }

	    /**
	     * Adds a near filter to the query. Requires `field` to be a coordinate
	     * within `maxDistance` of `coord`. Sorts documents from nearest to farthest.
	     * @see https://docs.mongodb.com/manual/reference/operator/query/near
	     *
	     * @param {string} field The field.
	     * @param {Array<number, number>} coord The coordinate (longitude, latitude).
	     * @param {number} [maxDistance] The maximum distance (miles).
	     * @throws {QueryError} `coord` must be of type `Array<number, number>`.
	     * @returns {Query} The query.
	     */

	  }, {
	    key: 'near',
	    value: function near(field, coord, maxDistance) {
	      if (!(0, _isArray2.default)(coord) || !(0, _isNumber2.default)(coord[0]) || !(0, _isNumber2.default)(coord[1])) {
	        throw new _errors.QueryError('coord must be a [number, number]');
	      }

	      var result = this.addFilter(field, '$nearSphere', [coord[0], coord[1]]);

	      if (maxDistance) {
	        this.addFilter(field, '$maxDistance', maxDistance);
	      }

	      return result;
	    }

	    /**
	     * Adds a within box filter to the query. Requires `field` to be a coordinate
	     * within the bounds of the rectangle defined by `bottomLeftCoord`,
	     * `bottomRightCoord`.
	     * @see https://docs.mongodb.com/manual/reference/operator/query/box
	     *
	     * @param {string} field The field.
	     * @param {Array<number, number>} bottomLeftCoord The bottom left coordinate (longitude, latitude).
	     * @param {Array<number, number>} upperRightCoord The bottom right coordinate (longitude, latitude).
	     * @throws {QueryError} `bottomLeftCoord` must be of type `Array<number, number>`.
	     * @throws {QueryError} `bottomRightCoord` must be of type `Array<number, number>`.
	     * @returns {Query} The query.
	     */

	  }, {
	    key: 'withinBox',
	    value: function withinBox(field, bottomLeftCoord, upperRightCoord) {
	      if (!(0, _isArray2.default)(bottomLeftCoord) || !bottomLeftCoord[0] || !bottomLeftCoord[1]) {
	        throw new _errors.QueryError('bottomLeftCoord must be a [number, number]');
	      }

	      if (!(0, _isArray2.default)(upperRightCoord) || !upperRightCoord[0] || !upperRightCoord[1]) {
	        throw new _errors.QueryError('upperRightCoord must be a [number, number]');
	      }

	      bottomLeftCoord[0] = parseFloat(bottomLeftCoord[0]);
	      bottomLeftCoord[1] = parseFloat(bottomLeftCoord[1]);
	      upperRightCoord[0] = parseFloat(upperRightCoord[0]);
	      upperRightCoord[1] = parseFloat(upperRightCoord[1]);

	      var coords = [[bottomLeftCoord[0], bottomLeftCoord[1]], [upperRightCoord[0], upperRightCoord[1]]];
	      return this.addFilter(field, '$within', { $box: coords });
	    }

	    /**
	     * Adds a within polygon filter to the query. Requires `field` to be a
	     * coordinate within the bounds of the polygon defined by `coords`.
	     * @see https://docs.mongodb.com/manual/reference/operator/query/polygon
	     *
	     * @param {string} field The field.
	     * @param {Array<Array<number, number>>} coords List of coordinates.
	     * @throws {QueryError} `coords` must be of type `Array<Array<number, number>>`.
	     * @returns {Query} The query.
	     */

	  }, {
	    key: 'withinPolygon',
	    value: function withinPolygon(field, coords) {
	      if (!(0, _isArray2.default)(coords) || coords.length > 3) {
	        throw new _errors.QueryError('coords must be [[number, number]]');
	      }

	      coords = coords.map(function (coord) {
	        if (!coord[0] || !coord[1]) {
	          throw new _errors.QueryError('coords argument must be [number, number]');
	        }

	        return [parseFloat(coord[0]), parseFloat(coord[1])];
	      });

	      return this.addFilter(field, '$within', { $polygon: coords });
	    }

	    /**
	     * Adds a size filter to the query. Requires `field` to be an `Array` with
	     * exactly `size` members.
	     * @see https://docs.mongodb.com/manual/reference/operator/query/size
	     *
	     * @param {string} field Field
	     * @param {number} size Size
	     * @throws {QueryError} `size` must be of type: `number`.
	     * @returns {Query} The query.
	     */

	  }, {
	    key: 'size',
	    value: function size(field, _size) {
	      if ((0, _isString2.default)(_size)) {
	        _size = parseFloat(_size);
	      }

	      if (!(0, _isNumber2.default)(_size)) {
	        throw new _errors.QueryError('size must be a number');
	      }

	      return this.addFilter(field, '$size', _size);
	    }

	    /**
	     * Adds an ascending sort modifier to the query. Sorts by `field`, ascending.
	     *
	     * @param {string} field Field
	     * @returns {Query} The query.
	     */

	  }, {
	    key: 'ascending',
	    value: function ascending(field) {
	      if (this._parent) {
	        this._parent.ascending(field);
	      } else {
	        this.sort[field] = 1;
	      }

	      return this;
	    }

	    /**
	     * Adds an descending sort modifier to the query. Sorts by `field`,
	     * descending.
	     *
	     * @param {string} field Field
	     * @returns {Query} The query.
	     */

	  }, {
	    key: 'descending',
	    value: function descending(field) {
	      if (this._parent) {
	        this._parent.descending(field);
	      } else {
	        this.sort[field] = -1;
	      }

	      return this;
	    }

	    /**
	     * Adds a filter to the query.
	     *
	     * @param {string} field Field
	     * @param {string} condition Condition
	     * @param {*} values Values
	     * @returns {Query} The query.
	     */

	  }, {
	    key: 'addFilter',
	    value: function addFilter(field, condition, values) {
	      if (!(0, _isObject2.default)(this.filter[field])) {
	        this.filter[field] = {};
	      }

	      if (condition && values) {
	        this.filter[field][condition] = values;
	      } else {
	        this.filter[field] = condition;
	      }

	      return this;
	    }

	    /**
	     * @private
	     * Joins the current query with another query using an operator.
	     *
	     * @param {string} operator Operator
	     * @param {Query[]|Object[]} queries Queries
	     * @throws {QueryError} `query` must be of type `Query[]` or `Object[]`.
	     * @returns {Query} The query.
	     */

	  }, {
	    key: 'join',
	    value: function join(operator, queries) {
	      var _this2 = this;

	      var that = this;
	      var currentQuery = {};

	      // Cast, validate, and parse arguments. If `queries` are supplied, obtain
	      // the `filter` for joining. The eventual return function will be the
	      // current query.
	      queries = queries.map(function (query) {
	        if (!(query instanceof Query)) {
	          if ((0, _isObject2.default)(query)) {
	            query = new Query(query);
	          } else {
	            throw new _errors.QueryError('query argument must be of type: Kinvey.Query[] or Object[].');
	          }
	        }

	        return query.toJSON().filter;
	      });

	      // If there are no `queries` supplied, create a new (empty) `Query`.
	      // This query is the right-hand side of the join expression, and will be
	      // returned to allow for a fluent interface.
	      if (queries.length === 0) {
	        that = new Query();
	        queries = [that.toJSON().filter];
	        that.parent = this; // Required for operator precedence and `toJSON`.
	      }

	      // Join operators operate on the top-level of `filter`. Since the `toJSON`
	      // magic requires `filter` to be passed by reference, we cannot simply re-
	      // assign `filter`. Instead, empty it without losing the reference.
	      var members = Object.keys(this.filter);
	      (0, _forEach2.default)(members, function (member) {
	        currentQuery[member] = _this2.filter[member];
	        delete _this2.filter[member];
	      });

	      // `currentQuery` is the left-hand side query. Join with `queries`.
	      this.filter[operator] = [currentQuery].concat(queries);

	      // Return the current query if there are `queries`, and the new (empty)
	      // `PrivateQuery` otherwise.
	      return that;
	    }

	    /**
	     * @private
	     * Processes the data by applying fields, sort, limit, and skip.
	     *
	     * @param {Array} data The raw data.
	     * @throws {QueryError} `data` must be of type `Array`.
	     * @returns {Array} The processed data.
	     */

	  }, {
	    key: 'process',
	    value: function process(data) {
	      var _this3 = this;

	      if (this.isSupportedOffline() === false) {
	        (function () {
	          var message = 'This query is not able to run locally. The following filters are not supported' + ' locally:';

	          (0, _forEach2.default)(unsupportedFilters, function (filter) {
	            message = message + ' ' + filter;
	          });

	          throw new _errors.QueryError(message);
	        })();
	      }

	      if (data) {
	        var _ret2 = function () {
	          // Validate arguments.
	          if (!(0, _isArray2.default)(data)) {
	            throw new _errors.QueryError('data argument must be of type: Array.');
	          }

	          // Apply the query
	          var json = _this3.toJSON();
	          data = (0, _sift2.default)(json.filter, data);

	          // Remove fields
	          if (json.fields && json.fields.length > 0) {
	            data = data.map(function (item) {
	              var keys = Object.keys(item);
	              (0, _forEach2.default)(keys, function (key) {
	                if (json.fields.indexOf(key) === -1) {
	                  delete item[key];
	                }
	              });

	              return item;
	            });
	          }

	          // Sorting.
	          data = data.sort(function (a, b) {
	            var fields = Object.keys(json.sort);
	            (0, _forEach2.default)(fields, function (field) {
	              // Find field in objects.
	              var aField = (0, _utils.nested)(a, field);
	              var bField = (0, _utils.nested)(b, field);

	              // Elements which do not contain the field should always be sorted
	              // lower.
	              if (aField && !bField) {
	                return -1;
	              }

	              if (bField && !aField) {
	                return 1;
	              }

	              // Sort on the current field. The modifier adjusts the sorting order
	              // (ascending (-1), or descending(1)). If the fields are equal,
	              // continue sorting based on the next field (if any).
	              if (aField !== bField) {
	                var modifier = json.sort[field]; // 1 or -1.
	                return (aField < bField ? -1 : 1) * modifier;
	              }

	              return 0;
	            });

	            return 0;
	          });

	          // Limit and skip.
	          if (json.limit) {
	            return {
	              v: data.slice(json.skip, json.skip + json.limit)
	            };
	          }

	          return {
	            v: data.slice(json.skip)
	          };
	        }();

	        if ((typeof _ret2 === 'undefined' ? 'undefined' : _typeof(_ret2)) === "object") return _ret2.v;
	      }

	      return data;
	    }

	    /**
	     * Returns Object representation of the query.
	     *
	     * @returns {Object} Object
	     */

	  }, {
	    key: 'toPlainObject',
	    value: function toPlainObject() {
	      if (this._parent) {
	        return this._parent.toPlainObject();
	      }

	      // Return set of parameters.
	      var json = {
	        fields: this.fields,
	        filter: this.filter,
	        sort: this.sort,
	        skip: this.skip,
	        limit: this.limit
	      };

	      return json;
	    }

	    /**
	     * Returns Object representation of the query.
	     *
	     * @returns {Object} Object
	     * @deprecated Use toPlainObject() instead.
	     */

	  }, {
	    key: 'toJSON',
	    value: function toJSON() {
	      return this.toPlainObject();
	    }

	    /**
	     * Returns query string representation of the query.
	     *
	     * @returns {Object} Query string object.
	     */

	  }, {
	    key: 'toQueryString',
	    value: function toQueryString() {
	      var queryString = {};

	      if (!(0, _isEmpty2.default)(this.filter)) {
	        queryString.query = this.filter;
	      }

	      if (!(0, _isEmpty2.default)(this.fields)) {
	        queryString.fields = this.fields.join(',');
	      }

	      if (this.limit) {
	        queryString.limit = this.limit;
	      }

	      if (this.skip > 0) {
	        queryString.skip = this.skip;
	      }

	      if (!(0, _isEmpty2.default)(this.sort)) {
	        queryString.sort = this.sort;
	      }

	      var keys = Object.keys(queryString);
	      (0, _forEach2.default)(keys, function (key) {
	        queryString[key] = (0, _isString2.default)(queryString[key]) ? queryString[key] : JSON.stringify(queryString[key]);
	      });

	      return queryString;
	    }

	    /**
	     * Returns query string representation of the query.
	     *
	     * @return {string} Query string string.
	     */

	  }, {
	    key: 'toString',
	    value: function toString() {
	      return JSON.stringify(this.toQueryString());
	    }
	  }, {
	    key: 'fields',
	    get: function get() {
	      return this._fields;
	    }

	    /**
	     * @type {string[]}
	     */
	    ,
	    set: function set(fields) {
	      fields = fields || [];

	      if (!(0, _isArray2.default)(fields)) {
	        throw new _errors.QueryError('fields must be an Array');
	      }

	      if (this._parent) {
	        this._parent.fields = fields;
	      } else {
	        this._fields = fields;
	      }
	    }

	    /**
	     * @type {Object}
	     */

	  }, {
	    key: 'filter',
	    get: function get() {
	      return this._filter;
	    }

	    /**
	     * @type {Object}
	     */
	    ,
	    set: function set(filter) {
	      this._filter = filter;
	    }

	    /**
	     * @type {Object}
	     */

	  }, {
	    key: 'sort',
	    get: function get() {
	      return this._sort;
	    }

	    /**
	     * @type {Object}
	     */
	    ,
	    set: function set(sort) {
	      if (sort && !(0, _isObject2.default)(sort)) {
	        throw new _errors.QueryError('sort must an Object');
	      }

	      if (this._parent) {
	        this._parent.sort(sort);
	      } else {
	        this._sort = sort || {};
	      }
	    }

	    /**
	     * @type {?number}
	     */

	  }, {
	    key: 'limit',
	    get: function get() {
	      return this._limit;
	    }

	    /**
	     * @type {?number}
	     */
	    ,
	    set: function set(limit) {
	      if ((0, _isString2.default)(limit)) {
	        limit = parseFloat(limit);
	      }

	      if (limit && !(0, _isNumber2.default)(limit)) {
	        throw new _errors.QueryError('limit must be a number');
	      }

	      if (this._parent) {
	        this._parent.limit = limit;
	      } else {
	        this._limit = limit;
	      }
	    }

	    /**
	     * @type {number}
	     */

	  }, {
	    key: 'skip',
	    get: function get() {
	      return this._skip;
	    }

	    /**
	     * @type {number}
	     */
	    ,
	    set: function set() {
	      var skip = arguments.length <= 0 || arguments[0] === undefined ? 0 : arguments[0];

	      if ((0, _isString2.default)(skip)) {
	        skip = parseFloat(skip);
	      }

	      if (!(0, _isNumber2.default)(skip)) {
	        throw new _errors.QueryError('skip must be a number');
	      }

	      if (this._parent) {
	        this._parent.skip(skip);
	      } else {
	        this._skip = skip;
	      }
	    }
	  }]);

	  return Query;
	}();

	exports.Query = Query;

/***/ },
/* 423 */
/***/ function(module, exports) {

	/*
	 * Sift 3.x
	 *
	 * Copryright 2015, Craig Condon
	 * Licensed under MIT
	 *
	 * Filter JavaScript objects with mongodb queries
	 */

	(function() {

	  'use strict';

	  /**
	   */

	  function isFunction(value) {
	    return typeof value === 'function';
	  }

	  /**
	   */

	  function isArray(value) {
	    return Object.prototype.toString.call(value) === '[object Array]';
	  }

	  /**
	   */

	  function comparable(value) {
	    if (value instanceof Date) {
	      return value.getTime();
	    } else if (value instanceof Array) {
	      return value.map(comparable);
	    } else {
	      return value;
	    }
	  }

	  function get(obj, key) {
	    if (obj.get) return obj.get(key);
	    return obj[key];
	  }

	  /**
	   */

	  function or(validator) {
	    return function(a, b) {
	      if (!isArray(b) || !b.length) return validator(a, b);
	      for (var i = 0, n = b.length; i < n; i++) if (validator(a, get(b,i))) return true;
	      return false;
	    }
	  }

	  /**
	   */

	  function and(validator) {
	    return function(a, b) {
	      if (!isArray(b) || !b.length) return validator(a, b);
	      for (var i = 0, n = b.length; i < n; i++) if (!validator(a, get(b, i))) return false;
	      return true;
	    };
	  }

	  function validate(validator, b) {
	    return validator.v(validator.a, b);
	  }


	  var operator = {

	    /**
	     */

	    $eq: or(function(a, b) {
	      return a(b);
	    }),

	    /**
	     */

	    $ne: and(function(a, b) {
	      return !a(b);
	    }),

	    /**
	     */

	    $or: function(a, b) {
	      for (var i = 0, n = a.length; i < n; i++) if (validate(get(a, i), b)) return true;
	      return false;
	    },

	    /**
	     */

	    $gt: or(function(a, b) {
	      return sift.compare(comparable(b), a) > 0;
	    }),

	    /**
	     */

	    $gte: or(function(a, b) {
	      return sift.compare(comparable(b), a) >= 0;
	    }),

	    /**
	     */

	    $lt: or(function(a, b) {
	      return sift.compare(comparable(b), a) < 0;
	    }),

	    /**
	     */

	    $lte: or(function(a, b) {
	      return sift.compare(comparable(b), a) <= 0;
	    }),

	    /**
	     */

	    $mod: or(function(a, b) {
	      return b % a[0] == a[1];
	    }),

	    /**
	     */

	    $in: function(a, b) {

	      if (b instanceof Array) {
	        for (var i = b.length; i--;) {
	          if (~a.indexOf(comparable(get(b, i)))) return true;
	        }
	      } else {
	        return !!~a.indexOf(comparable(b));
	      }

	      return false;
	    },

	    /**
	     */

	    $nin: function(a, b) {
	      return !operator.$in(a, b);
	    },

	    /**
	     */

	    $not: function(a, b) {
	      return !validate(a, b);
	    },

	    /**
	     */

	    $type: function(a, b) {
	      return b != void 0 ? b instanceof a || b.constructor == a : false;
	     },

	    /**
	     */

	    $all: function(a, b) {
	      if (!b) b = [];
	      for (var i = a.length; i--;) {
	        if (!~comparable(b).indexOf(get(a, i))) return false;
	      }
	      return true;
	    },

	    /**
	     */

	    $size: function(a, b) {
	      return b ? a === b.length : false;
	    },

	    /**
	     */

	    $nor: function(a, b) {
	      // todo - this suffice? return !operator.$in(a)
	      for (var i = 0, n = a.length; i < n; i++) if (validate(get(a, i), b)) return false;
	      return true;
	    },

	    /**
	     */

	    $and: function(a, b) {
	      for (var i = 0, n = a.length; i < n; i++) if (!validate(get(a, i), b)) return false;
	      return true;
	    },

	    /**
	     */

	    $regex: or(function(a, b) {
	      return typeof b === 'string' && a.test(b);
	    }),

	    /**
	     */

	    $where: function(a, b) {
	      return a.call(b, b);
	    },

	    /**
	     */

	    $elemMatch: function(a, b) {
	      if (isArray(b)) return !!~search(b, a);
	      return validate(a, b);
	    },

	    /**
	     */

	    $exists: function(a, b) {
	      return (b != void 0) === a;
	    }
	  };

	  /**
	   */

	  var prepare = {

	    /**
	     */

	    $eq: function(a) {

	      if (a instanceof RegExp) {
	        return function(b) {
	          return typeof b === 'string' && a.test(b);
	        };
	      } else if (a instanceof Function) {
	        return a;
	      } else if (isArray(a) && !a.length) {
	        // Special case of a == []
	        return function(b) {
	          return (isArray(b) && !b.length);
	        };
	      } else if (a === null){
	        return function(b){
	          //will match both null and undefined
	          return b == null;
	        }
	      }

	      return function(b) {
	        return sift.compare(comparable(b), a) === 0;
	      };
	    },

	    /**
	     */

	    $ne: function(a) {
	      return prepare.$eq(a);
	    },

	    /**
	     */

	    $and: function(a) {
	      return a.map(parse);
	    },

	    /**
	     */

	    $or: function(a) {
	      return a.map(parse);
	    },

	    /**
	     */

	    $nor: function(a) {
	      return a.map(parse);
	    },

	    /**
	     */

	    $not: function(a) {
	      return parse(a);
	    },

	    /**
	     */

	    $regex: function(a, query) {
	      return new RegExp(a, query.$options);
	    },

	    /**
	     */

	    $where: function(a) {
	      return typeof a === 'string' ? new Function('obj', 'return ' + a) : a;
	    },

	    /**
	     */

	    $elemMatch: function(a) {
	      return parse(a);
	    },

	    /**
	     */

	    $exists: function(a) {
	      return !!a;
	    }
	  };

	  /**
	   */

	  function search(array, validator) {

	    for (var i = 0; i < array.length; i++) {
	      if (validate(validator, get(array, i))) {
	        return i;
	      }
	    }

	    return -1;
	  }

	  /**
	   */

	  function createValidator(a, validate) {
	    return { a: a, v: validate };
	  }

	  /**
	   */

	  function nestedValidator(a, b) {
	    var values  = [];
	    findValues(b, a.k, 0, values);

	    if (values.length === 1) {
	      return validate(a.nv, values[0]);
	    }

	    return !!~search(values, a.nv);
	  }

	  /**
	   */

	  function findValues(current, keypath, index, values) {

	    if (index === keypath.length || current == void 0) {
	      values.push(current);
	      return;
	    }

	    var k = get(keypath, index);

	    // ensure that if current is an array, that the current key
	    // is NOT an array index. This sort of thing needs to work:
	    // sift({'foo.0':42}, [{foo: [42]}]);
	    if (isArray(current) && isNaN(Number(k))) {
	      for (var i = 0, n = current.length; i < n; i++) {
	        findValues(get(current, i), keypath, index, values);
	      }
	    } else {
	      findValues(get(current, k), keypath, index + 1, values);
	    }
	  }

	  /**
	   */

	  function createNestedValidator(keypath, a) {
	    return { a: { k: keypath, nv: a }, v: nestedValidator };
	  }

	  /**
	   * flatten the query
	   */

	  function parse(query) {
	    query = comparable(query);

	    if (!query || (query.constructor.toString() !== 'Object' &&
	        query.constructor.toString().replace(/\n/g,'').replace(/ /g, '') !== 'functionObject(){[nativecode]}')) { // cross browser support
	      query = { $eq: query };
	    }

	    var validators = [];

	    for (var key in query) {
	      var a = query[key];

	      if (key === '$options') continue;

	      if (operator[key]) {
	        if (prepare[key]) a = prepare[key](a, query);
	        validators.push(createValidator(comparable(a), operator[key]));
	      } else {

	        if (key.charCodeAt(0) === 36) {
	          throw new Error('Unknown operation ' + key);
	        }

	        validators.push(createNestedValidator(key.split('.'), parse(a)));
	      }
	    }

	    return validators.length === 1 ? validators[0] : createValidator(validators, operator.$and);
	  }

	  /**
	   */

	  function createRootValidator(query, getter) {
	    var validator = parse(query);
	    if (getter) {
	      validator = {
	        a: validator,
	        v: function(a, b) {
	          return validate(a, getter(b));
	        }
	      };
	    }
	    return validator;
	  }

	  /**
	   */

	  function sift(query, array, getter) {

	    if (isFunction(array)) {
	      getter = array;
	      array  = void 0;
	    }

	    var validator = createRootValidator(query, getter);

	    function filter(b) {
	      return validate(validator, b);
	    }

	    if (array) {
	      return array.filter(filter);
	    }

	    return filter;
	  }

	  /**
	   */

	  sift.use = function(plugin) {
	    if (isFunction(plugin)) return plugin(sift);
	    for (var key in plugin) {
	      if (key.charCodeAt(0) === 36) operator[key] = plugin[key];
	    }
	  };

	  /**
	   */

	  sift.indexOf = function(query, array, getter) {
	    return search(array, createRootValidator(query, getter));
	  };

	  /**
	   */

	  sift.compare = function(a, b) {
	    if(a===b) return 0;
	    if(typeof a === typeof b) {
	      if (a > b) return 1;
	      if (a < b) return -1;
	    }
	  };

	  /* istanbul ignore next */
	  if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {
	    module.exports = sift;
	  }

	  if (typeof window !== 'undefined') {
	    window.sift = sift;
	  }
	})();


/***/ },
/* 424 */
/***/ function(module, exports, __webpack_require__) {

	var baseIsRegExp = __webpack_require__(425),
	    baseUnary = __webpack_require__(105),
	    nodeUtil = __webpack_require__(106);

	/* Node.js helper references. */
	var nodeIsRegExp = nodeUtil && nodeUtil.isRegExp;

	/**
	 * Checks if `value` is classified as a `RegExp` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
	 * @example
	 *
	 * _.isRegExp(/abc/);
	 * // => true
	 *
	 * _.isRegExp('/abc/');
	 * // => false
	 */
	var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;

	module.exports = isRegExp;


/***/ },
/* 425 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(32);

	/** `Object#toString` result references. */
	var regexpTag = '[object RegExp]';

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objectToString = objectProto.toString;

	/**
	 * The base implementation of `_.isRegExp` without Node.js optimizations.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
	 */
	function baseIsRegExp(value) {
	  return isObject(value) && objectToString.call(value) == regexpTag;
	}

	module.exports = baseIsRegExp;


/***/ },
/* 426 */
/***/ function(module, exports, __webpack_require__) {

	var baseFindKey = __webpack_require__(427),
	    baseForOwn = __webpack_require__(22),
	    baseIteratee = __webpack_require__(42);

	/**
	 * This method is like `_.find` except that it returns the key of the first
	 * element `predicate` returns truthy for instead of the element itself.
	 *
	 * @static
	 * @memberOf _
	 * @since 1.1.0
	 * @category Object
	 * @param {Object} object The object to inspect.
	 * @param {Function} [predicate=_.identity] The function invoked per iteration.
	 * @returns {string|undefined} Returns the key of the matched element,
	 *  else `undefined`.
	 * @example
	 *
	 * var users = {
	 *   'barney':  { 'age': 36, 'active': true },
	 *   'fred':    { 'age': 40, 'active': false },
	 *   'pebbles': { 'age': 1,  'active': true }
	 * };
	 *
	 * _.findKey(users, function(o) { return o.age < 40; });
	 * // => 'barney' (iteration order is not guaranteed)
	 *
	 * // The `_.matches` iteratee shorthand.
	 * _.findKey(users, { 'age': 1, 'active': true });
	 * // => 'pebbles'
	 *
	 * // The `_.matchesProperty` iteratee shorthand.
	 * _.findKey(users, ['active', false]);
	 * // => 'fred'
	 *
	 * // The `_.property` iteratee shorthand.
	 * _.findKey(users, 'active');
	 * // => 'barney'
	 */
	function findKey(object, predicate) {
	  return baseFindKey(object, baseIteratee(predicate, 3), baseForOwn);
	}

	module.exports = findKey;


/***/ },
/* 427 */
/***/ function(module, exports) {

	/**
	 * The base implementation of methods like `_.findKey` and `_.findLastKey`,
	 * without support for iteratee shorthands, which iterates over `collection`
	 * using `eachFunc`.
	 *
	 * @private
	 * @param {Array|Object} collection The collection to inspect.
	 * @param {Function} predicate The function invoked per iteration.
	 * @param {Function} eachFunc The function to iterate over `collection`.
	 * @returns {*} Returns the found element or its key, else `undefined`.
	 */
	function baseFindKey(collection, predicate, eachFunc) {
	  var result;
	  eachFunc(collection, function(value, key, collection) {
	    if (predicate(value, key, collection)) {
	      result = key;
	      return false;
	    }
	  });
	  return result;
	}

	module.exports = baseFindKey;


/***/ },
/* 428 */
/***/ function(module, exports, __webpack_require__) {

	var castPath = __webpack_require__(114),
	    isFunction = __webpack_require__(31),
	    isKey = __webpack_require__(121),
	    toKey = __webpack_require__(122);

	/**
	 * This method is like `_.get` except that if the resolved value is a
	 * function it's invoked with the `this` binding of its parent object and
	 * its result is returned.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path of the property to resolve.
	 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
	 * @returns {*} Returns the resolved value.
	 * @example
	 *
	 * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
	 *
	 * _.result(object, 'a[0].b.c1');
	 * // => 3
	 *
	 * _.result(object, 'a[0].b.c2');
	 * // => 4
	 *
	 * _.result(object, 'a[0].b.c3', 'default');
	 * // => 'default'
	 *
	 * _.result(object, 'a[0].b.c3', _.constant('default'));
	 * // => 'default'
	 */
	function result(object, path, defaultValue) {
	  path = isKey(path, object) ? [path] : castPath(path);

	  var index = -1,
	      length = path.length;

	  // Ensure the loop is entered when path is empty.
	  if (!length) {
	    object = undefined;
	    length = 1;
	  }
	  while (++index < length) {
	    var value = object == null ? undefined : object[toKey(path[index])];
	    if (value === undefined) {
	      index = length;
	      value = defaultValue;
	    }
	    object = isFunction(value) ? value.call(object) : value;
	  }
	  return object;
	}

	module.exports = result;


/***/ },
/* 429 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Aggregation = undefined;

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _result = __webpack_require__(428);

	var _result2 = _interopRequireDefault(_result);

	var _assign = __webpack_require__(211);

	var _assign2 = _interopRequireDefault(_assign);

	var _forEach = __webpack_require__(19);

	var _forEach2 = _interopRequireDefault(_forEach);

	var _isString = __webpack_require__(217);

	var _isString2 = _interopRequireDefault(_isString);

	var _isObject = __webpack_require__(32);

	var _isObject2 = _interopRequireDefault(_isObject);

	var _isFunction = __webpack_require__(31);

	var _isFunction2 = _interopRequireDefault(_isFunction);

	var _errors = __webpack_require__(11);

	var _query = __webpack_require__(422);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * @private
	 */
	var Aggregation = exports.Aggregation = function () {
	  function Aggregation(options) {
	    _classCallCheck(this, Aggregation);

	    options = (0, _assign2.default)({
	      query: null,
	      initial: {},
	      key: {},
	      reduceFn: function () {}.toString()
	    }, options);

	    this.query = options.query;
	    this.initial = options.initial;
	    this.key = options.key;
	    this.reduceFn = options.reduceFn;
	  }

	  _createClass(Aggregation, [{
	    key: 'by',
	    value: function by(field) {
	      this.key[field] = true;
	      return this;
	    }
	  }, {
	    key: 'process',
	    value: function process() {
	      var entities = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];

	      var groups = {};
	      var response = [];
	      var aggregation = this.toJSON();
	      var reduceFn = aggregation.reduceFn.replace(/function[\s\S]*?\([\s\S]*?\)/, '');
	      aggregation.reduce = new Function(['doc', 'out'], reduceFn); // eslint-disable-line no-new-func

	      if (this.query) {
	        entities = this.query.process(entities);
	      }

	      (0, _forEach2.default)(entities, function (entity) {
	        var group = {};
	        var entityNames = Object.keys(entity);

	        (0, _forEach2.default)(entityNames, function (name) {
	          group[name] = entity[name];
	        });

	        var key = JSON.stringify(group);
	        if (!groups[key]) {
	          groups[key] = group;
	          var attributes = Object.keys(aggregation.initial);

	          (0, _forEach2.default)(attributes, function (attr) {
	            groups[key][attr] = aggregation.initial[attr];
	          });
	        }

	        aggregation.reduce(entity, groups[key]);
	      });

	      var segments = Object.keys(groups);
	      (0, _forEach2.default)(segments, function (segment) {
	        response.push(groups[segment]);
	      });

	      return response;
	    }
	  }, {
	    key: 'toJSON',
	    value: function toJSON() {
	      var json = {
	        key: this.key,
	        initial: this.initial,
	        reduceFn: this.reduceFn,
	        condition: this.query ? this.query.toJSON().filter : {},
	        query: this.query ? this.query.toJSON() : null
	      };

	      return json;
	    }
	  }, {
	    key: 'initial',
	    get: function get() {
	      return this.aggregationInitial;
	    },
	    set: function set(initial) {
	      if (!(0, _isObject2.default)(initial)) {
	        throw new _errors.KinveyError('initial must be an Object.');
	      }

	      this.aggregationInitial = initial;
	    }
	  }, {
	    key: 'query',
	    get: function get() {
	      return this.aggregationQuery;
	    },
	    set: function set(query) {
	      if (query && !(query instanceof _query.Query)) {
	        query = new _query.Query((0, _result2.default)(query, 'toJSON', query));
	      }

	      this.aggregationQuery = query;
	    }
	  }, {
	    key: 'reduceFn',
	    get: function get() {
	      return this.aggregationReduceFn;
	    },
	    set: function set(fn) {
	      if ((0, _isFunction2.default)(fn)) {
	        fn = fn.toString();
	      }

	      if (!(0, _isString2.default)(fn)) {
	        throw new _errors.KinveyError('fn argument must be of type function or string.');
	      }

	      this.aggregationReduceFn = fn;
	    }
	  }], [{
	    key: 'count',
	    value: function count() {
	      var field = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];

	      var aggregation = new Aggregation();

	      if (field) {
	        aggregation.by(field);
	      }

	      aggregation.initial = { result: 0 };
	      aggregation.reduceFn = function (doc, out) {
	        out.result += 1;
	        return out;
	      };
	      return aggregation;
	    }
	  }, {
	    key: 'sum',
	    value: function sum() {
	      var field = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];

	      field = field.replace('\'', '\\\'');

	      var aggregation = new Aggregation();
	      aggregation.initial = { result: 0 };
	      aggregation.reduceFn = function (doc, out) {
	        out.result += doc['\'' + field + '\''];
	      };
	      return aggregation;
	    }
	  }, {
	    key: 'min',
	    value: function min() {
	      var field = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];

	      field = field.replace('\'', '\\\'');

	      var aggregation = new Aggregation();
	      aggregation.initial = { result: Infinity };
	      aggregation.reduceFn = function (doc, out) {
	        out.result = Math.min(out.result, doc['\'' + field + '\'']);
	      };
	      return aggregation;
	    }
	  }, {
	    key: 'max',
	    value: function max() {
	      var field = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];

	      field = field.replace('\'', '\\\'');

	      var aggregation = new Aggregation();
	      aggregation.initial = { result: -Infinity };
	      aggregation.reduceFn = function (doc, out) {
	        out.result = Math.max(out.result, doc['\'' + field + '\'']);
	      };
	      return aggregation;
	    }
	  }, {
	    key: 'average',
	    value: function average() {
	      var field = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];

	      field = field.replace('\'', '\\\'');

	      var aggregation = new Aggregation();
	      aggregation.initial = { count: 0, result: 0 };
	      aggregation.reduceFn = function (doc, out) {
	        out.result = (out.result * out.count + doc['\'' + field + '\'']) / (out.count + 1);
	        out.count += 1;
	      };
	      return aggregation;
	    }
	  }]);

	  return Aggregation;
	}();

/***/ },
/* 430 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _cachestore = __webpack_require__(431);

	Object.keys(_cachestore).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function get() {
	      return _cachestore[key];
	    }
	  });
	});

	var _datastore = __webpack_require__(452);

	Object.keys(_datastore).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function get() {
	      return _datastore[key];
	    }
	  });
	});

	var _filestore = __webpack_require__(454);

	Object.keys(_filestore).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function get() {
	      return _filestore[key];
	    }
	  });
	});

	var _networkstore = __webpack_require__(432);

	Object.keys(_networkstore).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function get() {
	      return _networkstore[key];
	    }
	  });
	});

	var _sync = __webpack_require__(433);

	Object.keys(_sync).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function get() {
	      return _sync[key];
	    }
	  });
	});

	var _syncstore = __webpack_require__(453);

	Object.keys(_syncstore).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function get() {
	      return _syncstore[key];
	    }
	  });
	});

	var _userstore = __webpack_require__(455);

	Object.keys(_userstore).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function get() {
	      return _userstore[key];
	    }
	  });
	});

/***/ },
/* 431 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.CacheStore = undefined;

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _networkstore = __webpack_require__(432);

	var _request = __webpack_require__(219);

	var _errors = __webpack_require__(11);

	var _query5 = __webpack_require__(422);

	var _sync = __webpack_require__(433);

	var _entity = __webpack_require__(434);

	var _utils = __webpack_require__(13);

	var _regeneratorRuntime = __webpack_require__(148);

	var _regeneratorRuntime2 = _interopRequireDefault(_regeneratorRuntime);

	var _differenceBy = __webpack_require__(439);

	var _differenceBy2 = _interopRequireDefault(_differenceBy);

	var _keyBy = __webpack_require__(243);

	var _keyBy2 = _interopRequireDefault(_keyBy);

	var _url = __webpack_require__(206);

	var _url2 = _interopRequireDefault(_url);

	var _filter = __webpack_require__(445);

	var _filter2 = _interopRequireDefault(_filter);

	var _map = __webpack_require__(351);

	var _map2 = _interopRequireDefault(_map);

	var _xorWith = __webpack_require__(448);

	var _xorWith2 = _interopRequireDefault(_xorWith);

	var _isArray = __webpack_require__(35);

	var _isArray2 = _interopRequireDefault(_isArray);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { return step("next", value); }, function (err) { return step("throw", err); }); } } return step("next"); }); }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // eslint-disable-line no-unused-vars


	var idAttribute = process && process.env && process.env.KINVEY_ID_ATTRIBUTE || '_id' || '_id';

	/**
	 * The CacheStore class is used to find, create, update, remove, count and group entities. Entities are stored
	 * in a cache and synced with the backend.
	 */

	var CacheStore = exports.CacheStore = function (_NetworkStore) {
	  _inherits(CacheStore, _NetworkStore);

	  function CacheStore(collection) {
	    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	    _classCallCheck(this, CacheStore);

	    /**
	     * @type {number|undefined}
	     */
	    var _this = _possibleConstructorReturn(this, (CacheStore.__proto__ || Object.getPrototypeOf(CacheStore)).call(this, collection, options));

	    _this.ttl = options.ttl || undefined;

	    /**
	     * @type {SyncManager}
	     */
	    _this.syncManager = new _sync.SyncManager(_this.collection, options);
	    return _this;
	  }

	  _createClass(CacheStore, [{
	    key: 'find',


	    /**
	     * Find all entities in the data store. A query can be optionally provided to return
	     * a subset of all entities in a collection or omitted to return all entities in
	     * a collection. The number of entities returned adheres to the limits specified
	     * at http://devcenter.kinvey.com/rest/guides/datastore#queryrestrictions.
	     *
	     * @param   {Query}                 [query]                             Query used to filter entities.
	     * @param   {Object}                [options]                           Options
	     * @param   {Properties}            [options.properties]                Custom properties to send with
	     *                                                                      the request.
	     * @param   {Number}                [options.timeout]                   Timeout for the request.
	     * @param   {Boolean}               [options.useDeltaFetch]             Turn on or off the use of delta fetch.
	     * @return  {Observable}                                                Observable.
	     */
	    value: function find(query) {
	      var _this2 = this;

	      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	      var stream = _utils.KinveyObservable.create(function () {
	        var _ref = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee(observer) {
	          var cacheEntities, request, response, syncCount, networkEntities, removedEntities, removedIds, removeQuery, saveRequest;
	          return _regeneratorRuntime2.default.wrap(function _callee$(_context) {
	            while (1) {
	              switch (_context.prev = _context.next) {
	                case 0:
	                  _context.prev = 0;
	                  cacheEntities = [];
	                  _context.prev = 2;

	                  if (!(query && !(query instanceof _query5.Query))) {
	                    _context.next = 5;
	                    break;
	                  }

	                  throw new _errors.KinveyError('Invalid query. It must be an instance of the Query class.');

	                case 5:

	                  // Fetch the cache entities
	                  request = new _request.CacheRequest({
	                    method: _request.RequestMethod.GET,
	                    url: _url2.default.format({
	                      protocol: _this2.client.protocol,
	                      host: _this2.client.host,
	                      pathname: _this2.pathname,
	                      query: options.query
	                    }),
	                    properties: options.properties,
	                    query: query,
	                    timeout: options.timeout
	                  });

	                  // Execute the request

	                  _context.next = 8;
	                  return request.execute();

	                case 8:
	                  response = _context.sent;

	                  cacheEntities = response.data;

	                  // Emit the cache entities
	                  observer.next(cacheEntities);
	                  _context.next = 15;
	                  break;

	                case 13:
	                  _context.prev = 13;
	                  _context.t0 = _context['catch'](2);

	                case 15:
	                  if (!(_this2.syncAutomatically === true)) {
	                    _context.next = 39;
	                    break;
	                  }

	                  _context.next = 18;
	                  return _this2.pendingSyncCount(null, options);

	                case 18:
	                  syncCount = _context.sent;

	                  if (!(syncCount > 0)) {
	                    _context.next = 25;
	                    break;
	                  }

	                  _context.next = 22;
	                  return _this2.push(null, options);

	                case 22:
	                  _context.next = 24;
	                  return _this2.pendingSyncCount(null, options);

	                case 24:
	                  syncCount = _context.sent;

	                case 25:
	                  if (!(syncCount > 0)) {
	                    _context.next = 27;
	                    break;
	                  }

	                  throw new _errors.KinveyError('Unable to load data from the network.' + (' There are ' + syncCount + ' entities that need') + ' to be synced before data is loaded from the network.');

	                case 27:
	                  _context.next = 29;
	                  return _get(CacheStore.prototype.__proto__ || Object.getPrototypeOf(CacheStore.prototype), 'find', _this2).call(_this2, query, options).toPromise();

	                case 29:
	                  networkEntities = _context.sent;


	                  // Remove entities from the cache that no longer exists
	                  removedEntities = (0, _differenceBy2.default)(cacheEntities, networkEntities, idAttribute);
	                  removedIds = Object.keys((0, _keyBy2.default)(removedEntities, idAttribute));
	                  removeQuery = new _query5.Query().contains(idAttribute, removedIds);
	                  _context.next = 35;
	                  return _this2.clear(removeQuery, options);

	                case 35:

	                  // Save network entities to cache
	                  saveRequest = new _request.CacheRequest({
	                    method: _request.RequestMethod.PUT,
	                    url: _url2.default.format({
	                      protocol: _this2.client.protocol,
	                      host: _this2.client.host,
	                      pathname: _this2.pathname,
	                      query: options.query
	                    }),
	                    properties: options.properties,
	                    body: networkEntities,
	                    timeout: options.timeout
	                  });
	                  _context.next = 38;
	                  return saveRequest.execute();

	                case 38:

	                  // Emit the network entities
	                  observer.next(networkEntities);

	                case 39:
	                  _context.next = 44;
	                  break;

	                case 41:
	                  _context.prev = 41;
	                  _context.t1 = _context['catch'](0);
	                  return _context.abrupt('return', observer.error(_context.t1));

	                case 44:
	                  return _context.abrupt('return', observer.complete());

	                case 45:
	                case 'end':
	                  return _context.stop();
	              }
	            }
	          }, _callee, _this2, [[0, 41], [2, 13]]);
	        }));

	        return function (_x3) {
	          return _ref.apply(this, arguments);
	        };
	      }());

	      return stream;
	    }

	    /**
	     * Find a single entity in the data store by id.
	     *
	     * @param   {string}                id                               Entity by id to find.
	     * @param   {Object}                [options]                        Options
	     * @param   {Properties}            [options.properties]             Custom properties to send with
	     *                                                                   the request.
	     * @param   {Number}                [options.timeout]                Timeout for the request.
	     * @param   {Boolean}               [options.useDeltaFetch]          Turn on or off the use of delta fetch.
	     * @return  {Observable}                                             Observable.
	     */

	  }, {
	    key: 'findById',
	    value: function findById(id) {
	      var _this3 = this;

	      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	      var stream = _utils.KinveyObservable.create(function () {
	        var _ref2 = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee2(observer) {
	          var request, response, cacheEntity, syncCount, networkEntity, saveRequest;
	          return _regeneratorRuntime2.default.wrap(function _callee2$(_context2) {
	            while (1) {
	              switch (_context2.prev = _context2.next) {
	                case 0:
	                  _context2.prev = 0;

	                  if (id) {
	                    _context2.next = 5;
	                    break;
	                  }

	                  observer.next(undefined);
	                  _context2.next = 35;
	                  break;

	                case 5:
	                  _context2.prev = 5;

	                  // Fetch from the cache
	                  request = new _request.CacheRequest({
	                    method: _request.RequestMethod.GET,
	                    url: _url2.default.format({
	                      protocol: _this3.client.protocol,
	                      host: _this3.client.host,
	                      pathname: _this3.pathname + '/' + id,
	                      query: options.query
	                    }),
	                    properties: options.properties,
	                    timeout: options.timeout
	                  });
	                  _context2.next = 9;
	                  return request.execute();

	                case 9:
	                  response = _context2.sent;
	                  cacheEntity = response.data;

	                  // Emit the cache entity

	                  observer.next(cacheEntity);
	                  _context2.next = 16;
	                  break;

	                case 14:
	                  _context2.prev = 14;
	                  _context2.t0 = _context2['catch'](5);

	                case 16:
	                  if (!(_this3.syncAutomatically === true)) {
	                    _context2.next = 35;
	                    break;
	                  }

	                  _context2.next = 19;
	                  return _this3.pendingSyncCount(null, options);

	                case 19:
	                  syncCount = _context2.sent;

	                  if (!(syncCount > 0)) {
	                    _context2.next = 26;
	                    break;
	                  }

	                  _context2.next = 23;
	                  return _this3.push(null, options);

	                case 23:
	                  _context2.next = 25;
	                  return _this3.pendingSyncCount(null, options);

	                case 25:
	                  syncCount = _context2.sent;

	                case 26:
	                  if (!(syncCount > 0)) {
	                    _context2.next = 28;
	                    break;
	                  }

	                  throw new _errors.KinveyError('Unable to load data from the network.' + (' There are ' + syncCount + ' entities that need') + ' to be synced before data is loaded from the network.');

	                case 28:
	                  _context2.next = 30;
	                  return _get(CacheStore.prototype.__proto__ || Object.getPrototypeOf(CacheStore.prototype), 'findById', _this3).call(_this3, id, options).toPromise();

	                case 30:
	                  networkEntity = _context2.sent;


	                  // Save the network entity to cache
	                  saveRequest = new _request.CacheRequest({
	                    method: _request.RequestMethod.PUT,
	                    url: _url2.default.format({
	                      protocol: _this3.client.protocol,
	                      host: _this3.client.host,
	                      pathname: _this3.pathname,
	                      query: options.query
	                    }),
	                    properties: options.properties,
	                    body: networkEntity,
	                    timeout: options.timeout
	                  });
	                  _context2.next = 34;
	                  return saveRequest.execute();

	                case 34:

	                  // Emit the network entity
	                  observer.next(networkEntity);

	                case 35:
	                  _context2.next = 40;
	                  break;

	                case 37:
	                  _context2.prev = 37;
	                  _context2.t1 = _context2['catch'](0);
	                  return _context2.abrupt('return', observer.error(_context2.t1));

	                case 40:
	                  return _context2.abrupt('return', observer.complete());

	                case 41:
	                case 'end':
	                  return _context2.stop();
	              }
	            }
	          }, _callee2, _this3, [[0, 37], [5, 14]]);
	        }));

	        return function (_x5) {
	          return _ref2.apply(this, arguments);
	        };
	      }());

	      return stream;
	    }

	    /**
	     * Count all entities in the data store. A query can be optionally provided to return
	     * a subset of all entities in a collection or omitted to return all entities in
	     * a collection. The number of entities returned adheres to the limits specified
	     * at http://devcenter.kinvey.com/rest/guides/datastore#queryrestrictions.
	     *
	     * @param   {Query}                 [query]                          Query used to filter entities.
	     * @param   {Object}                [options]                        Options
	     * @param   {Properties}            [options.properties]             Custom properties to send with
	     *                                                                   the request.
	     * @param   {Number}                [options.timeout]                Timeout for the request.
	     * @return  {Observable}                                             Observable.
	     */

	  }, {
	    key: 'count',
	    value: function count(query) {
	      var _this4 = this;

	      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	      var stream = _utils.KinveyObservable.create(function () {
	        var _ref3 = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee3(observer) {
	          var request, response, data, syncCount, networkCount;
	          return _regeneratorRuntime2.default.wrap(function _callee3$(_context3) {
	            while (1) {
	              switch (_context3.prev = _context3.next) {
	                case 0:
	                  _context3.prev = 0;

	                  if (!(query && !(query instanceof _query5.Query))) {
	                    _context3.next = 3;
	                    break;
	                  }

	                  throw new _errors.KinveyError('Invalid query. It must be an instance of the Query class.');

	                case 3:
	                  _context3.prev = 3;

	                  // Count the entities in the cache
	                  request = new _request.CacheRequest({
	                    method: _request.RequestMethod.GET,
	                    url: _url2.default.format({
	                      protocol: _this4.client.protocol,
	                      host: _this4.client.host,
	                      pathname: _this4.pathname,
	                      query: options.query
	                    }),
	                    properties: options.properties,
	                    query: query,
	                    timeout: options.timeout
	                  });

	                  // Execute the request

	                  _context3.next = 7;
	                  return request.execute();

	                case 7:
	                  response = _context3.sent;
	                  data = response.data;

	                  // Emit the cache count

	                  observer.next(data ? data.length : 0);
	                  _context3.next = 14;
	                  break;

	                case 12:
	                  _context3.prev = 12;
	                  _context3.t0 = _context3['catch'](3);

	                case 14:
	                  if (!(_this4.syncAutomatically === true)) {
	                    _context3.next = 30;
	                    break;
	                  }

	                  _context3.next = 17;
	                  return _this4.pendingSyncCount(null, options);

	                case 17:
	                  syncCount = _context3.sent;

	                  if (!(syncCount > 0)) {
	                    _context3.next = 24;
	                    break;
	                  }

	                  _context3.next = 21;
	                  return _this4.push(null, options);

	                case 21:
	                  _context3.next = 23;
	                  return _this4.pendingSyncCount(null, options);

	                case 23:
	                  syncCount = _context3.sent;

	                case 24:
	                  if (!(syncCount > 0)) {
	                    _context3.next = 26;
	                    break;
	                  }

	                  throw new _errors.KinveyError('Unable to load data from the network.' + (' There are ' + syncCount + ' entities that need') + ' to be synced before data is loaded from the network.');

	                case 26:
	                  _context3.next = 28;
	                  return _get(CacheStore.prototype.__proto__ || Object.getPrototypeOf(CacheStore.prototype), 'count', _this4).call(_this4, query, options).toPromise();

	                case 28:
	                  networkCount = _context3.sent;


	                  // Emit the network count
	                  observer.next(networkCount);

	                case 30:
	                  _context3.next = 35;
	                  break;

	                case 32:
	                  _context3.prev = 32;
	                  _context3.t1 = _context3['catch'](0);
	                  return _context3.abrupt('return', observer.error(_context3.t1));

	                case 35:
	                  return _context3.abrupt('return', observer.complete());

	                case 36:
	                case 'end':
	                  return _context3.stop();
	              }
	            }
	          }, _callee3, _this4, [[0, 32], [3, 12]]);
	        }));

	        return function (_x7) {
	          return _ref3.apply(this, arguments);
	        };
	      }());

	      return stream;
	    }

	    /**
	     * Create a single or an array of entities on the data store.
	     *
	     * @param   {Object|Array}          data                              Data that you want to create on the data store.
	     * @param   {Object}                [options]                         Options
	     * @param   {Properties}            [options.properties]              Custom properties to send with
	     *                                                                    the request.
	     * @param   {Number}                [options.timeout]                 Timeout for the request.
	     * @return  {Promise}                                                 Promise.
	     */

	  }, {
	    key: 'create',
	    value: function create(data) {
	      var _this5 = this;

	      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	      var stream = _utils.KinveyObservable.create(function () {
	        var _ref4 = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee4(observer) {
	          var singular, request, response, ids, query, results, entities;
	          return _regeneratorRuntime2.default.wrap(function _callee4$(_context4) {
	            while (1) {
	              switch (_context4.prev = _context4.next) {
	                case 0:
	                  _context4.prev = 0;

	                  if (data) {
	                    _context4.next = 5;
	                    break;
	                  }

	                  observer.next(null);
	                  _context4.next = 25;
	                  break;

	                case 5:
	                  singular = false;

	                  // Cast the data to an array

	                  if (!(0, _isArray2.default)(data)) {
	                    singular = true;
	                    data = [data];
	                  }

	                  // Save the data to the cache
	                  request = new _request.CacheRequest({
	                    method: _request.RequestMethod.POST,
	                    url: _url2.default.format({
	                      protocol: _this5.client.protocol,
	                      host: _this5.client.host,
	                      pathname: _this5.pathname,
	                      query: options.query
	                    }),
	                    properties: options.properties,
	                    body: data,
	                    timeout: options.timeout
	                  });

	                  // Execute the request

	                  _context4.next = 10;
	                  return request.execute();

	                case 10:
	                  response = _context4.sent;

	                  data = response.data;

	                  // Add a create operation to sync
	                  _context4.next = 14;
	                  return _this5.syncManager.addCreateOperation(data, options);

	                case 14:
	                  if (!(_this5.syncAutomatically === true)) {
	                    _context4.next = 24;
	                    break;
	                  }

	                  ids = Object.keys((0, _keyBy2.default)(data, idAttribute));
	                  query = new _query5.Query().contains('entityId', ids);
	                  _context4.next = 19;
	                  return _this5.push(query, options);

	                case 19:
	                  results = _context4.sent;
	                  entities = (0, _map2.default)(results, function (result) {
	                    return result.entity;
	                  });

	                  // Emit the data

	                  observer.next(singular ? entities[0] : entities);
	                  _context4.next = 25;
	                  break;

	                case 24:
	                  // Emit the data
	                  observer.next(singular ? data[0] : data);

	                case 25:
	                  _context4.next = 30;
	                  break;

	                case 27:
	                  _context4.prev = 27;
	                  _context4.t0 = _context4['catch'](0);
	                  return _context4.abrupt('return', observer.error(_context4.t0));

	                case 30:
	                  return _context4.abrupt('return', observer.complete());

	                case 31:
	                case 'end':
	                  return _context4.stop();
	              }
	            }
	          }, _callee4, _this5, [[0, 27]]);
	        }));

	        return function (_x9) {
	          return _ref4.apply(this, arguments);
	        };
	      }());

	      return stream.toPromise();
	    }

	    /**
	     * Update a single or an array of entities on the data store.
	     *
	     * @param   {Object|Array}          data                              Data that you want to update on the data store.
	     * @param   {Object}                [options]                         Options
	     * @param   {Properties}            [options.properties]              Custom properties to send with
	     *                                                                    the request.
	     * @param   {Number}                [options.timeout]                 Timeout for the request.
	     * @return  {Promise}                                                 Promise.
	     */

	  }, {
	    key: 'update',
	    value: function update(data) {
	      var _this6 = this;

	      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	      var stream = _utils.KinveyObservable.create(function () {
	        var _ref5 = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee5(observer) {
	          var singular, request, response, ids, query, results, entities;
	          return _regeneratorRuntime2.default.wrap(function _callee5$(_context5) {
	            while (1) {
	              switch (_context5.prev = _context5.next) {
	                case 0:
	                  _context5.prev = 0;

	                  if (data) {
	                    _context5.next = 5;
	                    break;
	                  }

	                  observer.next(null);
	                  _context5.next = 25;
	                  break;

	                case 5:
	                  singular = false;

	                  // Cast the data to an array

	                  if (!(0, _isArray2.default)(data)) {
	                    singular = true;
	                    data = [data];
	                  }

	                  // Save the data to the cache
	                  request = new _request.CacheRequest({
	                    method: _request.RequestMethod.PUT,
	                    url: _url2.default.format({
	                      protocol: _this6.client.protocol,
	                      host: _this6.client.host,
	                      pathname: _this6.pathname,
	                      query: options.query
	                    }),
	                    properties: options.properties,
	                    body: data,
	                    timeout: options.timeout
	                  });

	                  // Execute the request

	                  _context5.next = 10;
	                  return request.execute();

	                case 10:
	                  response = _context5.sent;

	                  data = response.data;

	                  // Add an update operation to sync
	                  _context5.next = 14;
	                  return _this6.syncManager.addUpdateOperation(data, options);

	                case 14:
	                  if (!(_this6.syncAutomatically === true)) {
	                    _context5.next = 24;
	                    break;
	                  }

	                  ids = Object.keys((0, _keyBy2.default)(data, idAttribute));
	                  query = new _query5.Query().contains('entityId', ids);
	                  _context5.next = 19;
	                  return _this6.push(query, options);

	                case 19:
	                  results = _context5.sent;
	                  entities = (0, _map2.default)(results, function (result) {
	                    return result.entity;
	                  });

	                  // Emit the data

	                  observer.next(singular ? entities[0] : entities);
	                  _context5.next = 25;
	                  break;

	                case 24:
	                  // Emit the data
	                  observer.next(singular ? data[0] : data);

	                case 25:
	                  _context5.next = 30;
	                  break;

	                case 27:
	                  _context5.prev = 27;
	                  _context5.t0 = _context5['catch'](0);
	                  return _context5.abrupt('return', observer.error(_context5.t0));

	                case 30:
	                  return _context5.abrupt('return', observer.complete());

	                case 31:
	                case 'end':
	                  return _context5.stop();
	              }
	            }
	          }, _callee5, _this6, [[0, 27]]);
	        }));

	        return function (_x11) {
	          return _ref5.apply(this, arguments);
	        };
	      }());

	      return stream.toPromise();
	    }

	    /**
	     * Remove all entities in the data store. A query can be optionally provided to remove
	     * a subset of all entities in a collection or omitted to remove all entities in
	     * a collection. The number of entities removed adheres to the limits specified
	     * at http://devcenter.kinvey.com/rest/guides/datastore#queryrestrictions.
	     *
	     * @param   {Query}                 [query]                           Query used to filter entities.
	     * @param   {Object}                [options]                         Options
	     * @param   {Properties}            [options.properties]              Custom properties to send with
	     *                                                                    the request.
	     * @param   {Number}                [options.timeout]                 Timeout for the request.
	     * @return  {Promise}                                                 Promise.
	     */

	  }, {
	    key: 'remove',
	    value: function remove(query) {
	      var _this7 = this;

	      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	      var stream = _utils.KinveyObservable.create(function () {
	        var _ref6 = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee6(observer) {
	          var fetchRequest, fetchResponse, entities, removeRequest, removeResponse, localEntities, _query, syncEntities, ids, _query2;

	          return _regeneratorRuntime2.default.wrap(function _callee6$(_context6) {
	            while (1) {
	              switch (_context6.prev = _context6.next) {
	                case 0:
	                  _context6.prev = 0;

	                  if (!(query && !(query instanceof _query5.Query))) {
	                    _context6.next = 3;
	                    break;
	                  }

	                  throw new _errors.KinveyError('Invalid query. It must be an instance of the Query class.');

	                case 3:

	                  // Fetch the cache entities
	                  fetchRequest = new _request.CacheRequest({
	                    method: _request.RequestMethod.GET,
	                    url: _url2.default.format({
	                      protocol: _this7.client.protocol,
	                      host: _this7.client.host,
	                      pathname: _this7.pathname,
	                      query: options.query
	                    }),
	                    properties: options.properties,
	                    query: query,
	                    timeout: options.timeout
	                  });

	                  // Execute the request

	                  _context6.next = 6;
	                  return fetchRequest.execute();

	                case 6:
	                  fetchResponse = _context6.sent;
	                  entities = fetchResponse.data;

	                  // Remove the data from the cache

	                  removeRequest = new _request.CacheRequest({
	                    method: _request.RequestMethod.DELETE,
	                    url: _url2.default.format({
	                      protocol: _this7.client.protocol,
	                      host: _this7.client.host,
	                      pathname: _this7.pathname,
	                      query: options.query
	                    }),
	                    properties: options.properties,
	                    body: entities,
	                    timeout: options.timeout
	                  });

	                  // Execite the request

	                  _context6.next = 11;
	                  return removeRequest.execute();

	                case 11:
	                  removeResponse = _context6.sent;

	                  entities = removeResponse.data;

	                  if (!(entities && entities.length > 0)) {
	                    _context6.next = 21;
	                    break;
	                  }

	                  // Clear local entities from the sync table
	                  localEntities = (0, _filter2.default)(entities, function (entity) {
	                    var metadata = new _entity.Metadata(entity);
	                    return metadata.isLocal();
	                  });
	                  _query = new _query5.Query().contains('entityId', Object.keys((0, _keyBy2.default)(localEntities, idAttribute)));
	                  _context6.next = 18;
	                  return _this7.clearSync(_query, options);

	                case 18:

	                  // Create delete operations for non local data in the sync table
	                  syncEntities = (0, _xorWith2.default)(entities, localEntities, function (entity, localEntity) {
	                    return entity[idAttribute] === localEntity[idAttribute];
	                  });
	                  _context6.next = 21;
	                  return _this7.syncManager.addDeleteOperation(syncEntities, options);

	                case 21:
	                  if (!(_this7.syncAutomatically === true)) {
	                    _context6.next = 26;
	                    break;
	                  }

	                  ids = Object.keys((0, _keyBy2.default)(entities, idAttribute));
	                  _query2 = new _query5.Query().contains('entityId', ids);
	                  _context6.next = 26;
	                  return _this7.push(_query2, options);

	                case 26:

	                  // Emit the data
	                  observer.next(entities);
	                  _context6.next = 32;
	                  break;

	                case 29:
	                  _context6.prev = 29;
	                  _context6.t0 = _context6['catch'](0);
	                  return _context6.abrupt('return', observer.error(_context6.t0));

	                case 32:
	                  return _context6.abrupt('return', observer.complete());

	                case 33:
	                case 'end':
	                  return _context6.stop();
	              }
	            }
	          }, _callee6, _this7, [[0, 29]]);
	        }));

	        return function (_x13) {
	          return _ref6.apply(this, arguments);
	        };
	      }());

	      return stream.toPromise();
	    }

	    /**
	     * Remove a single entity in the data store by id.
	     *
	     * @param   {string}                id                               Entity by id to remove.
	     * @param   {Object}                [options]                        Options
	     * @param   {Properties}            [options.properties]             Custom properties to send with
	     *                                                                   the request.
	     * @param   {Number}                [options.timeout]                Timeout for the request.
	     * @return  {Observable}                                             Observable.
	     */

	  }, {
	    key: 'removeById',
	    value: function removeById(id) {
	      var _this8 = this;

	      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	      var stream = _utils.KinveyObservable.create(function () {
	        var _ref7 = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee7(observer) {
	          var request, response, entity, metadata, query, _query3;

	          return _regeneratorRuntime2.default.wrap(function _callee7$(_context7) {
	            while (1) {
	              switch (_context7.prev = _context7.next) {
	                case 0:
	                  _context7.prev = 0;

	                  // Remove from cache
	                  request = new _request.CacheRequest({
	                    method: _request.RequestMethod.DELETE,
	                    url: _url2.default.format({
	                      protocol: _this8.client.protocol,
	                      host: _this8.client.host,
	                      pathname: _this8.pathname + '/' + id,
	                      query: options.query
	                    }),
	                    properties: options.properties,
	                    authType: _request.AuthType.Default,
	                    timeout: options.timeout
	                  });

	                  // Execute the request

	                  _context7.next = 4;
	                  return request.execute();

	                case 4:
	                  response = _context7.sent;
	                  entity = response.data;

	                  if (!entity) {
	                    _context7.next = 17;
	                    break;
	                  }

	                  metadata = new _entity.Metadata(entity);

	                  // Clear any pending sync items if the entity
	                  // was created locally

	                  if (!metadata.isLocal()) {
	                    _context7.next = 15;
	                    break;
	                  }

	                  query = new _query5.Query();

	                  query.equalTo('entityId', entity[idAttribute]);
	                  _context7.next = 13;
	                  return _this8.clearSync(query, options);

	                case 13:
	                  _context7.next = 17;
	                  break;

	                case 15:
	                  _context7.next = 17;
	                  return _this8.syncManager.addDeleteOperation(entity, options);

	                case 17:
	                  if (!(_this8.syncAutomatically === true)) {
	                    _context7.next = 21;
	                    break;
	                  }

	                  _query3 = new _query5.Query().equalTo('entityId', entity[idAttribute]);
	                  _context7.next = 21;
	                  return _this8.push(_query3, options);

	                case 21:

	                  // Emit the data
	                  observer.next(entity);
	                  _context7.next = 27;
	                  break;

	                case 24:
	                  _context7.prev = 24;
	                  _context7.t0 = _context7['catch'](0);
	                  return _context7.abrupt('return', observer.error(_context7.t0));

	                case 27:
	                  return _context7.abrupt('return', observer.complete());

	                case 28:
	                case 'end':
	                  return _context7.stop();
	              }
	            }
	          }, _callee7, _this8, [[0, 24]]);
	        }));

	        return function (_x15) {
	          return _ref7.apply(this, arguments);
	        };
	      }());

	      return stream.toPromise();
	    }

	    /**
	     * Remove all entities in the data store that are stored locally.
	     *
	     * @param   {Query}                 [query]                           Query used to filter entities.
	     * @param   {Object}                [options]                         Options
	     * @param   {Properties}            [options.properties]              Custom properties to send with
	     *                                                                    the request.
	     * @param   {Number}                [options.timeout]                 Timeout for the request.
	     * @return  {Promise}                                                 Promise.
	     */

	  }, {
	    key: 'clear',
	    value: function clear(query) {
	      var _this9 = this;

	      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	      var stream = _utils.KinveyObservable.create(function () {
	        var _ref8 = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee8(observer) {
	          var fetchRequest, fetchResponse, entities, removeRequest, removeResponse, _query4;

	          return _regeneratorRuntime2.default.wrap(function _callee8$(_context8) {
	            while (1) {
	              switch (_context8.prev = _context8.next) {
	                case 0:
	                  _context8.prev = 0;

	                  if (!(query && !(query instanceof _query5.Query))) {
	                    _context8.next = 3;
	                    break;
	                  }

	                  throw new _errors.KinveyError('Invalid query. It must be an instance of the Query class.');

	                case 3:

	                  // Fetch the cache entities
	                  fetchRequest = new _request.CacheRequest({
	                    method: _request.RequestMethod.GET,
	                    url: _url2.default.format({
	                      protocol: _this9.client.protocol,
	                      host: _this9.client.host,
	                      pathname: _this9.pathname,
	                      query: options.query
	                    }),
	                    properties: options.properties,
	                    query: query,
	                    timeout: options.timeout
	                  });

	                  // Execute the request

	                  _context8.next = 6;
	                  return fetchRequest.execute();

	                case 6:
	                  fetchResponse = _context8.sent;
	                  entities = fetchResponse.data;

	                  // Remove the data from the cache

	                  removeRequest = new _request.CacheRequest({
	                    method: _request.RequestMethod.DELETE,
	                    url: _url2.default.format({
	                      protocol: _this9.client.protocol,
	                      host: _this9.client.host,
	                      pathname: _this9.pathname,
	                      query: options.query
	                    }),
	                    properties: options.properties,
	                    body: entities,
	                    timeout: options.timeout
	                  });

	                  // Execute the request

	                  _context8.next = 11;
	                  return removeRequest.execute();

	                case 11:
	                  removeResponse = _context8.sent;

	                  entities = removeResponse.data;

	                  if (!(entities && entities.length > 0)) {
	                    _context8.next = 17;
	                    break;
	                  }

	                  // Clear entities from the sync table
	                  _query4 = new _query5.Query().contains('entityId', Object.keys((0, _keyBy2.default)(entities, idAttribute)));
	                  _context8.next = 17;
	                  return _this9.clearSync(_query4, options);

	                case 17:

	                  // Emit the data
	                  observer.next(entities);
	                  _context8.next = 23;
	                  break;

	                case 20:
	                  _context8.prev = 20;
	                  _context8.t0 = _context8['catch'](0);
	                  return _context8.abrupt('return', observer.error(_context8.t0));

	                case 23:
	                  return _context8.abrupt('return', observer.complete());

	                case 24:
	                case 'end':
	                  return _context8.stop();
	              }
	            }
	          }, _callee8, _this9, [[0, 20]]);
	        }));

	        return function (_x17) {
	          return _ref8.apply(this, arguments);
	        };
	      }());

	      return stream.toPromise();
	    }

	    /**
	     * Count the number of entities waiting to be pushed to the network. A promise will be
	     * returned with the count of entities or rejected with an error.
	     *
	     * @param   {Query}                 [query]                                   Query to count a subset of entities.
	     * @param   {Object}                options                                   Options
	     * @param   {Properties}            [options.properties]                      Custom properties to send with
	     *                                                                            the request.
	     * @param   {Number}                [options.timeout]                         Timeout for the request.
	     * @param   {Number}                [options.ttl]                             Time to live for data retrieved
	     *                                                                            from the local cache.
	     * @return  {Promise}                                                         Promise
	     */

	  }, {
	    key: 'pendingSyncCount',
	    value: function pendingSyncCount(query, options) {
	      return this.syncManager.count(query, options);
	    }
	  }, {
	    key: 'syncCount',
	    value: function syncCount(query, options) {
	      return this.pendingSyncCount(query, options);
	    }
	  }, {
	    key: 'pendingSyncEntities',
	    value: function pendingSyncEntities(query, options) {
	      return this.syncManager.find(query, options);
	    }

	    /**
	     * Push sync items for the data store to the network. A promise will be returned that will be
	     * resolved with the result of the push or rejected with an error.
	     *
	     * @param   {Query}                 [query]                                   Query to push a subset of items.
	     * @param   {Object}                options                                   Options
	     * @param   {Properties}            [options.properties]                      Custom properties to send with
	     *                                                                            the request.
	     * @param   {Number}                [options.timeout]                         Timeout for the request.
	     * @return  {Promise}                                                         Promise
	     */

	  }, {
	    key: 'push',
	    value: function push(query, options) {
	      return this.syncManager.push(query, options);
	    }

	    /**
	     * Pull items for the data store from the network to your local cache. A promise will be
	     * returned that will be resolved with the result of the pull or rejected with an error.
	     *
	     * @param   {Query}                 [query]                                   Query to pull a subset of items.
	     * @param   {Object}                options                                   Options
	     * @param   {Properties}            [options.properties]                      Custom properties to send with
	     *                                                                            the request.
	     * @param   {Number}                [options.timeout]                         Timeout for the request.
	     * @return  {Promise}                                                         Promise
	     */

	  }, {
	    key: 'pull',
	    value: function () {
	      var _ref9 = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee9(query) {
	        var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
	        var entities, saveRequest;
	        return _regeneratorRuntime2.default.wrap(function _callee9$(_context9) {
	          while (1) {
	            switch (_context9.prev = _context9.next) {
	              case 0:
	                _context9.next = 2;
	                return this.syncManager.pull(query, options);

	              case 2:
	                entities = _context9.sent;
	                _context9.next = 5;
	                return this.clear(query, options);

	              case 5:

	                // Save network entities to cache
	                saveRequest = new _request.CacheRequest({
	                  method: _request.RequestMethod.PUT,
	                  url: _url2.default.format({
	                    protocol: this.client.protocol,
	                    host: this.client.host,
	                    pathname: this.pathname,
	                    query: options.query
	                  }),
	                  properties: options.properties,
	                  body: entities,
	                  timeout: options.timeout
	                });
	                _context9.next = 8;
	                return saveRequest.execute();

	              case 8:
	                return _context9.abrupt('return', entities);

	              case 9:
	              case 'end':
	                return _context9.stop();
	            }
	          }
	        }, _callee9, this);
	      }));

	      function pull(_x18, _x19) {
	        return _ref9.apply(this, arguments);
	      }

	      return pull;
	    }()

	    /**
	     * Sync items for the data store. This will push pending sync items first and then
	     * pull items from the network into your local cache. A promise will be
	     * returned that will be resolved with the result of the pull or rejected with an error.
	     *
	     * @param   {Query}                 [query]                                   Query to pull a subset of items.
	     * @param   {Object}                options                                   Options
	     * @param   {Properties}            [options.properties]                      Custom properties to send with
	     *                                                                            the request.
	     * @param   {Number}                [options.timeout]                         Timeout for the request.
	     * @return  {Promise}                                                         Promise
	     */

	  }, {
	    key: 'sync',
	    value: function sync(query, options) {
	      return this.syncManager.sync(query, options);
	    }
	  }, {
	    key: 'clearSync',
	    value: function clearSync(query, options) {
	      return this.syncManager.clear(query, options);
	    }

	    /**
	     * @deprecated Use clearSync() instead of this.
	     */

	  }, {
	    key: 'purge',
	    value: function purge(query, options) {
	      return this.clearSync(query, options);
	    }
	  }, {
	    key: 'syncAutomatically',
	    get: function get() {
	      return true;
	    }
	  }]);

	  return CacheStore;
	}(_networkstore.NetworkStore);
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 432 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.NetworkStore = undefined;

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // eslint-disable-line no-unused-vars


	var _request = __webpack_require__(219);

	var _errors = __webpack_require__(11);

	var _query = __webpack_require__(422);

	var _client = __webpack_require__(10);

	var _utils = __webpack_require__(13);

	var _promise = __webpack_require__(286);

	var _promise2 = _interopRequireDefault(_promise);

	var _regeneratorRuntime = __webpack_require__(148);

	var _regeneratorRuntime2 = _interopRequireDefault(_regeneratorRuntime);

	var _isString = __webpack_require__(217);

	var _isString2 = _interopRequireDefault(_isString);

	var _url = __webpack_require__(206);

	var _url2 = _interopRequireDefault(_url);

	var _map = __webpack_require__(351);

	var _map2 = _interopRequireDefault(_map);

	var _isArray = __webpack_require__(35);

	var _isArray2 = _interopRequireDefault(_isArray);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new _promise2.default(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return _promise2.default.resolve(value).then(function (value) { return step("next", value); }, function (err) { return step("throw", err); }); } } return step("next"); }); }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var idAttribute = process && process.env && process.env.KINVEY_ID_ATTRIBUTE || '_id' || '_id';
	var appdataNamespace = process && process.env && process.env.KINVEY_DATASTORE_NAMESPACE || 'appdata' || 'appdata';

	/**
	 * The NetworkStore class is used to find, create, update, remove, count and group entities over the network.
	 */

	var NetworkStore = exports.NetworkStore = function () {
	  function NetworkStore(collection) {
	    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	    _classCallCheck(this, NetworkStore);

	    if (collection && !(0, _isString2.default)(collection)) {
	      throw new _errors.KinveyError('Collection must be a string.');
	    }

	    /**
	     * @type {string}
	     */
	    this.collection = collection;

	    /**
	     * @type {Client}
	     */
	    this.client = options.client || _client.Client.sharedInstance();

	    /**
	     * @type {boolean}
	     */
	    this.useDeltaFetch = options.useDeltaFetch === true;
	  }

	  /**
	   * The pathname for the store.
	   * @return  {string}  Pathname
	   */


	  _createClass(NetworkStore, [{
	    key: 'find',


	    /**
	     * Find all entities in the data store. A query can be optionally provided to return
	     * a subset of all entities in a collection or omitted to return all entities in
	     * a collection. The number of entities returned adheres to the limits specified
	     * at http://devcenter.kinvey.com/rest/guides/datastore#queryrestrictions.
	     *
	     * @param   {Query}                 [query]                             Query used to filter entities.
	     * @param   {Object}                [options]                           Options
	     * @param   {Properties}            [options.properties]                Custom properties to send with
	     *                                                                      the request.
	     * @param   {Number}                [options.timeout]                   Timeout for the request.
	     * @param   {Boolean}               [options.useDeltaFetch]             Turn on or off the use of delta fetch.
	     * @return  {Observable}                                                Observable.
	     */
	    value: function find(query) {
	      var _this = this;

	      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	      var useDeltaFetch = options.useDeltaFetch || this.useDeltaFetch;
	      var stream = _utils.KinveyObservable.create(function () {
	        var _ref = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee(observer) {
	          var config, request, response;
	          return _regeneratorRuntime2.default.wrap(function _callee$(_context) {
	            while (1) {
	              switch (_context.prev = _context.next) {
	                case 0:
	                  _context.prev = 0;

	                  if (!(query && !(query instanceof _query.Query))) {
	                    _context.next = 3;
	                    break;
	                  }

	                  throw new _errors.KinveyError('Invalid query. It must be an instance of the Query class.');

	                case 3:

	                  // Create the request
	                  config = {
	                    method: _request.RequestMethod.GET,
	                    authType: _request.AuthType.Default,
	                    url: _url2.default.format({
	                      protocol: _this.client.protocol,
	                      host: _this.client.host,
	                      pathname: _this.pathname,
	                      query: options.query
	                    }),
	                    properties: options.properties,
	                    query: query,
	                    timeout: options.timeout,
	                    client: _this.client
	                  };
	                  request = new _request.KinveyRequest(config);

	                  // Should we use delta fetch?

	                  if (useDeltaFetch === true) {
	                    request = new _request.DeltaFetchRequest(config);
	                  }

	                  // Execute the request
	                  _context.next = 8;
	                  return request.execute();

	                case 8:
	                  response = _context.sent;


	                  // Send the response
	                  observer.next(response.data);
	                  _context.next = 15;
	                  break;

	                case 12:
	                  _context.prev = 12;
	                  _context.t0 = _context['catch'](0);
	                  return _context.abrupt('return', observer.error(_context.t0));

	                case 15:
	                  return _context.abrupt('return', observer.complete());

	                case 16:
	                case 'end':
	                  return _context.stop();
	              }
	            }
	          }, _callee, _this, [[0, 12]]);
	        }));

	        return function (_x3) {
	          return _ref.apply(this, arguments);
	        };
	      }());

	      return stream;
	    }

	    /**
	     * Find a single entity in the data store by id.
	     *
	     * @param   {string}                id                               Entity by id to find.
	     * @param   {Object}                [options]                        Options
	     * @param   {Properties}            [options.properties]             Custom properties to send with
	     *                                                                   the request.
	     * @param   {Number}                [options.timeout]                Timeout for the request.
	     * @param   {Boolean}               [options.useDeltaFetch]          Turn on or off the use of delta fetch.
	     * @return  {Observable}                                             Observable.
	     */

	  }, {
	    key: 'findById',
	    value: function findById(id) {
	      var _this2 = this;

	      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	      var useDeltaFetch = options.useDeltaFetch || this.useDeltaFetch;
	      var stream = _utils.KinveyObservable.create(function () {
	        var _ref2 = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee2(observer) {
	          var config, request, response, data;
	          return _regeneratorRuntime2.default.wrap(function _callee2$(_context2) {
	            while (1) {
	              switch (_context2.prev = _context2.next) {
	                case 0:
	                  _context2.prev = 0;

	                  if (id) {
	                    _context2.next = 5;
	                    break;
	                  }

	                  observer.next(undefined);
	                  _context2.next = 13;
	                  break;

	                case 5:
	                  // Fetch data from the network
	                  config = {
	                    method: _request.RequestMethod.GET,
	                    authType: _request.AuthType.Default,
	                    url: _url2.default.format({
	                      protocol: _this2.client.protocol,
	                      host: _this2.client.host,
	                      pathname: _this2.pathname + '/' + id,
	                      query: options.query
	                    }),
	                    properties: options.properties,
	                    timeout: options.timeout,
	                    client: _this2.client
	                  };
	                  request = new _request.KinveyRequest(config);


	                  if (useDeltaFetch === true) {
	                    request = new _request.DeltaFetchRequest(config);
	                  }

	                  _context2.next = 10;
	                  return request.execute();

	                case 10:
	                  response = _context2.sent;
	                  data = response.data;

	                  observer.next(data);

	                case 13:
	                  _context2.next = 18;
	                  break;

	                case 15:
	                  _context2.prev = 15;
	                  _context2.t0 = _context2['catch'](0);
	                  return _context2.abrupt('return', observer.error(_context2.t0));

	                case 18:
	                  return _context2.abrupt('return', observer.complete());

	                case 19:
	                case 'end':
	                  return _context2.stop();
	              }
	            }
	          }, _callee2, _this2, [[0, 15]]);
	        }));

	        return function (_x5) {
	          return _ref2.apply(this, arguments);
	        };
	      }());

	      return stream;
	    }

	    /**
	     * Count all entities in the data store. A query can be optionally provided to return
	     * a subset of all entities in a collection or omitted to return all entities in
	     * a collection. The number of entities returned adheres to the limits specified
	     * at http://devcenter.kinvey.com/rest/guides/datastore#queryrestrictions.
	     *
	     * @param   {Query}                 [query]                          Query used to filter entities.
	     * @param   {Object}                [options]                        Options
	     * @param   {Properties}            [options.properties]             Custom properties to send with
	     *                                                                   the request.
	     * @param   {Number}                [options.timeout]                Timeout for the request.
	     * @return  {Observable}                                             Observable.
	     */

	  }, {
	    key: 'count',
	    value: function count(query) {
	      var _this3 = this;

	      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	      var stream = _utils.KinveyObservable.create(function () {
	        var _ref3 = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee3(observer) {
	          var request, response, data;
	          return _regeneratorRuntime2.default.wrap(function _callee3$(_context3) {
	            while (1) {
	              switch (_context3.prev = _context3.next) {
	                case 0:
	                  _context3.prev = 0;

	                  if (!(query && !(query instanceof _query.Query))) {
	                    _context3.next = 3;
	                    break;
	                  }

	                  throw new _errors.KinveyError('Invalid query. It must be an instance of the Query class.');

	                case 3:

	                  // Create the request
	                  request = new _request.KinveyRequest({
	                    method: _request.RequestMethod.GET,
	                    authType: _request.AuthType.Default,
	                    url: _url2.default.format({
	                      protocol: _this3.client.protocol,
	                      host: _this3.client.host,
	                      pathname: _this3.pathname + '/_count',
	                      query: options.query
	                    }),
	                    properties: options.properties,
	                    query: query,
	                    timeout: options.timeout,
	                    client: _this3.client
	                  });

	                  // Execute the request

	                  _context3.next = 6;
	                  return request.execute();

	                case 6:
	                  response = _context3.sent;
	                  data = response.data;

	                  // Emit the count

	                  observer.next(data ? data.count : 0);
	                  _context3.next = 14;
	                  break;

	                case 11:
	                  _context3.prev = 11;
	                  _context3.t0 = _context3['catch'](0);
	                  return _context3.abrupt('return', observer.error(_context3.t0));

	                case 14:
	                  return _context3.abrupt('return', observer.complete());

	                case 15:
	                case 'end':
	                  return _context3.stop();
	              }
	            }
	          }, _callee3, _this3, [[0, 11]]);
	        }));

	        return function (_x7) {
	          return _ref3.apply(this, arguments);
	        };
	      }());

	      return stream;
	    }

	    /**
	     * Create a single or an array of entities on the data store.
	     *
	     * @param   {Object|Array}          data                              Data that you want to create on the data store.
	     * @param   {Object}                [options]                         Options
	     * @param   {Properties}            [options.properties]              Custom properties to send with
	     *                                                                    the request.
	     * @param   {Number}                [options.timeout]                 Timeout for the request.
	     * @return  {Promise}                                                 Promise.
	     */

	  }, {
	    key: 'create',
	    value: function create(data) {
	      var _this4 = this;

	      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	      var stream = _utils.KinveyObservable.create(function () {
	        var _ref4 = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee4(observer) {
	          var singular, responses;
	          return _regeneratorRuntime2.default.wrap(function _callee4$(_context4) {
	            while (1) {
	              switch (_context4.prev = _context4.next) {
	                case 0:
	                  _context4.prev = 0;

	                  if (data) {
	                    _context4.next = 5;
	                    break;
	                  }

	                  observer.next(null);
	                  _context4.next = 12;
	                  break;

	                case 5:
	                  singular = false;


	                  if (!(0, _isArray2.default)(data)) {
	                    singular = true;
	                    data = [data];
	                  }

	                  _context4.next = 9;
	                  return _promise2.default.all((0, _map2.default)(data, function (entity) {
	                    var request = new _request.KinveyRequest({
	                      method: _request.RequestMethod.POST,
	                      authType: _request.AuthType.Default,
	                      url: _url2.default.format({
	                        protocol: _this4.client.protocol,
	                        host: _this4.client.host,
	                        pathname: _this4.pathname,
	                        query: options.query
	                      }),
	                      properties: options.properties,
	                      data: entity,
	                      timeout: options.timeout,
	                      client: _this4.client
	                    });
	                    return request.execute();
	                  }));

	                case 9:
	                  responses = _context4.sent;


	                  data = (0, _map2.default)(responses, function (response) {
	                    return response.data;
	                  });
	                  observer.next(singular ? data[0] : data);

	                case 12:
	                  _context4.next = 17;
	                  break;

	                case 14:
	                  _context4.prev = 14;
	                  _context4.t0 = _context4['catch'](0);
	                  return _context4.abrupt('return', observer.error(_context4.t0));

	                case 17:
	                  return _context4.abrupt('return', observer.complete());

	                case 18:
	                case 'end':
	                  return _context4.stop();
	              }
	            }
	          }, _callee4, _this4, [[0, 14]]);
	        }));

	        return function (_x9) {
	          return _ref4.apply(this, arguments);
	        };
	      }());

	      return stream.toPromise();
	    }

	    /**
	     * Update a single or an array of entities on the data store.
	     *
	     * @param   {Object|Array}          data                              Data that you want to update on the data store.
	     * @param   {Object}                [options]                         Options
	     * @param   {Properties}            [options.properties]              Custom properties to send with
	     *                                                                    the request.
	     * @param   {Number}                [options.timeout]                 Timeout for the request.
	     * @return  {Promise}                                                 Promise.
	     */

	  }, {
	    key: 'update',
	    value: function update(data) {
	      var _this5 = this;

	      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	      var stream = _utils.KinveyObservable.create(function () {
	        var _ref5 = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee5(observer) {
	          var singular, responses;
	          return _regeneratorRuntime2.default.wrap(function _callee5$(_context5) {
	            while (1) {
	              switch (_context5.prev = _context5.next) {
	                case 0:
	                  _context5.prev = 0;

	                  if (data) {
	                    _context5.next = 5;
	                    break;
	                  }

	                  observer.next(null);
	                  _context5.next = 12;
	                  break;

	                case 5:
	                  singular = false;


	                  if (!(0, _isArray2.default)(data)) {
	                    singular = true;
	                    data = [data];
	                  }

	                  _context5.next = 9;
	                  return _promise2.default.all((0, _map2.default)(data, function (entity) {
	                    var request = new _request.KinveyRequest({
	                      method: _request.RequestMethod.PUT,
	                      authType: _request.AuthType.Default,
	                      url: _url2.default.format({
	                        protocol: _this5.client.protocol,
	                        host: _this5.client.host,
	                        pathname: _this5.pathname + '/' + entity[idAttribute],
	                        query: options.query
	                      }),
	                      properties: options.properties,
	                      data: entity,
	                      timeout: options.timeout,
	                      client: _this5.client
	                    });
	                    return request.execute();
	                  }));

	                case 9:
	                  responses = _context5.sent;


	                  data = (0, _map2.default)(responses, function (response) {
	                    return response.data;
	                  });
	                  observer.next(singular ? data[0] : data);

	                case 12:
	                  _context5.next = 17;
	                  break;

	                case 14:
	                  _context5.prev = 14;
	                  _context5.t0 = _context5['catch'](0);
	                  return _context5.abrupt('return', observer.error(_context5.t0));

	                case 17:
	                  return _context5.abrupt('return', observer.complete());

	                case 18:
	                case 'end':
	                  return _context5.stop();
	              }
	            }
	          }, _callee5, _this5, [[0, 14]]);
	        }));

	        return function (_x11) {
	          return _ref5.apply(this, arguments);
	        };
	      }());

	      return stream.toPromise();
	    }

	    /**
	     * Save a single or an array of entities on the data store.
	     *
	     * @param   {Object|Array}          data                              Data that you want to save on the data store.
	     * @param   {Object}                [options]                         Options
	     * @param   {Properties}            [options.properties]              Custom properties to send with
	     *                                                                    the request.
	     * @param   {Number}                [options.timeout]                 Timeout for the request.
	     * @return  {Promise}                                                 Promise.
	     */

	  }, {
	    key: 'save',
	    value: function save(data, options) {
	      if (data[idAttribute]) {
	        return this.update(data, options);
	      }

	      return this.create(data, options);
	    }

	    /**
	     * Remove all entities in the data store. A query can be optionally provided to remove
	     * a subset of all entities in a collection or omitted to remove all entities in
	     * a collection. The number of entities removed adheres to the limits specified
	     * at http://devcenter.kinvey.com/rest/guides/datastore#queryrestrictions.
	     *
	     * @param   {Query}                 [query]                           Query used to filter entities.
	     * @param   {Object}                [options]                         Options
	     * @param   {Properties}            [options.properties]              Custom properties to send with
	     *                                                                    the request.
	     * @param   {Number}                [options.timeout]                 Timeout for the request.
	     * @return  {Promise}                                                 Promise.
	     */

	  }, {
	    key: 'remove',
	    value: function remove(query) {
	      var _this6 = this;

	      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	      var stream = _utils.KinveyObservable.create(function () {
	        var _ref6 = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee6(observer) {
	          var request, response;
	          return _regeneratorRuntime2.default.wrap(function _callee6$(_context6) {
	            while (1) {
	              switch (_context6.prev = _context6.next) {
	                case 0:
	                  _context6.prev = 0;

	                  if (!(query && !(query instanceof _query.Query))) {
	                    _context6.next = 3;
	                    break;
	                  }

	                  throw new _errors.KinveyError('Invalid query. It must be an instance of the Query class.');

	                case 3:
	                  request = new _request.KinveyRequest({
	                    method: _request.RequestMethod.DELETE,
	                    authType: _request.AuthType.Default,
	                    url: _url2.default.format({
	                      protocol: _this6.client.protocol,
	                      host: _this6.client.host,
	                      pathname: _this6.pathname,
	                      query: options.query
	                    }),
	                    properties: options.properties,
	                    query: query,
	                    timeout: options.timeout,
	                    client: _this6.client
	                  });
	                  _context6.next = 6;
	                  return request.execute();

	                case 6:
	                  response = _context6.sent;

	                  observer.next(response.data);
	                  _context6.next = 13;
	                  break;

	                case 10:
	                  _context6.prev = 10;
	                  _context6.t0 = _context6['catch'](0);
	                  return _context6.abrupt('return', observer.error(_context6.t0));

	                case 13:
	                  return _context6.abrupt('return', observer.complete());

	                case 14:
	                case 'end':
	                  return _context6.stop();
	              }
	            }
	          }, _callee6, _this6, [[0, 10]]);
	        }));

	        return function (_x13) {
	          return _ref6.apply(this, arguments);
	        };
	      }());

	      return stream.toPromise();
	    }

	    /**
	     * Remove a single entity in the data store by id.
	     *
	     * @param   {string}                id                               Entity by id to remove.
	     * @param   {Object}                [options]                        Options
	     * @param   {Properties}            [options.properties]             Custom properties to send with
	     *                                                                   the request.
	     * @param   {Number}                [options.timeout]                Timeout for the request.
	     * @return  {Observable}                                             Observable.
	     */

	  }, {
	    key: 'removeById',
	    value: function removeById(id) {
	      var _this7 = this;

	      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	      var stream = _utils.KinveyObservable.create(function () {
	        var _ref7 = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee7(observer) {
	          var request, response;
	          return _regeneratorRuntime2.default.wrap(function _callee7$(_context7) {
	            while (1) {
	              switch (_context7.prev = _context7.next) {
	                case 0:
	                  _context7.prev = 0;

	                  if (id) {
	                    _context7.next = 5;
	                    break;
	                  }

	                  observer.next(undefined);
	                  _context7.next = 10;
	                  break;

	                case 5:
	                  request = new _request.KinveyRequest({
	                    method: _request.RequestMethod.DELETE,
	                    authType: _request.AuthType.Default,
	                    url: _url2.default.format({
	                      protocol: _this7.client.protocol,
	                      host: _this7.client.host,
	                      pathname: _this7.pathname + '/' + id,
	                      query: options.query
	                    }),
	                    properties: options.properties,
	                    timeout: options.timeout
	                  });
	                  _context7.next = 8;
	                  return request.execute();

	                case 8:
	                  response = _context7.sent;

	                  observer.next(response.data);

	                case 10:
	                  _context7.next = 15;
	                  break;

	                case 12:
	                  _context7.prev = 12;
	                  _context7.t0 = _context7['catch'](0);
	                  return _context7.abrupt('return', observer.error(_context7.t0));

	                case 15:
	                  return _context7.abrupt('return', observer.complete());

	                case 16:
	                case 'end':
	                  return _context7.stop();
	              }
	            }
	          }, _callee7, _this7, [[0, 12]]);
	        }));

	        return function (_x15) {
	          return _ref7.apply(this, arguments);
	        };
	      }());

	      return stream.toPromise();
	    }

	    /**
	     * Subscribes to a live stream
	     */

	  }, {
	    key: 'subscribe',
	    value: function subscribe(onNext, onError, onComplete) {
	      return this.liveStream.subscribe(onNext, onError, onComplete);
	    }
	  }, {
	    key: 'pathname',
	    get: function get() {
	      var pathname = '/' + appdataNamespace + '/' + this.client.appKey;

	      if (this.collection) {
	        pathname = pathname + '/' + this.collection;
	      }

	      return pathname;
	    }

	    /**
	     * Returns the live stream for the store.
	     * @return {Observable} Observable
	     */

	  }, {
	    key: 'liveStream',
	    get: function get() {
	      var _this8 = this;

	      if (typeof EventSource === 'undefined') {
	        throw new _errors.KinveyError('Your environment does not support server-sent events.');
	      }

	      if (!this._liveStream) {
	        (function () {
	          // Subscribe to KLS
	          var source = new EventSource(_url2.default.format({
	            protocol: _this8.client.liveServiceProtocol,
	            host: _this8.client.liveServiceHost,
	            pathname: _this8.pathname
	          }));

	          // Create a live stream
	          _this8._liveStream = _utils.KinveyObservable.create(function () {
	            var _ref8 = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee8(observer) {
	              return _regeneratorRuntime2.default.wrap(function _callee8$(_context8) {
	                while (1) {
	                  switch (_context8.prev = _context8.next) {
	                    case 0:
	                      // Open event
	                      source.onopen = function (event) {
	                        _utils.Log.info('Subscription to Kinvey Live Service is now open at ' + source.url + '.');
	                        _utils.Log.info(event);
	                      };

	                      // Message event
	                      source.onmessage = function (message) {
	                        try {
	                          observer.next(JSON.parse(message.data));
	                        } catch (error) {
	                          observer.error(error);
	                        }
	                      };

	                      // Error event
	                      source.onerror = function (error) {
	                        observer.error(error);
	                      };

	                      // Dispose function
	                      return _context8.abrupt('return', function () {
	                        observer.complete();
	                      });

	                    case 4:
	                    case 'end':
	                      return _context8.stop();
	                  }
	                }
	              }, _callee8, _this8);
	            }));

	            return function (_x16) {
	              return _ref8.apply(this, arguments);
	            };
	          }()).finally(function () {
	            source.close();
	            delete _this8._liveStream;
	          });
	        })();
	      }

	      // Return the stream
	      return this._liveStream;
	    }
	  }]);

	  return NetworkStore;
	}();
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 433 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.SyncManager = exports.SyncOperation = undefined;

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // eslint-disable-line no-unused-vars


	var _request2 = __webpack_require__(219);

	var _errors = __webpack_require__(11);

	var _client = __webpack_require__(10);

	var _query = __webpack_require__(422);

	var _promise = __webpack_require__(286);

	var _promise2 = _interopRequireDefault(_promise);

	var _regeneratorRuntime = __webpack_require__(148);

	var _regeneratorRuntime2 = _interopRequireDefault(_regeneratorRuntime);

	var _url = __webpack_require__(206);

	var _url2 = _interopRequireDefault(_url);

	var _map = __webpack_require__(351);

	var _map2 = _interopRequireDefault(_map);

	var _result = __webpack_require__(428);

	var _result2 = _interopRequireDefault(_result);

	var _isArray = __webpack_require__(35);

	var _isArray2 = _interopRequireDefault(_isArray);

	var _isString = __webpack_require__(217);

	var _isString2 = _interopRequireDefault(_isString);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new _promise2.default(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return _promise2.default.resolve(value).then(function (value) { return step("next", value); }, function (err) { return step("throw", err); }); } } return step("next"); }); }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var appdataNamespace = process && process.env && process.env.KINVEY_DATASTORE_NAMESPACE || 'appdata' || 'appdata';
	var syncCollectionName = process && process.env && process.env.KINVEY_SYNC_COLLECTION_NAME || 'kinvey_sync' || 'kinvey_sync';
	var idAttribute = process && process.env && process.env.KINVEY_ID_ATTRIBUTE || '_id' || '_id';

	/**
	 * @private
	 * Enum for Sync Operations.
	 */
	var SyncOperation = {
	  Create: _request2.RequestMethod.POST,
	  Update: _request2.RequestMethod.PUT,
	  Delete: _request2.RequestMethod.DELETE
	};
	Object.freeze(SyncOperation);
	exports.SyncOperation = SyncOperation;

	/**
	 * @private
	 */

	var SyncManager = exports.SyncManager = function () {
	  function SyncManager(collection) {
	    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	    _classCallCheck(this, SyncManager);

	    if (!collection) {
	      throw new _errors.SyncError('A collection is required.');
	    }

	    if (!(0, _isString2.default)(collection)) {
	      throw new _errors.SyncError('Collection must be a string.');
	    }

	    /**
	     * @type {string}
	     */
	    this.collection = collection;

	    /**
	     * @type {Client}
	     */
	    this.client = options.client || _client.Client.sharedInstance();
	  }

	  /**
	   * Pathname used to send sync requests.
	   *
	   * @return {String} sync pathname
	   */


	  _createClass(SyncManager, [{
	    key: 'find',
	    value: function () {
	      var _ref = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee() {
	        var query = arguments.length <= 0 || arguments[0] === undefined ? new _query.Query() : arguments[0];
	        var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
	        var syncEntities, request;
	        return _regeneratorRuntime2.default.wrap(function _callee$(_context) {
	          while (1) {
	            switch (_context.prev = _context.next) {
	              case 0:
	                syncEntities = [];


	                if (!(query instanceof _query.Query)) {
	                  query = new _query.Query((0, _result2.default)(query, 'toJSON', query));
	                }

	                query.equalTo('collection', this.collection);

	                // Get all sync entities
	                request = new _request2.CacheRequest({
	                  method: _request2.RequestMethod.GET,
	                  url: _url2.default.format({
	                    protocol: this.client.protocol,
	                    host: this.client.host,
	                    pathname: this.pathname
	                  }),
	                  properties: options.properties,
	                  query: query,
	                  timeout: options.timeout,
	                  client: this.client
	                });
	                _context.next = 6;
	                return request.execute().then(function (response) {
	                  return response.data;
	                });

	              case 6:
	                syncEntities = _context.sent;
	                return _context.abrupt('return', syncEntities);

	              case 8:
	              case 'end':
	                return _context.stop();
	            }
	          }
	        }, _callee, this);
	      }));

	      function find(_x2, _x3) {
	        return _ref.apply(this, arguments);
	      }

	      return find;
	    }()

	    /**
	     * Count the number of entities that are waiting to be synced. A query can be
	     * provided to only count a subset of entities.
	     *
	     * @param   {Query}         [query]                     Query
	     * @param   {Object}        [options={}]                Options
	     * @param   {Number}        [options.timeout]           Timeout for the request.
	     * @return  {Promise}                                   Promise
	     */

	  }, {
	    key: 'count',
	    value: function () {
	      var _ref2 = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee2() {
	        var query = arguments.length <= 0 || arguments[0] === undefined ? new _query.Query() : arguments[0];
	        var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
	        var syncEntities;
	        return _regeneratorRuntime2.default.wrap(function _callee2$(_context2) {
	          while (1) {
	            switch (_context2.prev = _context2.next) {
	              case 0:
	                _context2.next = 2;
	                return this.find(query, options);

	              case 2:
	                syncEntities = _context2.sent;
	                return _context2.abrupt('return', syncEntities.length);

	              case 4:
	              case 'end':
	                return _context2.stop();
	            }
	          }
	        }, _callee2, this);
	      }));

	      function count(_x6, _x7) {
	        return _ref2.apply(this, arguments);
	      }

	      return count;
	    }()
	  }, {
	    key: 'addCreateOperation',
	    value: function () {
	      var _ref3 = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee3(entities) {
	        var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
	        return _regeneratorRuntime2.default.wrap(function _callee3$(_context3) {
	          while (1) {
	            switch (_context3.prev = _context3.next) {
	              case 0:
	                return _context3.abrupt('return', this.addOperation(SyncOperation.Create, entities, options));

	              case 1:
	              case 'end':
	                return _context3.stop();
	            }
	          }
	        }, _callee3, this);
	      }));

	      function addCreateOperation(_x10, _x11) {
	        return _ref3.apply(this, arguments);
	      }

	      return addCreateOperation;
	    }()
	  }, {
	    key: 'addUpdateOperation',
	    value: function () {
	      var _ref4 = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee4(entities) {
	        var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
	        return _regeneratorRuntime2.default.wrap(function _callee4$(_context4) {
	          while (1) {
	            switch (_context4.prev = _context4.next) {
	              case 0:
	                return _context4.abrupt('return', this.addOperation(SyncOperation.Update, entities, options));

	              case 1:
	              case 'end':
	                return _context4.stop();
	            }
	          }
	        }, _callee4, this);
	      }));

	      function addUpdateOperation(_x13, _x14) {
	        return _ref4.apply(this, arguments);
	      }

	      return addUpdateOperation;
	    }()
	  }, {
	    key: 'addDeleteOperation',
	    value: function () {
	      var _ref5 = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee5(entities) {
	        var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
	        return _regeneratorRuntime2.default.wrap(function _callee5$(_context5) {
	          while (1) {
	            switch (_context5.prev = _context5.next) {
	              case 0:
	                return _context5.abrupt('return', this.addOperation(SyncOperation.Delete, entities, options));

	              case 1:
	              case 'end':
	                return _context5.stop();
	            }
	          }
	        }, _callee5, this);
	      }));

	      function addDeleteOperation(_x16, _x17) {
	        return _ref5.apply(this, arguments);
	      }

	      return addDeleteOperation;
	    }()
	  }, {
	    key: 'addOperation',
	    value: function () {
	      var _ref6 = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee7() {
	        var operation = arguments.length <= 0 || arguments[0] === undefined ? SyncOperation.Create : arguments[0];

	        var _this = this;

	        var entities = arguments[1];
	        var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];
	        var singular;
	        return _regeneratorRuntime2.default.wrap(function _callee7$(_context7) {
	          while (1) {
	            switch (_context7.prev = _context7.next) {
	              case 0:
	                singular = false;

	                // Cast the entities to an array

	                if (!(0, _isArray2.default)(entities)) {
	                  singular = true;
	                  entities = [entities];
	                }

	                // Process the array of entities
	                _context7.next = 4;
	                return _promise2.default.all((0, _map2.default)(entities, function () {
	                  var _ref7 = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee6(entity) {
	                    var id, query, findRequest, response, syncEntities, syncEntity, request;
	                    return _regeneratorRuntime2.default.wrap(function _callee6$(_context6) {
	                      while (1) {
	                        switch (_context6.prev = _context6.next) {
	                          case 0:
	                            if (entity) {
	                              _context6.next = 2;
	                              break;
	                            }

	                            return _context6.abrupt('return', null);

	                          case 2:

	                            // Validate that the entity has an id
	                            id = entity[idAttribute];

	                            if (id) {
	                              _context6.next = 5;
	                              break;
	                            }

	                            throw new _errors.SyncError('An entity is missing an _id. All entities must have an _id in order to be ' + 'added to the sync table.', entity);

	                          case 5:

	                            // Find an existing sync operation for the entity
	                            query = new _query.Query().equalTo('entityId', id);
	                            findRequest = new _request2.CacheRequest({
	                              method: _request2.RequestMethod.GET,
	                              url: _url2.default.format({
	                                protocol: _this.client.protocol,
	                                host: _this.client.host,
	                                pathname: _this.pathname
	                              }),
	                              properties: options.properties,
	                              query: query,
	                              timeout: options.timeout
	                            });
	                            _context6.next = 9;
	                            return findRequest.execute();

	                          case 9:
	                            response = _context6.sent;
	                            syncEntities = response.data;
	                            syncEntity = syncEntities.length === 1 ? syncEntities[0] : { collection: _this.collection, state: {}, entityId: id };

	                            // Update the state

	                            syncEntity.state = syncEntity.state || {};
	                            syncEntity.state.method = operation;

	                            // Send a request to save the sync entity
	                            request = new _request2.CacheRequest({
	                              method: _request2.RequestMethod.PUT,
	                              url: _url2.default.format({
	                                protocol: _this.client.protocol,
	                                host: _this.client.host,
	                                pathname: _this.pathname
	                              }),
	                              properties: options.properties,
	                              body: syncEntity,
	                              timeout: options.timeout
	                            });
	                            return _context6.abrupt('return', request.execute());

	                          case 16:
	                          case 'end':
	                            return _context6.stop();
	                        }
	                      }
	                    }, _callee6, _this);
	                  }));

	                  return function (_x24) {
	                    return _ref7.apply(this, arguments);
	                  };
	                }()));

	              case 4:
	                return _context7.abrupt('return', singular ? entities[0] : entities);

	              case 5:
	              case 'end':
	                return _context7.stop();
	            }
	          }
	        }, _callee7, this);
	      }));

	      function addOperation(_x19, _x20, _x21) {
	        return _ref6.apply(this, arguments);
	      }

	      return addOperation;
	    }()
	  }, {
	    key: 'pull',
	    value: function () {
	      var _ref8 = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee8(query) {
	        var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
	        var count, config, request, response;
	        return _regeneratorRuntime2.default.wrap(function _callee8$(_context8) {
	          while (1) {
	            switch (_context8.prev = _context8.next) {
	              case 0:
	                if (!(query && !(query instanceof _query.Query))) {
	                  _context8.next = 2;
	                  break;
	                }

	                throw new _errors.SyncError('Invalid query. It must be an instance of the Query class.');

	              case 2:
	                _context8.next = 4;
	                return this.count();

	              case 4:
	                count = _context8.sent;

	                if (!(count > 0)) {
	                  _context8.next = 11;
	                  break;
	                }

	                _context8.next = 8;
	                return this.push();

	              case 8:
	                _context8.next = 10;
	                return this.count();

	              case 10:
	                count = _context8.sent;

	              case 11:
	                if (!(count > 0)) {
	                  _context8.next = 13;
	                  break;
	                }

	                throw new _errors.SyncError('Unable to pull data from the network.' + (' There are ' + count + ' entities that need') + ' to be synced before data is loaded from the network.');

	              case 13:
	                config = {
	                  method: _request2.RequestMethod.GET,
	                  authType: _request2.AuthType.Default,
	                  url: _url2.default.format({
	                    protocol: this.client.protocol,
	                    host: this.client.host,
	                    pathname: this.backendPathname,
	                    query: options.query
	                  }),
	                  properties: options.properties,
	                  query: query,
	                  timeout: options.timeout,
	                  client: this.client
	                };
	                request = new _request2.KinveyRequest(config);

	                // Should we use delta fetch?

	                if (options.useDeltaFetch === true) {
	                  request = new _request2.DeltaFetchRequest(config);
	                }

	                // Execute the request
	                _context8.next = 18;
	                return request.execute();

	              case 18:
	                response = _context8.sent;
	                return _context8.abrupt('return', response.data);

	              case 20:
	              case 'end':
	                return _context8.stop();
	            }
	          }
	        }, _callee8, this);
	      }));

	      function pull(_x25, _x26) {
	        return _ref8.apply(this, arguments);
	      }

	      return pull;
	    }()

	    /*
	     * Sync entities with the network. A query can be provided to
	     * sync a subset of entities.
	     *
	     * @param   {Query}         [query]                     Query
	     * @param   {Object}        [options={}]                Options
	     * @param   {Number}        [options.timeout]           Timeout for the request.
	     * @return  {Promise}                                   Promise
	     */

	  }, {
	    key: 'push',
	    value: function () {
	      var _ref9 = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee14(query) {
	        var _this2 = this;

	        var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	        var batchSize, i, syncEntities, _ret;

	        return _regeneratorRuntime2.default.wrap(function _callee14$(_context14) {
	          while (1) {
	            switch (_context14.prev = _context14.next) {
	              case 0:
	                batchSize = 100;
	                i = 0;

	                // Get the pending sync items

	                _context14.next = 4;
	                return this.find(query);

	              case 4:
	                syncEntities = _context14.sent;

	                if (!(syncEntities.length > 0)) {
	                  _context14.next = 9;
	                  break;
	                }

	                _ret = function () {
	                  // Sync the entities in batches to prevent exhausting
	                  // available network connections
	                  var batchSync = function () {
	                    var _ref10 = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee13(syncResults) {
	                      var promise;
	                      return _regeneratorRuntime2.default.wrap(function _callee13$(_context13) {
	                        while (1) {
	                          switch (_context13.prev = _context13.next) {
	                            case 0:
	                              promise = new _promise2.default(function () {
	                                var _ref11 = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee12(resolve) {
	                                  var batch, results;
	                                  return _regeneratorRuntime2.default.wrap(function _callee12$(_context12) {
	                                    while (1) {
	                                      switch (_context12.prev = _context12.next) {
	                                        case 0:
	                                          batch = syncEntities.slice(i, i + batchSize);

	                                          i += batchSize;

	                                          // Get the results of syncing all of the entities
	                                          _context12.next = 4;
	                                          return _promise2.default.all((0, _map2.default)(batch, function (syncEntity) {
	                                            var entityId = syncEntity.entityId;
	                                            var state = syncEntity.state;
	                                            var method = state.method;


	                                            if (method === _request2.RequestMethod.DELETE) {
	                                              // Remove the entity from the network.
	                                              var request = new _request2.KinveyRequest({
	                                                method: _request2.RequestMethod.DELETE,
	                                                authType: _request2.AuthType.Default,
	                                                url: _url2.default.format({
	                                                  protocol: _this2.client.protocol,
	                                                  host: _this2.client.host,
	                                                  pathname: _this2.backendPathname + '/' + entityId
	                                                }),
	                                                properties: options.properties,
	                                                timeout: options.timeout,
	                                                client: _this2.client
	                                              });
	                                              return request.execute().then(function () {
	                                                // Remove the sync entity from the cache
	                                                var request = new _request2.CacheRequest({
	                                                  method: _request2.RequestMethod.DELETE,
	                                                  url: _url2.default.format({
	                                                    protocol: _this2.client.protocol,
	                                                    host: _this2.client.host,
	                                                    pathname: _this2.pathname + '/' + syncEntity[idAttribute]
	                                                  }),
	                                                  properties: options.properties,
	                                                  timeout: options.timeout
	                                                });
	                                                return request.execute();
	                                              }).then(function () {
	                                                // Return the result
	                                                var result = { _id: entityId };
	                                                return result;
	                                              }).catch(function () {
	                                                var _ref12 = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee9(error) {
	                                                  var getNetworkRequest, originalEntity, putCacheRequest, deleteSyncRequest;
	                                                  return _regeneratorRuntime2.default.wrap(function _callee9$(_context9) {
	                                                    while (1) {
	                                                      switch (_context9.prev = _context9.next) {
	                                                        case 0:
	                                                          if (!(error instanceof _errors.InsufficientCredentialsError)) {
	                                                            _context9.next = 16;
	                                                            break;
	                                                          }

	                                                          _context9.prev = 1;

	                                                          // Get the original entity
	                                                          getNetworkRequest = new _request2.KinveyRequest({
	                                                            method: _request2.RequestMethod.GET,
	                                                            authType: _request2.AuthType.Default,
	                                                            url: _url2.default.format({
	                                                              protocol: _this2.client.protocol,
	                                                              host: _this2.client.host,
	                                                              pathname: _this2.backendPathname + '/' + entityId
	                                                            }),
	                                                            properties: options.properties,
	                                                            timeout: options.timeout,
	                                                            client: _this2.client
	                                                          });
	                                                          _context9.next = 5;
	                                                          return getNetworkRequest.execute().then(function (response) {
	                                                            return response.data;
	                                                          });

	                                                        case 5:
	                                                          originalEntity = _context9.sent;


	                                                          // Update the cache with the original entity
	                                                          putCacheRequest = new _request2.CacheRequest({
	                                                            method: _request2.RequestMethod.PUT,
	                                                            url: _url2.default.format({
	                                                              protocol: _this2.client.protocol,
	                                                              host: _this2.client.host,
	                                                              pathname: _this2.backendPathname + '/' + entityId
	                                                            }),
	                                                            properties: options.properties,
	                                                            timeout: options.timeout,
	                                                            body: originalEntity
	                                                          });
	                                                          _context9.next = 9;
	                                                          return putCacheRequest.execute();

	                                                        case 9:

	                                                          // Clear the item from the sync table
	                                                          deleteSyncRequest = new _request2.CacheRequest({
	                                                            method: _request2.RequestMethod.DELETE,
	                                                            url: _url2.default.format({
	                                                              protocol: _this2.client.protocol,
	                                                              host: _this2.client.host,
	                                                              pathname: _this2.pathname + '/' + syncEntity[idAttribute]
	                                                            }),
	                                                            properties: options.properties,
	                                                            timeout: options.timeout
	                                                          });
	                                                          _context9.next = 12;
	                                                          return deleteSyncRequest.execute();

	                                                        case 12:
	                                                          _context9.next = 16;
	                                                          break;

	                                                        case 14:
	                                                          _context9.prev = 14;
	                                                          _context9.t0 = _context9['catch'](1);

	                                                        case 16:
	                                                          return _context9.abrupt('return', {
	                                                            _id: entityId,
	                                                            error: error
	                                                          });

	                                                        case 17:
	                                                        case 'end':
	                                                          return _context9.stop();
	                                                      }
	                                                    }
	                                                  }, _callee9, _this2, [[1, 14]]);
	                                                }));

	                                                return function (_x33) {
	                                                  return _ref12.apply(this, arguments);
	                                                };
	                                              }());
	                                            } else if (method === _request2.RequestMethod.POST || method === _request2.RequestMethod.PUT) {
	                                              // Get the entity from cache
	                                              var _request = new _request2.CacheRequest({
	                                                method: _request2.RequestMethod.GET,
	                                                url: _url2.default.format({
	                                                  protocol: _this2.client.protocol,
	                                                  host: _this2.client.host,
	                                                  pathname: _this2.backendPathname + '/' + entityId
	                                                }),
	                                                properties: options.properties,
	                                                timeout: options.timeout
	                                              });
	                                              return _request.execute().then(function (response) {
	                                                var entity = response.data;

	                                                // Save the entity to the backend.
	                                                var request = new _request2.KinveyRequest({
	                                                  method: method,
	                                                  authType: _request2.AuthType.Default,
	                                                  url: _url2.default.format({
	                                                    protocol: _this2.client.protocol,
	                                                    host: _this2.client.host,
	                                                    pathname: _this2.backendPathname + '/' + entityId
	                                                  }),
	                                                  properties: options.properties,
	                                                  timeout: options.timeout,
	                                                  body: entity,
	                                                  client: _this2.client
	                                                });

	                                                // If the entity was created locally then delete the autogenerated _id,
	                                                // send a POST request, and update the url.
	                                                if (method === _request2.RequestMethod.POST) {
	                                                  delete entity[idAttribute];
	                                                  request.method = _request2.RequestMethod.POST;
	                                                  request.url = _url2.default.format({
	                                                    protocol: _this2.client.protocol,
	                                                    host: _this2.client.host,
	                                                    pathname: _this2.backendPathname
	                                                  });
	                                                  request.body = entity;
	                                                }

	                                                return request.execute().then(function (response) {
	                                                  return response.data;
	                                                }).then(function () {
	                                                  var _ref13 = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee10(entity) {
	                                                    var deleteRequest, putCacheRequest, deleteCacheRequest;
	                                                    return _regeneratorRuntime2.default.wrap(function _callee10$(_context10) {
	                                                      while (1) {
	                                                        switch (_context10.prev = _context10.next) {
	                                                          case 0:
	                                                            // Remove the sync entity
	                                                            deleteRequest = new _request2.CacheRequest({
	                                                              method: _request2.RequestMethod.DELETE,
	                                                              url: _url2.default.format({
	                                                                protocol: _this2.client.protocol,
	                                                                host: _this2.client.host,
	                                                                pathname: _this2.pathname + '/' + syncEntity[idAttribute]
	                                                              }),
	                                                              properties: options.properties,
	                                                              timeout: options.timeout
	                                                            });
	                                                            _context10.next = 3;
	                                                            return deleteRequest.execute();

	                                                          case 3:

	                                                            // Save the result of the network request locally.
	                                                            putCacheRequest = new _request2.CacheRequest({
	                                                              method: _request2.RequestMethod.PUT,
	                                                              url: _url2.default.format({
	                                                                protocol: _this2.client.protocol,
	                                                                host: _this2.client.host,
	                                                                pathname: _this2.backendPathname + '/' + entity[idAttribute]
	                                                              }),
	                                                              properties: options.properties,
	                                                              timeout: options.timeout,
	                                                              body: entity
	                                                            });
	                                                            _context10.next = 6;
	                                                            return putCacheRequest.execute().then(function (response) {
	                                                              return response.data;
	                                                            });

	                                                          case 6:
	                                                            entity = _context10.sent;

	                                                            if (!(method === _request2.RequestMethod.POST)) {
	                                                              _context10.next = 11;
	                                                              break;
	                                                            }

	                                                            deleteCacheRequest = new _request2.CacheRequest({
	                                                              method: _request2.RequestMethod.DELETE,
	                                                              url: _url2.default.format({
	                                                                protocol: _this2.client.protocol,
	                                                                host: _this2.client.host,
	                                                                pathname: _this2.backendPathname + '/' + entityId
	                                                              }),
	                                                              properties: options.properties,
	                                                              timeout: options.timeout
	                                                            });
	                                                            _context10.next = 11;
	                                                            return deleteCacheRequest.execute();

	                                                          case 11:
	                                                            return _context10.abrupt('return', {
	                                                              _id: entityId,
	                                                              entity: entity
	                                                            });

	                                                          case 12:
	                                                          case 'end':
	                                                            return _context10.stop();
	                                                        }
	                                                      }
	                                                    }, _callee10, _this2);
	                                                  }));

	                                                  return function (_x34) {
	                                                    return _ref13.apply(this, arguments);
	                                                  };
	                                                }()).catch(function () {
	                                                  var _ref14 = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee11(error) {
	                                                    var getNetworkRequest, originalEntity, putCacheRequest, deleteSyncRequest;
	                                                    return _regeneratorRuntime2.default.wrap(function _callee11$(_context11) {
	                                                      while (1) {
	                                                        switch (_context11.prev = _context11.next) {
	                                                          case 0:
	                                                            if (!(error instanceof _errors.InsufficientCredentialsError)) {
	                                                              _context11.next = 17;
	                                                              break;
	                                                            }

	                                                            _context11.prev = 1;

	                                                            if (!(method !== _request2.RequestMethod.POST)) {
	                                                              _context11.next = 13;
	                                                              break;
	                                                            }

	                                                            // Get the original entity
	                                                            getNetworkRequest = new _request2.KinveyRequest({
	                                                              method: _request2.RequestMethod.GET,
	                                                              authType: _request2.AuthType.Default,
	                                                              url: _url2.default.format({
	                                                                protocol: _this2.client.protocol,
	                                                                host: _this2.client.host,
	                                                                pathname: _this2.backendPathname + '/' + entityId
	                                                              }),
	                                                              properties: options.properties,
	                                                              timeout: options.timeout,
	                                                              client: _this2.client
	                                                            });
	                                                            _context11.next = 6;
	                                                            return getNetworkRequest.execute().then(function (response) {
	                                                              return response.data;
	                                                            });

	                                                          case 6:
	                                                            originalEntity = _context11.sent;


	                                                            // Update the cache with the original entity
	                                                            putCacheRequest = new _request2.CacheRequest({
	                                                              method: _request2.RequestMethod.PUT,
	                                                              url: _url2.default.format({
	                                                                protocol: _this2.client.protocol,
	                                                                host: _this2.client.host,
	                                                                pathname: _this2.backendPathname + '/' + entityId
	                                                              }),
	                                                              properties: options.properties,
	                                                              timeout: options.timeout,
	                                                              body: originalEntity
	                                                            });
	                                                            _context11.next = 10;
	                                                            return putCacheRequest.execute();

	                                                          case 10:

	                                                            // Clear the item from the sync table
	                                                            deleteSyncRequest = new _request2.CacheRequest({
	                                                              method: _request2.RequestMethod.DELETE,
	                                                              url: _url2.default.format({
	                                                                protocol: _this2.client.protocol,
	                                                                host: _this2.client.host,
	                                                                pathname: _this2.pathname + '/' + syncEntity[idAttribute]
	                                                              }),
	                                                              properties: options.properties,
	                                                              timeout: options.timeout
	                                                            });
	                                                            _context11.next = 13;
	                                                            return deleteSyncRequest.execute();

	                                                          case 13:
	                                                            _context11.next = 17;
	                                                            break;

	                                                          case 15:
	                                                            _context11.prev = 15;
	                                                            _context11.t0 = _context11['catch'](1);

	                                                          case 17:
	                                                            return _context11.abrupt('return', {
	                                                              _id: entityId,
	                                                              entity: entity,
	                                                              error: error
	                                                            });

	                                                          case 18:
	                                                          case 'end':
	                                                            return _context11.stop();
	                                                        }
	                                                      }
	                                                    }, _callee11, _this2, [[1, 15]]);
	                                                  }));

	                                                  return function (_x35) {
	                                                    return _ref14.apply(this, arguments);
	                                                  };
	                                                }());
	                                              }).catch(function (error) {
	                                                return { _id: entityId, entity: undefined, error: error };
	                                              });
	                                            }

	                                            return {
	                                              _id: entityId,
	                                              entity: undefined,
	                                              error: new _errors.SyncError('Unable to sync the entity since the method was not recognized.', syncEntity)
	                                            };
	                                          }));

	                                        case 4:
	                                          results = _context12.sent;


	                                          // Concat the results
	                                          syncResults = syncResults.concat(results);

	                                          // Sync the remaining entities

	                                          if (!(i < syncEntities.length)) {
	                                            _context12.next = 8;
	                                            break;
	                                          }

	                                          return _context12.abrupt('return', resolve(batchSync(syncResults)));

	                                        case 8:
	                                          return _context12.abrupt('return', resolve(syncResults));

	                                        case 9:
	                                        case 'end':
	                                          return _context12.stop();
	                                      }
	                                    }
	                                  }, _callee12, _this2);
	                                }));

	                                return function (_x32) {
	                                  return _ref11.apply(this, arguments);
	                                };
	                              }());
	                              return _context13.abrupt('return', promise);

	                            case 2:
	                            case 'end':
	                              return _context13.stop();
	                          }
	                        }
	                      }, _callee13, _this2);
	                    }));

	                    return function batchSync(_x31) {
	                      return _ref10.apply(this, arguments);
	                    };
	                  }();

	                  // Return the result
	                  return {
	                    v: batchSync([])
	                  };
	                }();

	                if (!((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object")) {
	                  _context14.next = 9;
	                  break;
	                }

	                return _context14.abrupt('return', _ret.v);

	              case 9:
	                return _context14.abrupt('return', []);

	              case 10:
	              case 'end':
	                return _context14.stop();
	            }
	          }
	        }, _callee14, this);
	      }));

	      function push(_x28, _x29) {
	        return _ref9.apply(this, arguments);
	      }

	      return push;
	    }()
	  }, {
	    key: 'sync',
	    value: function () {
	      var _ref15 = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee15(query) {
	        var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
	        var push, pull;
	        return _regeneratorRuntime2.default.wrap(function _callee15$(_context15) {
	          while (1) {
	            switch (_context15.prev = _context15.next) {
	              case 0:
	                _context15.next = 2;
	                return this.push(null, options);

	              case 2:
	                push = _context15.sent;
	                _context15.next = 5;
	                return this.pull(query, options);

	              case 5:
	                pull = _context15.sent;
	                return _context15.abrupt('return', {
	                  push: push,
	                  pull: pull
	                });

	              case 7:
	              case 'end':
	                return _context15.stop();
	            }
	          }
	        }, _callee15, this);
	      }));

	      function sync(_x36, _x37) {
	        return _ref15.apply(this, arguments);
	      }

	      return sync;
	    }()

	    /**
	     * Clear the sync table. A query can be provided to
	     * only clear a subset of the sync table.
	     *
	     * @param   {Query}         [query]                     Query
	     * @param   {Object}        [options={}]                Options
	     * @param   {Number}        [options.timeout]           Timeout for the request.
	     * @return  {Promise}                                   Promise
	     */

	  }, {
	    key: 'clear',
	    value: function () {
	      var _ref16 = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee16() {
	        var query = arguments.length <= 0 || arguments[0] === undefined ? new _query.Query() : arguments[0];
	        var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
	        var fetchRequest, fetchResponse, entities, removeRequest, removeResponse;
	        return _regeneratorRuntime2.default.wrap(function _callee16$(_context16) {
	          while (1) {
	            switch (_context16.prev = _context16.next) {
	              case 0:
	                if (!(query instanceof _query.Query)) {
	                  query = new _query.Query(query);
	                }
	                query.equalTo('collection', this.collection);

	                fetchRequest = new _request2.CacheRequest({
	                  method: _request2.RequestMethod.GET,
	                  url: _url2.default.format({
	                    protocol: this.client.protocol,
	                    host: this.client.host,
	                    pathname: this.pathname
	                  }),
	                  properties: options.properties,
	                  query: query,
	                  timeout: options.timeout
	                });
	                _context16.next = 5;
	                return fetchRequest.execute();

	              case 5:
	                fetchResponse = _context16.sent;
	                entities = fetchResponse.data;
	                removeRequest = new _request2.CacheRequest({
	                  method: _request2.RequestMethod.DELETE,
	                  url: _url2.default.format({
	                    protocol: this.client.protocol,
	                    host: this.client.host,
	                    pathname: this.pathname
	                  }),
	                  properties: options.properties,
	                  body: entities,
	                  timeout: options.timeout
	                });
	                _context16.next = 10;
	                return removeRequest.execute();

	              case 10:
	                removeResponse = _context16.sent;
	                return _context16.abrupt('return', removeResponse.data);

	              case 12:
	              case 'end':
	                return _context16.stop();
	            }
	          }
	        }, _callee16, this);
	      }));

	      function clear(_x39, _x40) {
	        return _ref16.apply(this, arguments);
	      }

	      return clear;
	    }()
	  }, {
	    key: 'pathname',
	    get: function get() {
	      return '/' + appdataNamespace + '/' + this.client.appKey + '/' + syncCollectionName;
	    }

	    /**
	     * Pathname used to send backend requests.
	     *
	     * @return {String} sync pathname
	     */

	  }, {
	    key: 'backendPathname',
	    get: function get() {
	      return '/' + appdataNamespace + '/' + this.client.appKey + '/' + this.collection;
	    }
	  }]);

	  return SyncManager;
	}();
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 434 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _acl = __webpack_require__(435);

	Object.keys(_acl).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function get() {
	      return _acl[key];
	    }
	  });
	});

	var _metadata = __webpack_require__(437);

	Object.keys(_metadata).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function get() {
	      return _metadata[key];
	    }
	  });
	});

	var _user = __webpack_require__(438);

	Object.keys(_user).forEach(function (key) {
	  if (key === "default" || key === "__esModule") return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function get() {
	      return _user[key];
	    }
	  });
	});

/***/ },
/* 435 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Acl = undefined;

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _errors = __webpack_require__(11);

	var _clone = __webpack_require__(436);

	var _clone2 = _interopRequireDefault(_clone);

	var _isPlainObject = __webpack_require__(224);

	var _isPlainObject2 = _interopRequireDefault(_isPlainObject);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var aclAttribute = process && process.env && process.env.KINVEY_ACL_ATTRIBUTE || '_acl' || '_acl';

	/**
	 * The Acl class is used as a wrapper for reading and setting permissions on an entity level.
	 *
	 * @example
	 * var entity = { _acl: {} };
	 * var acl = new Kinvey.Acl(entity);
	 */

	var Acl = exports.Acl = function () {
	  function Acl() {
	    var entity = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

	    _classCallCheck(this, Acl);

	    if (!(0, _isPlainObject2.default)(entity)) {
	      throw new _errors.KinveyError('entity argument must be an object');
	    }

	    /**
	     * The kmd properties.
	     *
	     * @private
	     * @type {Object}
	     */
	    this.acl = (0, _clone2.default)(entity[aclAttribute]);
	  }

	  _createClass(Acl, [{
	    key: 'addReader',
	    value: function addReader(user) {
	      var r = this.acl.r || [];

	      if (r.indexOf(user) === -1) {
	        r.push(user);
	      }

	      this.acl.r = r;
	      return this;
	    }
	  }, {
	    key: 'addReaderGroup',
	    value: function addReaderGroup(group) {
	      var groups = this.acl.groups || {};
	      var r = groups.r || [];

	      if (r.indexOf(group) === -1) {
	        r.push(group);
	      }

	      groups.r = r;
	      this.acl.groups = groups;
	      return this;
	    }
	  }, {
	    key: 'addWriter',
	    value: function addWriter(user) {
	      var w = this.acl.w || [];

	      if (w.indexOf(user) === -1) {
	        w.push(user);
	      }

	      this.acl.w = w;
	      return this;
	    }
	  }, {
	    key: 'addWriterGroup',
	    value: function addWriterGroup(group) {
	      var groups = this.acl.groups || {};
	      var w = groups.w || [];

	      if (w.indexOf(group) === -1) {
	        w.push(group);
	      }

	      groups.w = w;
	      this.acl.groups = groups;
	      return this;
	    }
	  }, {
	    key: 'isGloballyReadable',
	    value: function isGloballyReadable() {
	      return this.acl.gr || false;
	    }
	  }, {
	    key: 'isGloballyWritable',
	    value: function isGloballyWritable() {
	      return this.acl.gw || false;
	    }
	  }, {
	    key: 'removeReader',
	    value: function removeReader(user) {
	      var r = this.acl.r || [];
	      var pos = r.indexOf(user);

	      if (pos !== -1) {
	        r.splice(pos, 1);
	      }

	      this.acl.r = r;
	      return this;
	    }
	  }, {
	    key: 'removeReaderGroup',
	    value: function removeReaderGroup(group) {
	      var groups = this.acl.groups || {};
	      var r = groups.r || [];
	      var pos = r.indexOf(group);

	      if (pos !== -1) {
	        r.splice(pos, 1);
	      }

	      groups.r = r;
	      this.acl.groups = groups;
	      return this;
	    }
	  }, {
	    key: 'removeWriter',
	    value: function removeWriter(user) {
	      var w = this.acl.w || [];
	      var pos = w.indexOf(user);

	      if (pos !== -1) {
	        w.splice(pos, 1);
	      }

	      this.acl.w = w;
	      return this;
	    }
	  }, {
	    key: 'removeWriterGroup',
	    value: function removeWriterGroup(group) {
	      var groups = this.acl.groups || {};
	      var w = groups.w || [];
	      var pos = w.indexOf(group);

	      if (pos !== -1) {
	        w.splice(pos, 1);
	      }

	      groups.w = w;
	      this.acl.groups = groups;
	      return this;
	    }
	  }, {
	    key: 'toPlainObject',
	    value: function toPlainObject() {
	      return this.acl;
	    }
	  }, {
	    key: 'toJSON',
	    value: function toJSON() {
	      return this.toPlainObject();
	    }
	  }, {
	    key: 'creator',
	    get: function get() {
	      return this.acl.creator;
	    }
	  }, {
	    key: 'readers',
	    get: function get() {
	      return this.acl.r || [];
	    }
	  }, {
	    key: 'writers',
	    get: function get() {
	      return this.acl.w || [];
	    }
	  }, {
	    key: 'readerGroups',
	    get: function get() {
	      return this.acl.groups ? this.acl.groups.r : [];
	    }
	  }, {
	    key: 'writerGroups',
	    get: function get() {
	      return this.acl.groups ? this.acl.groups.w : [];
	    }
	  }, {
	    key: 'globallyReadable',
	    set: function set(gr) {
	      this.acl.gr = gr || false;
	    }
	  }, {
	    key: 'globallyWritable',
	    set: function set(gw) {
	      this.acl.gw = gw || false;
	    }
	  }]);

	  return Acl;
	}();
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 436 */
/***/ function(module, exports, __webpack_require__) {

	var baseClone = __webpack_require__(253);

	/**
	 * Creates a shallow clone of `value`.
	 *
	 * **Note:** This method is loosely based on the
	 * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
	 * and supports cloning arrays, array buffers, booleans, date objects, maps,
	 * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
	 * arrays. The own enumerable properties of `arguments` objects are cloned
	 * as plain objects. An empty object is returned for uncloneable values such
	 * as error objects, functions, DOM nodes, and WeakMaps.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to clone.
	 * @returns {*} Returns the cloned value.
	 * @see _.cloneDeep
	 * @example
	 *
	 * var objects = [{ 'a': 1 }, { 'b': 2 }];
	 *
	 * var shallow = _.clone(objects);
	 * console.log(shallow[0] === objects[0]);
	 * // => true
	 */
	function clone(value) {
	  return baseClone(value, false, true);
	}

	module.exports = clone;


/***/ },
/* 437 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Metadata = undefined;

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _errors = __webpack_require__(11);

	var _clone = __webpack_require__(436);

	var _clone2 = _interopRequireDefault(_clone);

	var _isPlainObject = __webpack_require__(224);

	var _isPlainObject2 = _interopRequireDefault(_isPlainObject);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var kmdAttribute = process && process.env && process.env.KINVEY_KMD_ATTRIBUTE || '_kmd' || '_kmd';

	/**
	 * The Metadata class is used to as a wrapper for accessing the `_kmd` properties of an entity.
	 */

	var Metadata = exports.Metadata = function () {
	  function Metadata() {
	    var entity = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

	    _classCallCheck(this, Metadata);

	    if (!(0, _isPlainObject2.default)(entity)) {
	      throw new _errors.KinveyError('entity argument must be an object');
	    }

	    /**
	     * The kmd properties.
	     *
	     * @private
	     * @type {Object}
	     */
	    this.kmd = (0, _clone2.default)(entity[kmdAttribute] || {});
	  }

	  _createClass(Metadata, [{
	    key: 'isLocal',
	    value: function isLocal() {
	      return !!this.kmd.local;
	    }
	  }, {
	    key: 'toPlainObject',
	    value: function toPlainObject() {
	      return this.kmd;
	    }
	  }, {
	    key: 'toJSON',
	    value: function toJSON() {
	      return this.toPlainObject();
	    }
	  }, {
	    key: 'createdAt',
	    get: function get() {
	      if (this.kmd.ect) {
	        return Date.parse(this.kmd.ect);
	      }

	      return undefined;
	    }
	  }, {
	    key: 'ect',
	    get: function get() {
	      return this.createdAt;
	    }
	  }, {
	    key: 'emailVerification',
	    get: function get() {
	      return this.kmd.emailVerification.status;
	    }
	  }, {
	    key: 'lastModified',
	    get: function get() {
	      if (this.kmd.lmt) {
	        return Date.parse(this.kmd.lmt);
	      }

	      return undefined;
	    }
	  }, {
	    key: 'lmt',
	    get: function get() {
	      return this.lastModified;
	    }
	  }, {
	    key: 'authtoken',
	    get: function get() {
	      return this.kmd.authtoken;
	    },
	    set: function set(authtoken) {
	      this.kmd.authtoken = authtoken;
	    }
	  }]);

	  return Metadata;
	}();
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 438 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.User = undefined;

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // eslint-disable-line no-unused-vars


	var _client = __webpack_require__(10);

	var _acl = __webpack_require__(435);

	var _metadata = __webpack_require__(437);

	var _request = __webpack_require__(219);

	var _errors = __webpack_require__(11);

	var _datastore = __webpack_require__(430);

	var _social = __webpack_require__(411);

	var _utils = __webpack_require__(13);

	var _promise = __webpack_require__(286);

	var _promise2 = _interopRequireDefault(_promise);

	var _regeneratorRuntime = __webpack_require__(148);

	var _regeneratorRuntime2 = _interopRequireDefault(_regeneratorRuntime);

	var _url = __webpack_require__(206);

	var _url2 = _interopRequireDefault(_url);

	var _assign = __webpack_require__(211);

	var _assign2 = _interopRequireDefault(_assign);

	var _result = __webpack_require__(428);

	var _result2 = _interopRequireDefault(_result);

	var _isString = __webpack_require__(217);

	var _isString2 = _interopRequireDefault(_isString);

	var _isObject = __webpack_require__(32);

	var _isObject2 = _interopRequireDefault(_isObject);

	var _isEmpty = __webpack_require__(359);

	var _isEmpty2 = _interopRequireDefault(_isEmpty);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new _promise2.default(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return _promise2.default.resolve(value).then(function (value) { return step("next", value); }, function (err) { return step("throw", err); }); } } return step("next"); }); }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var usersNamespace = process && process.env && process.env.KINVEY_USERS_NAMESPACE || 'user' || 'user';
	var rpcNamespace = process && process.env && process.env.KINVEY_RPC_NAMESPACE || 'rpc' || 'rpc';
	var idAttribute = process && process.env && process.env.KINVEY_ID_ATTRIBUTE || '_id' || '_id';
	var kmdAttribute = process && process.env && process.env.KINVEY_KMD_ATTRIBUTE || '_kmd' || '_kmd';
	var socialIdentityAttribute = process && process.env && process.env.KINVEY_SOCIAL_IDENTITY_ATTRIBUTE || '_socialIdentity' || '_socialIdentity';
	var usernameAttribute = process && process.env && process.env.KINVEY_USERNAME_ATTRIBUTE || 'username' || 'username';
	var emailAttribute = process && process.env && process.env.KINVEY_EMAIL_ATTRIBUTE || 'email' || 'email';

	/**
	 * The User class is used to represent a single user on the Kinvey platform.
	 * Use the user class to manage the active user lifecycle and perform user operations.
	 */

	var User = exports.User = function () {
	  /**
	   * Create a new instance of a User.
	   *
	   * @param {Object} [data={}] Data for the user.
	   * @param {Object} [options={}] Options.
	   * @return {User} User
	   */
	  function User() {
	    var data = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	    _classCallCheck(this, User);

	    /**
	     * The users data.
	     *
	     * @type {Object}
	     */
	    this.data = data;

	    /**
	     * @private
	     * The client used by this user.
	     *
	     * @type {Client}
	     */
	    this.client = options.client || _client.Client.sharedInstance();
	  }

	  /**
	   * The _id for the user.
	   *
	   * @return {?string} _id
	   */


	  _createClass(User, [{
	    key: 'isActive',


	    /**
	     * Checks if the user is the active user.
	     *
	     * @return {boolean} True the user is the active user otherwise false.
	     */
	    value: function isActive() {
	      var activeUser = User.getActiveUser(this.client);

	      if (activeUser && activeUser[idAttribute] === this[idAttribute]) {
	        return true;
	      }

	      return false;
	    }

	    /**
	     * Checks if the users email is verfified.
	     *
	     * @return {boolean} True if the users email is verified otherwise false.
	     */

	  }, {
	    key: 'isEmailVerified',
	    value: function isEmailVerified() {
	      var status = this.metadata.emailVerification;
	      return status === 'confirmed';
	    }

	    /**
	     * Gets the active user. You can optionally provide a client
	     * to use to lookup the active user.
	     *
	     * @param {Client} [client=Client.sharedInstance()] Client to use to lookup active user.
	     * @return {?User} The active user.
	     */

	  }, {
	    key: 'login',


	    /**
	     * Login using a username or password.
	     *
	     * @param {string|Object} username Username or an object with username and password as properties.
	     * @param {string} [password] Password
	     * @param {Object} [options={}] Options
	     * @return {Promise<User>} The user.
	     */
	    value: function () {
	      var _ref = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee(username, password) {
	        var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

	        var isActiveUser, activeUser, credentials, request, _ref2, data;

	        return _regeneratorRuntime2.default.wrap(function _callee$(_context) {
	          while (1) {
	            switch (_context.prev = _context.next) {
	              case 0:
	                isActiveUser = this.isActive();

	                if (!isActiveUser) {
	                  _context.next = 3;
	                  break;
	                }

	                throw new _errors.ActiveUserError('This user is already the active user.');

	              case 3:
	                activeUser = User.getActiveUser(this.client);

	                if (!activeUser) {
	                  _context.next = 6;
	                  break;
	                }

	                throw new _errors.ActiveUserError('An active user already exists. ' + 'Please logout the active user before you login.');

	              case 6:
	                credentials = username;

	                if ((0, _isObject2.default)(credentials)) {
	                  options = password || {};
	                } else {
	                  credentials = {
	                    username: username,
	                    password: password
	                  };
	                }

	                if (!credentials[socialIdentityAttribute]) {
	                  if (credentials.username) {
	                    credentials.username = String(credentials.username).trim();
	                  }

	                  if (credentials.password) {
	                    credentials.password = String(credentials.password).trim();
	                  }
	                }

	                if (!((!credentials.username || credentials.username === '' || !credentials.password || credentials.password === '') && !credentials[socialIdentityAttribute])) {
	                  _context.next = 11;
	                  break;
	                }

	                throw new _errors.KinveyError('Username and/or password missing. ' + 'Please provide both a username and password to login.');

	              case 11:
	                request = new _request.KinveyRequest({
	                  method: _request.RequestMethod.POST,
	                  authType: _request.AuthType.App,
	                  url: _url2.default.format({
	                    protocol: this.client.apiProtocol,
	                    host: this.client.apiHost,
	                    pathname: this.pathname + '/login'
	                  }),
	                  body: credentials,
	                  properties: options.properties,
	                  timeout: options.timeout,
	                  client: this.client
	                });
	                _context.next = 14;
	                return request.execute();

	              case 14:
	                _ref2 = _context.sent;
	                data = _ref2.data;

	                this.data = data;
	                (0, _utils.setActiveUser)(this.client, this.data);
	                return _context.abrupt('return', this);

	              case 19:
	              case 'end':
	                return _context.stop();
	            }
	          }
	        }, _callee, this);
	      }));

	      function login(_x3, _x4, _x5) {
	        return _ref.apply(this, arguments);
	      }

	      return login;
	    }()

	    /**
	     * Login using a username or password.
	     *
	     * @param {string|Object} username Username or an object with username and password as properties.
	     * @param {string} [password] Password
	     * @param {Object} [options={}] Options
	     * @return {Promise<User>} The user.
	     */

	  }, {
	    key: 'loginWithMIC',


	    /**
	     * Login using Mobile Identity Connect.
	     *
	     * @param {string} redirectUri The redirect uri.
	     * @param {AuthorizationGrant} [authorizationGrant=AuthoizationGrant.AuthorizationCodeLoginPage] MIC authorization grant to use.
	     * @param {Object} [options] Options
	     * @return {Promise<User>} The user.
	     */
	    value: function () {
	      var _ref3 = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee2(redirectUri, authorizationGrant) {
	        var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];
	        var isActiveUser, activeUser, mic, session;
	        return _regeneratorRuntime2.default.wrap(function _callee2$(_context2) {
	          while (1) {
	            switch (_context2.prev = _context2.next) {
	              case 0:
	                isActiveUser = this.isActive();

	                if (!isActiveUser) {
	                  _context2.next = 3;
	                  break;
	                }

	                throw new _errors.ActiveUserError('This user is already the active user.');

	              case 3:
	                activeUser = User.getActiveUser(this.client);

	                if (!activeUser) {
	                  _context2.next = 6;
	                  break;
	                }

	                throw new _errors.ActiveUserError('An active user already exists. ' + 'Please logout the active user before you login.');

	              case 6:
	                mic = new _social.MobileIdentityConnect({ client: this.client });
	                _context2.next = 9;
	                return mic.login(redirectUri, authorizationGrant, options);

	              case 9:
	                session = _context2.sent;
	                return _context2.abrupt('return', this.connectIdentity(_social.MobileIdentityConnect.identity, session, options));

	              case 11:
	              case 'end':
	                return _context2.stop();
	            }
	          }
	        }, _callee2, this);
	      }));

	      function loginWithMIC(_x7, _x8, _x9) {
	        return _ref3.apply(this, arguments);
	      }

	      return loginWithMIC;
	    }()

	    /**
	     * Login using Mobile Identity Connect.
	     *
	     * @param {string} redirectUri The redirect uri.
	     * @param {AuthorizationGrant} [authorizationGrant=AuthoizationGrant.AuthorizationCodeLoginPage] MIC authorization grant to use.
	     * @param {Object} [options] Options
	     * @return {Promise<User>} The user.
	     */

	  }, {
	    key: 'connectIdentity',


	    /**
	     * Connect a social identity.
	     *
	     * @param {string} identity Social identity.
	     * @param {Object} session Social identity session.
	     * @param {Object} [options] Options
	     * @return {Promise<User>} The user.
	     */
	    value: function () {
	      var _ref4 = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee3(identity, session, options) {
	        var data, socialIdentity, isActive;
	        return _regeneratorRuntime2.default.wrap(function _callee3$(_context3) {
	          while (1) {
	            switch (_context3.prev = _context3.next) {
	              case 0:
	                data = this.data;
	                socialIdentity = data[socialIdentityAttribute] || {};

	                socialIdentity[identity] = session;
	                data[socialIdentityAttribute] = socialIdentity;
	                this.data = data;

	                _context3.prev = 5;
	                isActive = this.isActive();

	                if (!isActive) {
	                  _context3.next = 9;
	                  break;
	                }

	                return _context3.abrupt('return', this.update(data, options));

	              case 9:
	                _context3.next = 11;
	                return this.login(data, options);

	              case 11:
	                (0, _utils.setIdentitySession)(this.client, identity, session);
	                return _context3.abrupt('return', this);

	              case 15:
	                _context3.prev = 15;
	                _context3.t0 = _context3['catch'](5);

	                if (!(_context3.t0 instanceof _errors.NotFoundError)) {
	                  _context3.next = 21;
	                  break;
	                }

	                _context3.next = 20;
	                return this.signup(data, options);

	              case 20:
	                return _context3.abrupt('return', this.connectIdentity(identity, session, options));

	              case 21:
	                throw _context3.t0;

	              case 22:
	              case 'end':
	                return _context3.stop();
	            }
	          }
	        }, _callee3, this, [[5, 15]]);
	      }));

	      function connectIdentity(_x11, _x12, _x13) {
	        return _ref4.apply(this, arguments);
	      }

	      return connectIdentity;
	    }()

	    /**
	     * Connect a social identity.
	     *
	     * @param {string} identity Social identity.
	     * @param {Object} session Social identity session.
	     * @param {Object} [options] Options
	     * @return {Promise<User>} The user.
	     */

	  }, {
	    key: 'connectWithIdentity',


	    /**
	     * Connect an social identity.
	     *
	     * @deprecated Use connectIdentity().
	     *
	     * @param {string} identity Social identity.
	     * @param {Object} session Social identity session.
	     * @param {Object} [options] Options
	     * @return {Promise<User>} The user.
	     */
	    value: function () {
	      var _ref5 = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee4(identity, session, options) {
	        return _regeneratorRuntime2.default.wrap(function _callee4$(_context4) {
	          while (1) {
	            switch (_context4.prev = _context4.next) {
	              case 0:
	                return _context4.abrupt('return', this.connectIdentity(identity, session, options));

	              case 1:
	              case 'end':
	                return _context4.stop();
	            }
	          }
	        }, _callee4, this);
	      }));

	      function connectWithIdentity(_x14, _x15, _x16) {
	        return _ref5.apply(this, arguments);
	      }

	      return connectWithIdentity;
	    }()

	    /**
	     * Connect a Facebook identity.
	     *
	     * @param  {Object}         [options]     Options
	     * @return {Promise<User>}                The user.
	     */

	  }, {
	    key: 'connectFacebook',
	    value: function () {
	      var _ref6 = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee5(clientId, options) {
	        var facebook, session;
	        return _regeneratorRuntime2.default.wrap(function _callee5$(_context5) {
	          while (1) {
	            switch (_context5.prev = _context5.next) {
	              case 0:
	                facebook = new _social.Facebook({ client: this.client });
	                _context5.next = 3;
	                return facebook.login(clientId, options);

	              case 3:
	                session = _context5.sent;
	                return _context5.abrupt('return', this.connectIdentity(_social.Facebook.identity, session, options));

	              case 5:
	              case 'end':
	                return _context5.stop();
	            }
	          }
	        }, _callee5, this);
	      }));

	      function connectFacebook(_x17, _x18) {
	        return _ref6.apply(this, arguments);
	      }

	      return connectFacebook;
	    }()

	    /**
	     * Connect a Facebook identity.
	     *
	     * @param  {Object}         [options]     Options
	     * @return {Promise<User>}                The user.
	     */

	  }, {
	    key: 'disconnectFacebook',


	    /**
	     * Diconnect a Facebook identity.
	     *
	     * @param  {Object}         [options]     Options
	     * @return {Promise<User>}                The user.
	     */
	    value: function () {
	      var _ref7 = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee6(options) {
	        return _regeneratorRuntime2.default.wrap(function _callee6$(_context6) {
	          while (1) {
	            switch (_context6.prev = _context6.next) {
	              case 0:
	                return _context6.abrupt('return', this.disconnectIdentity(_social.Facebook.identity, options));

	              case 1:
	              case 'end':
	                return _context6.stop();
	            }
	          }
	        }, _callee6, this);
	      }));

	      function disconnectFacebook(_x19) {
	        return _ref7.apply(this, arguments);
	      }

	      return disconnectFacebook;
	    }()

	    /**
	     * Connect a Google identity.
	     *
	     * @param  {Object}         [options]     Options
	     * @return {Promise<User>}                The user.
	     */

	  }, {
	    key: 'connectGoogle',
	    value: function () {
	      var _ref8 = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee7(clientId, options) {
	        var google, session;
	        return _regeneratorRuntime2.default.wrap(function _callee7$(_context7) {
	          while (1) {
	            switch (_context7.prev = _context7.next) {
	              case 0:
	                google = new _social.Google({ client: this.client });
	                _context7.next = 3;
	                return google.login(clientId, options);

	              case 3:
	                session = _context7.sent;
	                return _context7.abrupt('return', this.connectIdentity(_social.Google.identity, session, options));

	              case 5:
	              case 'end':
	                return _context7.stop();
	            }
	          }
	        }, _callee7, this);
	      }));

	      function connectGoogle(_x20, _x21) {
	        return _ref8.apply(this, arguments);
	      }

	      return connectGoogle;
	    }()

	    /**
	     * Connect a Google identity.
	     *
	     * @param  {Object}         [options]     Options
	     * @return {Promise<User>}                The user.
	     */

	  }, {
	    key: 'disconnectGoogle',


	    /**
	     * Diconnect a Google identity.
	     *
	     * @param  {Object}         [options]     Options
	     * @return {Promise<User>}                The user.
	     */
	    value: function () {
	      var _ref9 = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee8(options) {
	        return _regeneratorRuntime2.default.wrap(function _callee8$(_context8) {
	          while (1) {
	            switch (_context8.prev = _context8.next) {
	              case 0:
	                return _context8.abrupt('return', this.disconnectIdentity(_social.Google.identity, options));

	              case 1:
	              case 'end':
	                return _context8.stop();
	            }
	          }
	        }, _callee8, this);
	      }));

	      function disconnectGoogle(_x22) {
	        return _ref9.apply(this, arguments);
	      }

	      return disconnectGoogle;
	    }()

	    /**
	     * Connect a LinkedIn identity.
	     *
	     * @param  {Object}         [options]     Options
	     * @return {Promise<User>}                The user.
	     */

	  }, {
	    key: 'connectLinkedIn',
	    value: function () {
	      var _ref10 = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee9(clientId, options) {
	        var linkedIn, session;
	        return _regeneratorRuntime2.default.wrap(function _callee9$(_context9) {
	          while (1) {
	            switch (_context9.prev = _context9.next) {
	              case 0:
	                linkedIn = new _social.LinkedIn({ client: this.client });
	                _context9.next = 3;
	                return linkedIn.login(clientId, options);

	              case 3:
	                session = _context9.sent;
	                return _context9.abrupt('return', this.connectIdentity(_social.LinkedIn.identity, session, options));

	              case 5:
	              case 'end':
	                return _context9.stop();
	            }
	          }
	        }, _callee9, this);
	      }));

	      function connectLinkedIn(_x23, _x24) {
	        return _ref10.apply(this, arguments);
	      }

	      return connectLinkedIn;
	    }()

	    /**
	     * Connect a LinkedIn identity.
	     *
	     * @param  {Object}         [options]     Options
	     * @return {Promise<User>}                The user.
	     */

	  }, {
	    key: 'disconnectLinkedIn',


	    /**
	     * Diconnect a LinkedIn identity.
	     *
	     * @param  {Object}         [options]     Options
	     * @return {Promise<User>}                The user.
	     */
	    value: function () {
	      var _ref11 = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee10(options) {
	        return _regeneratorRuntime2.default.wrap(function _callee10$(_context10) {
	          while (1) {
	            switch (_context10.prev = _context10.next) {
	              case 0:
	                return _context10.abrupt('return', this.disconnectIdentity(_social.LinkedIn.identity, options));

	              case 1:
	              case 'end':
	                return _context10.stop();
	            }
	          }
	        }, _callee10, this);
	      }));

	      function disconnectLinkedIn(_x25) {
	        return _ref11.apply(this, arguments);
	      }

	      return disconnectLinkedIn;
	    }()

	    /**
	     * @private
	     * Disconnects the user from an identity.
	     *
	     * @param {SocialIdentity|string} identity Identity used to connect the user.
	     * @param  {Object} [options] Options
	     * @return {Promise<User>} The user.
	     */

	  }, {
	    key: 'disconnectIdentity',
	    value: function () {
	      var _ref12 = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee11(identity, options) {
	        var data, socialIdentity;
	        return _regeneratorRuntime2.default.wrap(function _callee11$(_context11) {
	          while (1) {
	            switch (_context11.prev = _context11.next) {
	              case 0:
	                _context11.prev = 0;

	                if (!(identity === _social.Facebook.identity)) {
	                  _context11.next = 6;
	                  break;
	                }

	                _context11.next = 4;
	                return _social.Facebook.logout(this, options);

	              case 4:
	                _context11.next = 19;
	                break;

	              case 6:
	                if (!(identity === _social.Google.identity)) {
	                  _context11.next = 11;
	                  break;
	                }

	                _context11.next = 9;
	                return _social.Google.logout(this, options);

	              case 9:
	                _context11.next = 19;
	                break;

	              case 11:
	                if (!(identity === _social.LinkedIn.identity)) {
	                  _context11.next = 16;
	                  break;
	                }

	                _context11.next = 14;
	                return _social.LinkedIn.logout(this, options);

	              case 14:
	                _context11.next = 19;
	                break;

	              case 16:
	                if (!(identity === _social.MobileIdentityConnect.identity)) {
	                  _context11.next = 19;
	                  break;
	                }

	                _context11.next = 19;
	                return _social.MobileIdentityConnect.logout(this, options);

	              case 19:

	                (0, _utils.setIdentitySession)(this.client, identity, null);
	                _context11.next = 25;
	                break;

	              case 22:
	                _context11.prev = 22;
	                _context11.t0 = _context11['catch'](0);

	                _utils.Log.error(_context11.t0);

	              case 25:
	                data = this.data;
	                socialIdentity = data[socialIdentityAttribute] || {};

	                delete socialIdentity[identity];
	                data[socialIdentityAttribute] = socialIdentity;
	                this.data = data;

	                if (this[idAttribute]) {
	                  _context11.next = 32;
	                  break;
	                }

	                return _context11.abrupt('return', this);

	              case 32:
	                _context11.next = 34;
	                return this.update(data, options);

	              case 34:
	                return _context11.abrupt('return', this);

	              case 35:
	              case 'end':
	                return _context11.stop();
	            }
	          }
	        }, _callee11, this, [[0, 22]]);
	      }));

	      function disconnectIdentity(_x26, _x27) {
	        return _ref12.apply(this, arguments);
	      }

	      return disconnectIdentity;
	    }()

	    /**
	     * Logout the active user.
	     *
	     * @param {Object} [options={}] Options
	     * @return {Promise<User>} The user.
	     */

	  }, {
	    key: 'logout',
	    value: function () {
	      var _ref13 = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee12() {
	        var _this = this;

	        var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	        var request, identities, promises;
	        return _regeneratorRuntime2.default.wrap(function _callee12$(_context12) {
	          while (1) {
	            switch (_context12.prev = _context12.next) {
	              case 0:
	                _context12.prev = 0;
	                request = new _request.KinveyRequest({
	                  method: _request.RequestMethod.POST,
	                  authType: _request.AuthType.Session,
	                  url: _url2.default.format({
	                    protocol: this.client.apiProtocol,
	                    host: this.client.apiHost,
	                    pathname: this.pathname + '/_logout'
	                  }),
	                  properties: options.properties,
	                  timeout: options.timeout,
	                  client: this.client
	                });
	                _context12.next = 4;
	                return request.execute();

	              case 4:
	                _context12.next = 9;
	                break;

	              case 6:
	                _context12.prev = 6;
	                _context12.t0 = _context12['catch'](0);

	                _utils.Log.error(_context12.t0);

	              case 9:
	                _context12.prev = 9;
	                identities = Object.keys(this._socialIdentity || {});
	                promises = identities.map(function (identity) {
	                  return _this.disconnectIdentity(identity, options);
	                });
	                _context12.next = 14;
	                return _promise2.default.all(promises);

	              case 14:
	                _context12.next = 19;
	                break;

	              case 16:
	                _context12.prev = 16;
	                _context12.t1 = _context12['catch'](9);

	                _utils.Log.error(_context12.t1);

	              case 19:

	                (0, _utils.setActiveUser)(this.client, null);
	                _context12.next = 22;
	                return _datastore.DataStore.clearCache({ client: this.client });

	              case 22:
	                return _context12.abrupt('return', this);

	              case 23:
	              case 'end':
	                return _context12.stop();
	            }
	          }
	        }, _callee12, this, [[0, 6], [9, 16]]);
	      }));

	      function logout(_x28) {
	        return _ref13.apply(this, arguments);
	      }

	      return logout;
	    }()

	    /**
	     * Logout the active user.
	     *
	     * @param {Object} [options={}] Options
	     * @return {Promise<User>} The user.
	     */

	  }, {
	    key: 'signup',


	    /**
	     * Sign up a user with Kinvey.
	     *
	     * @param {?User|?Object} data Users data.
	     * @param {Object} [options] Options
	     * @param {boolean} [options.state=true] If set to true, the user will be set as the active user after successfully
	     *                                       being signed up.
	     * @return {Promise<User>} The user.
	     */
	    value: function () {
	      var _ref14 = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee13(data) {
	        var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
	        var activeUser, request, response;
	        return _regeneratorRuntime2.default.wrap(function _callee13$(_context13) {
	          while (1) {
	            switch (_context13.prev = _context13.next) {
	              case 0:
	                options = (0, _assign2.default)({
	                  state: true
	                }, options);

	                if (!(options.state === true)) {
	                  _context13.next = 5;
	                  break;
	                }

	                activeUser = User.getActiveUser(this.client);

	                if (!activeUser) {
	                  _context13.next = 5;
	                  break;
	                }

	                throw new _errors.ActiveUserError('An active user already exists.' + ' Please logout the active user before you login.');

	              case 5:

	                if (data instanceof User) {
	                  data = data.data;
	                }

	                request = new _request.KinveyRequest({
	                  method: _request.RequestMethod.POST,
	                  authType: _request.AuthType.App,
	                  url: _url2.default.format({
	                    protocol: this.client.protocol,
	                    host: this.client.host,
	                    pathname: this.pathname
	                  }),
	                  body: (0, _isEmpty2.default)(data) ? null : data,
	                  properties: options.properties,
	                  timeout: options.timeout,
	                  client: this.client
	                });
	                _context13.next = 9;
	                return request.execute();

	              case 9:
	                response = _context13.sent;

	                this.data = response.data;

	                if (options.state === true) {
	                  (0, _utils.setActiveUser)(this.client, this.data);
	                }

	                return _context13.abrupt('return', this);

	              case 13:
	              case 'end':
	                return _context13.stop();
	            }
	          }
	        }, _callee13, this);
	      }));

	      function signup(_x30, _x31) {
	        return _ref14.apply(this, arguments);
	      }

	      return signup;
	    }()

	    /**
	     * Sign up a user with Kinvey.
	     *
	     * @param {User|Object} data Users data.
	     * @param {Object} [options] Options
	     * @param {boolean} [options.state=true] If set to true, the user will be set as the active user after successfully
	     *                                       being signed up.
	     * @return {Promise<User>} The user.
	     */

	  }, {
	    key: 'signupWithIdentity',


	    /**
	     * Sign up a user with Kinvey using an identity.
	     *
	     * @param {SocialIdentity|string} identity The identity.
	     * @param {Object} session Identity session
	     * @param {Object} [options] Options
	     * @param {boolean} [options.state=true] If set to true, the user will be set as the active user after successfully
	     *                                       being signed up.
	     * @return {Promise<User>} The user.
	     */
	    value: function signupWithIdentity(identity, session, options) {
	      var data = {};
	      data[socialIdentityAttribute] = {};
	      data[socialIdentityAttribute][identity] = session;
	      return this.signup(data, options);
	    }

	    /**
	     * Sign up a user with Kinvey using an identity.
	     *
	     * @param {SocialIdentity|string} identity The identity.
	     * @param {Object} session Identity session
	     * @param {Object} [options] Options
	     * @param {boolean} [options.state=true] If set to true, the user will be set as the active user after successfully
	     *                                       being signed up.
	     * @return {Promise<User>} The user.
	     */

	  }, {
	    key: 'update',


	    /**
	     * Update the users data.
	     *
	     * @param {Object} data Data.
	     * @param {Object} [options] Options
	     * @return {Promise<User>} The user.
	     */
	    value: function () {
	      var _ref15 = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee14(data, options) {
	        var userStore;
	        return _regeneratorRuntime2.default.wrap(function _callee14$(_context14) {
	          while (1) {
	            switch (_context14.prev = _context14.next) {
	              case 0:
	                data = (0, _assign2.default)(this.data, data);
	                userStore = new _datastore.UserStore();
	                _context14.next = 4;
	                return userStore.update(data, options);

	              case 4:

	                if (this.isActive()) {
	                  (0, _utils.setActiveUser)(this.client, this.data);
	                }

	                return _context14.abrupt('return', this);

	              case 6:
	              case 'end':
	                return _context14.stop();
	            }
	          }
	        }, _callee14, this);
	      }));

	      function update(_x33, _x34) {
	        return _ref15.apply(this, arguments);
	      }

	      return update;
	    }()

	    /**
	     * Update the active user.
	     *
	     * @param {Object} data Data.
	     * @param {Object} [options] Options
	     * @return {Promise<User>} The user.
	     */

	  }, {
	    key: 'me',


	    /**
	     * Retfresh the users data.
	     *
	     * @param {Object} [options={}] Options
	     * @return {Promise<User>} The user.
	     */
	    value: function () {
	      var _ref16 = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee15() {
	        var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

	        var request, _ref17, data, activeUser;

	        return _regeneratorRuntime2.default.wrap(function _callee15$(_context15) {
	          while (1) {
	            switch (_context15.prev = _context15.next) {
	              case 0:
	                request = new _request.KinveyRequest({
	                  method: _request.RequestMethod.GET,
	                  authType: _request.AuthType.Session,
	                  url: _url2.default.format({
	                    protocol: this.client.protocol,
	                    host: this.client.host,
	                    pathname: this.pathname + '/_me'
	                  }),
	                  properties: options.properties,
	                  timeout: options.timeout
	                });
	                _context15.next = 3;
	                return request.execute();

	              case 3:
	                _ref17 = _context15.sent;
	                data = _ref17.data;

	                this.data = data;

	                if (!this.authtoken) {
	                  activeUser = User.getActiveUser(this.client);


	                  if (activeUser) {
	                    this.authtoken = activeUser.authtoken;
	                  }
	                }

	                (0, _utils.setActiveUser)(this.client, this.data);
	                return _context15.abrupt('return', this);

	              case 9:
	              case 'end':
	                return _context15.stop();
	            }
	          }
	        }, _callee15, this);
	      }));

	      function me(_x35) {
	        return _ref16.apply(this, arguments);
	      }

	      return me;
	    }()

	    /**
	     * Refresh the active user.
	     *
	     * @param {Object} [options={}] Options
	     * @return {Promise<User>} The user.
	     */

	  }, {
	    key: 'verifyEmail',


	    /**
	     * Request an email to be sent to verify the users email.
	     *
	     * @deprecated Use the static function verifyEmail().
	     *
	     * @param {Object} [options={}] Options
	     * @return {Promise<Object>} The response.
	     */
	    value: function () {
	      var _ref18 = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee16() {
	        var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	        return _regeneratorRuntime2.default.wrap(function _callee16$(_context16) {
	          while (1) {
	            switch (_context16.prev = _context16.next) {
	              case 0:
	                options.client = this.client;
	                return _context16.abrupt('return', User.verifyEmail(this.username, options));

	              case 2:
	              case 'end':
	                return _context16.stop();
	            }
	          }
	        }, _callee16, this);
	      }));

	      function verifyEmail(_x37) {
	        return _ref18.apply(this, arguments);
	      }

	      return verifyEmail;
	    }()

	    /**
	     * Request an email to be sent to verify the users email.
	     *
	     * @param {string} username Username
	     * @param {Object} [options={}] Options
	     * @return {Promise<Object>} The response.
	     */

	  }, {
	    key: 'forgotUsername',


	    /**
	     * Request an email to be sent to recover a forgot username.
	     *
	     * @deprecated Use the static function forgotUsername().
	     *
	     * @param {Object} [options={}] Options
	     * @return {Promise<Object>} The response.
	     */
	    value: function () {
	      var _ref19 = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee17() {
	        var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	        return _regeneratorRuntime2.default.wrap(function _callee17$(_context17) {
	          while (1) {
	            switch (_context17.prev = _context17.next) {
	              case 0:
	                options.client = this.client;
	                return _context17.abrupt('return', User.forgotUsername(this.email, options));

	              case 2:
	              case 'end':
	                return _context17.stop();
	            }
	          }
	        }, _callee17, this);
	      }));

	      function forgotUsername(_x39) {
	        return _ref19.apply(this, arguments);
	      }

	      return forgotUsername;
	    }()

	    /**
	     * Request an email to be sent to recover a forgot username.
	     *
	     * @param {string} email Email
	     * @param {Object} [options={}] Options
	     * @return {Promise<Object>} The response.
	     */

	  }, {
	    key: 'resetPassword',


	    /**
	     * Request an email to be sent to reset the users password.
	     *
	     * @deprecated Use the static function resetPassword().
	     *
	     * @param {Object} [options = {}] Options
	     * @return {Promise<Object>} The response.
	     */
	    value: function resetPassword() {
	      var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

	      options.client = this.client;
	      return User.resetPassword(this.username, options);
	    }

	    /**
	     * Request an email to be sent to reset a users password.
	     *
	     * @param {string} username Username
	     * @param {Object} [options={}] Options
	     * @return {Promise<Object>} The response.
	     */

	  }, {
	    key: '_id',
	    get: function get() {
	      return this.data[idAttribute];
	    }

	    /**
	     * The _acl for the user.
	     *
	     * @return {Acl} _acl
	     */

	  }, {
	    key: '_acl',
	    get: function get() {
	      return new _acl.Acl(this.data);
	    }

	    /**
	     * The metadata for the user.
	     *
	     * @return {Metadata} metadata
	     */

	  }, {
	    key: 'metadata',
	    get: function get() {
	      return new _metadata.Metadata(this.data);
	    }

	    /**
	     * Set the metadata for the user.
	     *
	     * @param {Metadata|Object} metadata The metadata.
	     */
	    ,
	    set: function set(metadata) {
	      this.data[kmdAttribute] = (0, _result2.default)(metadata, 'toPlainObjecta', metadata);
	    }

	    /**
	     * The _kmd for the user.
	     *
	     * @return {Metadata} _kmd
	     */

	  }, {
	    key: '_kmd',
	    get: function get() {
	      return this.metadata;
	    }

	    /**
	     * Set the _kmd for the user.
	     *
	     * @param {Metadata|Object} metadata The metadata.
	     */
	    ,
	    set: function set(kmd) {
	      this.metadata = kmd;
	    }

	    /**
	     * The _socialIdentity for the user.
	     *
	     * @return {Object} _socialIdentity
	     */

	  }, {
	    key: '_socialIdentity',
	    get: function get() {
	      return this.data[socialIdentityAttribute];
	    }

	    /**
	     * The auth token for the user.
	     *
	     * @return {?string} Auth token
	     */

	  }, {
	    key: 'authtoken',
	    get: function get() {
	      return this.metadata.authtoken;
	    }

	    /**
	     * Set the auth token for the user.
	     *
	     * @param  {?string} authtoken Auth token
	     */
	    ,
	    set: function set(authtoken) {
	      var metadata = this.metadata;
	      metadata.authtoken = authtoken;
	      this.metadata = metadata;
	    }

	    /**
	     * The username for the user.
	     *
	     * @return {?string} Username
	     */

	  }, {
	    key: 'username',
	    get: function get() {
	      return this.data[usernameAttribute];
	    }

	    /**
	     * The email for the user.
	     *
	     * @return {?string} Email
	     */

	  }, {
	    key: 'email',
	    get: function get() {
	      return this.data[emailAttribute];
	    }

	    /**
	     * @private
	     */

	  }, {
	    key: 'pathname',
	    get: function get() {
	      return '/' + usersNamespace + '/' + this.client.appKey;
	    }
	  }], [{
	    key: 'getActiveUser',
	    value: function getActiveUser() {
	      var client = arguments.length <= 0 || arguments[0] === undefined ? _client.Client.sharedInstance() : arguments[0];

	      var data = client.activeUser;
	      var user = null;

	      if (data) {
	        user = new this(data);
	        user.client = client;
	      }

	      return user;
	    }
	  }, {
	    key: 'login',
	    value: function login(username, password, options) {
	      var user = new this({}, options);
	      return user.login(username, password, options);
	    }
	  }, {
	    key: 'loginWithMIC',
	    value: function loginWithMIC(redirectUri, authorizationGrant) {
	      var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

	      var user = new this({}, options);
	      return user.loginWithMIC(redirectUri, authorizationGrant, options);
	    }
	  }, {
	    key: 'connectIdentity',
	    value: function connectIdentity(identity, session, options) {
	      var user = new this({}, options);
	      return user.connectIdentity(identity, session, options);
	    }
	  }, {
	    key: 'connectFacebook',
	    value: function connectFacebook(clientId, options) {
	      var user = new this({}, options);
	      return user.connectFacebook(clientId, options);
	    }
	  }, {
	    key: 'connectGoogle',
	    value: function connectGoogle(clientId, options) {
	      var user = new this({}, options);
	      return user.connectGoogle(clientId, options);
	    }
	  }, {
	    key: 'connectLinkedIn',
	    value: function connectLinkedIn(clientId, options) {
	      var user = new this({}, options);
	      return user.connectLinkedIn(clientId, options);
	    }
	  }, {
	    key: 'logout',
	    value: function () {
	      var _ref20 = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee18() {
	        var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	        var user;
	        return _regeneratorRuntime2.default.wrap(function _callee18$(_context18) {
	          while (1) {
	            switch (_context18.prev = _context18.next) {
	              case 0:
	                user = User.getActiveUser(options.client);

	                if (!user) {
	                  _context18.next = 3;
	                  break;
	                }

	                return _context18.abrupt('return', user.logout(options));

	              case 3:
	                return _context18.abrupt('return', null);

	              case 4:
	              case 'end':
	                return _context18.stop();
	            }
	          }
	        }, _callee18, this);
	      }));

	      function logout(_x44) {
	        return _ref20.apply(this, arguments);
	      }

	      return logout;
	    }()
	  }, {
	    key: 'signup',
	    value: function signup(data, options) {
	      var user = new this({}, options);
	      return user.signup(data, options);
	    }
	  }, {
	    key: 'signupWithIdentity',
	    value: function signupWithIdentity(identity, session, options) {
	      var user = new this({}, options);
	      return user.signupWithIdentity(identity, session, options);
	    }
	  }, {
	    key: 'update',
	    value: function () {
	      var _ref21 = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee19(data, options) {
	        var user;
	        return _regeneratorRuntime2.default.wrap(function _callee19$(_context19) {
	          while (1) {
	            switch (_context19.prev = _context19.next) {
	              case 0:
	                user = User.getActiveUser(options.client);

	                if (!user) {
	                  _context19.next = 3;
	                  break;
	                }

	                return _context19.abrupt('return', user.update(data, options));

	              case 3:
	                return _context19.abrupt('return', null);

	              case 4:
	              case 'end':
	                return _context19.stop();
	            }
	          }
	        }, _callee19, this);
	      }));

	      function update(_x46, _x47) {
	        return _ref21.apply(this, arguments);
	      }

	      return update;
	    }()
	  }, {
	    key: 'me',
	    value: function () {
	      var _ref22 = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee20(options) {
	        var user;
	        return _regeneratorRuntime2.default.wrap(function _callee20$(_context20) {
	          while (1) {
	            switch (_context20.prev = _context20.next) {
	              case 0:
	                user = User.getActiveUser(options.client);

	                if (!user) {
	                  _context20.next = 3;
	                  break;
	                }

	                return _context20.abrupt('return', user.me(options));

	              case 3:
	                return _context20.abrupt('return', null);

	              case 4:
	              case 'end':
	                return _context20.stop();
	            }
	          }
	        }, _callee20, this);
	      }));

	      function me(_x48) {
	        return _ref22.apply(this, arguments);
	      }

	      return me;
	    }()
	  }, {
	    key: 'verifyEmail',
	    value: function () {
	      var _ref23 = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee21(username) {
	        var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	        var client, request, _ref24, data;

	        return _regeneratorRuntime2.default.wrap(function _callee21$(_context21) {
	          while (1) {
	            switch (_context21.prev = _context21.next) {
	              case 0:
	                if (username) {
	                  _context21.next = 2;
	                  break;
	                }

	                throw new _errors.KinveyError('A username was not provided.', 'Please provide a username for the user that you would like to verify their email.');

	              case 2:
	                if ((0, _isString2.default)(username)) {
	                  _context21.next = 4;
	                  break;
	                }

	                throw new _errors.KinveyError('The provided username is not a string.');

	              case 4:
	                client = options.client || _client.Client.sharedInstance();
	                request = new _request.KinveyRequest({
	                  method: _request.RequestMethod.POST,
	                  authType: _request.AuthType.App,
	                  url: _url2.default.format({
	                    protocol: client.protocol,
	                    host: client.host,
	                    pathname: '/' + rpcNamespace + '/' + client.appKey + '/' + username + '/user-email-verification-initiate'
	                  }),
	                  properties: options.properties,
	                  timeout: options.timeout,
	                  client: client
	                });
	                _context21.next = 8;
	                return request.execute();

	              case 8:
	                _ref24 = _context21.sent;
	                data = _ref24.data;
	                return _context21.abrupt('return', data);

	              case 11:
	              case 'end':
	                return _context21.stop();
	            }
	          }
	        }, _callee21, this);
	      }));

	      function verifyEmail(_x49, _x50) {
	        return _ref23.apply(this, arguments);
	      }

	      return verifyEmail;
	    }()
	  }, {
	    key: 'forgotUsername',
	    value: function () {
	      var _ref25 = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee22(email) {
	        var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	        var client, request, _ref26, data;

	        return _regeneratorRuntime2.default.wrap(function _callee22$(_context22) {
	          while (1) {
	            switch (_context22.prev = _context22.next) {
	              case 0:
	                if (email) {
	                  _context22.next = 2;
	                  break;
	                }

	                throw new _errors.KinveyError('An email was not provided.', 'Please provide an email for the user that you would like to retrieve their username.');

	              case 2:
	                if ((0, _isString2.default)(email)) {
	                  _context22.next = 4;
	                  break;
	                }

	                throw new _errors.KinveyError('The provided email is not a string.');

	              case 4:
	                client = options.client || _client.Client.sharedInstance();
	                request = new _request.KinveyRequest({
	                  method: _request.RequestMethod.POST,
	                  authType: _request.AuthType.App,
	                  url: _url2.default.format({
	                    protocol: client.protocol,
	                    host: client.host,
	                    pathname: '/' + rpcNamespace + '/' + client.appKey + '/user-forgot-username'
	                  }),
	                  properties: options.properties,
	                  data: { email: email },
	                  timeout: options.timeout,
	                  client: client
	                });
	                _context22.next = 8;
	                return request.execute();

	              case 8:
	                _ref26 = _context22.sent;
	                data = _ref26.data;
	                return _context22.abrupt('return', data);

	              case 11:
	              case 'end':
	                return _context22.stop();
	            }
	          }
	        }, _callee22, this);
	      }));

	      function forgotUsername(_x52, _x53) {
	        return _ref25.apply(this, arguments);
	      }

	      return forgotUsername;
	    }()
	  }, {
	    key: 'resetPassword',
	    value: function () {
	      var _ref27 = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee23(username) {
	        var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	        var client, request, _ref28, data;

	        return _regeneratorRuntime2.default.wrap(function _callee23$(_context23) {
	          while (1) {
	            switch (_context23.prev = _context23.next) {
	              case 0:
	                if (username) {
	                  _context23.next = 2;
	                  break;
	                }

	                throw new _errors.KinveyError('A username was not provided.', 'Please provide a username for the user that you would like to reset their password.');

	              case 2:
	                if ((0, _isString2.default)(username)) {
	                  _context23.next = 4;
	                  break;
	                }

	                throw new _errors.KinveyError('The provided username is not a string.');

	              case 4:
	                client = options.client || _client.Client.sharedInstance();
	                request = new _request.KinveyRequest({
	                  method: _request.RequestMethod.POST,
	                  authType: _request.AuthType.App,
	                  url: _url2.default.format({
	                    protocol: client.protocol,
	                    host: client.host,
	                    pathname: '/' + rpcNamespace + '/' + client.appKey + '/' + username + '/user-password-reset-initiate'
	                  }),
	                  properties: options.properties,
	                  timeout: options.timeout,
	                  client: client
	                });
	                _context23.next = 8;
	                return request.execute();

	              case 8:
	                _ref28 = _context23.sent;
	                data = _ref28.data;
	                return _context23.abrupt('return', data);

	              case 11:
	              case 'end':
	                return _context23.stop();
	            }
	          }
	        }, _callee23, this);
	      }));

	      function resetPassword(_x55, _x56) {
	        return _ref27.apply(this, arguments);
	      }

	      return resetPassword;
	    }()

	    /**
	     * Check if a username already exists.
	     *
	     * @param {string} username Username
	     * @param {Object} [options] Options
	     * @return {boolean} True if the username already exists otherwise false.
	     */

	  }, {
	    key: 'exists',
	    value: function exists(username, options) {
	      var store = new _datastore.UserStore(options);
	      return store.exists(username, options);
	    }

	    /**
	     * Restore a user that has been suspended.
	     *
	     * @param {string} id Id of the user to restore.
	     * @param {Object} [options] Options
	     * @return {Promise<Object>} The response.
	     */

	  }, {
	    key: 'restore',
	    value: function restore(id, options) {
	      var store = new _datastore.UserStore(options);
	      return store.restore(id, options);
	    }
	  }]);

	  return User;
	}();
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 439 */
/***/ function(module, exports, __webpack_require__) {

	var baseDifference = __webpack_require__(440),
	    baseFlatten = __webpack_require__(442),
	    baseIteratee = __webpack_require__(42),
	    baseRest = __webpack_require__(151),
	    isArrayLikeObject = __webpack_require__(29),
	    last = __webpack_require__(444);

	/**
	 * This method is like `_.difference` except that it accepts `iteratee` which
	 * is invoked for each element of `array` and `values` to generate the criterion
	 * by which they're compared. The order and references of result values are
	 * determined by the first array. The iteratee is invoked with one argument:
	 * (value).
	 *
	 * **Note:** Unlike `_.pullAllBy`, this method returns a new array.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Array
	 * @param {Array} array The array to inspect.
	 * @param {...Array} [values] The values to exclude.
	 * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	 * @returns {Array} Returns the new array of filtered values.
	 * @example
	 *
	 * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);
	 * // => [1.2]
	 *
	 * // The `_.property` iteratee shorthand.
	 * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');
	 * // => [{ 'x': 2 }]
	 */
	var differenceBy = baseRest(function(array, values) {
	  var iteratee = last(values);
	  if (isArrayLikeObject(iteratee)) {
	    iteratee = undefined;
	  }
	  return isArrayLikeObject(array)
	    ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), baseIteratee(iteratee, 2))
	    : [];
	});

	module.exports = differenceBy;


/***/ },
/* 440 */
/***/ function(module, exports, __webpack_require__) {

	var SetCache = __webpack_require__(86),
	    arrayIncludes = __webpack_require__(187),
	    arrayIncludesWith = __webpack_require__(441),
	    arrayMap = __webpack_require__(281),
	    baseUnary = __webpack_require__(105),
	    cacheHas = __webpack_require__(90);

	/** Used as the size to enable large array optimizations. */
	var LARGE_ARRAY_SIZE = 200;

	/**
	 * The base implementation of methods like `_.difference` without support
	 * for excluding multiple arrays or iteratee shorthands.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {Array} values The values to exclude.
	 * @param {Function} [iteratee] The iteratee invoked per element.
	 * @param {Function} [comparator] The comparator invoked per element.
	 * @returns {Array} Returns the new array of filtered values.
	 */
	function baseDifference(array, values, iteratee, comparator) {
	  var index = -1,
	      includes = arrayIncludes,
	      isCommon = true,
	      length = array.length,
	      result = [],
	      valuesLength = values.length;

	  if (!length) {
	    return result;
	  }
	  if (iteratee) {
	    values = arrayMap(values, baseUnary(iteratee));
	  }
	  if (comparator) {
	    includes = arrayIncludesWith;
	    isCommon = false;
	  }
	  else if (values.length >= LARGE_ARRAY_SIZE) {
	    includes = cacheHas;
	    isCommon = false;
	    values = new SetCache(values);
	  }
	  outer:
	  while (++index < length) {
	    var value = array[index],
	        computed = iteratee ? iteratee(value) : value;

	    value = (comparator || value !== 0) ? value : 0;
	    if (isCommon && computed === computed) {
	      var valuesIndex = valuesLength;
	      while (valuesIndex--) {
	        if (values[valuesIndex] === computed) {
	          continue outer;
	        }
	      }
	      result.push(value);
	    }
	    else if (!includes(values, computed, comparator)) {
	      result.push(value);
	    }
	  }
	  return result;
	}

	module.exports = baseDifference;


/***/ },
/* 441 */
/***/ function(module, exports) {

	/**
	 * This function is like `arrayIncludes` except that it accepts a comparator.
	 *
	 * @private
	 * @param {Array} [array] The array to inspect.
	 * @param {*} target The value to search for.
	 * @param {Function} comparator The comparator invoked per element.
	 * @returns {boolean} Returns `true` if `target` is found, else `false`.
	 */
	function arrayIncludesWith(array, value, comparator) {
	  var index = -1,
	      length = array ? array.length : 0;

	  while (++index < length) {
	    if (comparator(value, array[index])) {
	      return true;
	    }
	  }
	  return false;
	}

	module.exports = arrayIncludesWith;


/***/ },
/* 442 */
/***/ function(module, exports, __webpack_require__) {

	var arrayPush = __webpack_require__(261),
	    isFlattenable = __webpack_require__(443);

	/**
	 * The base implementation of `_.flatten` with support for restricting flattening.
	 *
	 * @private
	 * @param {Array} array The array to flatten.
	 * @param {number} depth The maximum recursion depth.
	 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
	 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
	 * @param {Array} [result=[]] The initial result value.
	 * @returns {Array} Returns the new flattened array.
	 */
	function baseFlatten(array, depth, predicate, isStrict, result) {
	  var index = -1,
	      length = array.length;

	  predicate || (predicate = isFlattenable);
	  result || (result = []);

	  while (++index < length) {
	    var value = array[index];
	    if (depth > 0 && predicate(value)) {
	      if (depth > 1) {
	        // Recursively flatten arrays (susceptible to call stack limits).
	        baseFlatten(value, depth - 1, predicate, isStrict, result);
	      } else {
	        arrayPush(result, value);
	      }
	    } else if (!isStrict) {
	      result[result.length] = value;
	    }
	  }
	  return result;
	}

	module.exports = baseFlatten;


/***/ },
/* 443 */
/***/ function(module, exports, __webpack_require__) {

	var Symbol = __webpack_require__(92),
	    isArguments = __webpack_require__(28),
	    isArray = __webpack_require__(35);

	/** Built-in value references. */
	var spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;

	/**
	 * Checks if `value` is a flattenable `arguments` object or array.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
	 */
	function isFlattenable(value) {
	  return isArray(value) || isArguments(value) ||
	    !!(spreadableSymbol && value && value[spreadableSymbol]);
	}

	module.exports = isFlattenable;


/***/ },
/* 444 */
/***/ function(module, exports) {

	/**
	 * Gets the last element of `array`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Array
	 * @param {Array} array The array to query.
	 * @returns {*} Returns the last element of `array`.
	 * @example
	 *
	 * _.last([1, 2, 3]);
	 * // => 3
	 */
	function last(array) {
	  var length = array ? array.length : 0;
	  return length ? array[length - 1] : undefined;
	}

	module.exports = last;


/***/ },
/* 445 */
/***/ function(module, exports, __webpack_require__) {

	var arrayFilter = __webpack_require__(446),
	    baseFilter = __webpack_require__(447),
	    baseIteratee = __webpack_require__(42),
	    isArray = __webpack_require__(35);

	/**
	 * Iterates over elements of `collection`, returning an array of all elements
	 * `predicate` returns truthy for. The predicate is invoked with three
	 * arguments: (value, index|key, collection).
	 *
	 * **Note:** Unlike `_.remove`, this method returns a new array.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Collection
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function} [predicate=_.identity]
	 *  The function invoked per iteration.
	 * @returns {Array} Returns the new filtered array.
	 * @see _.reject
	 * @example
	 *
	 * var users = [
	 *   { 'user': 'barney', 'age': 36, 'active': true },
	 *   { 'user': 'fred',   'age': 40, 'active': false }
	 * ];
	 *
	 * _.filter(users, function(o) { return !o.active; });
	 * // => objects for ['fred']
	 *
	 * // The `_.matches` iteratee shorthand.
	 * _.filter(users, { 'age': 36, 'active': true });
	 * // => objects for ['barney']
	 *
	 * // The `_.matchesProperty` iteratee shorthand.
	 * _.filter(users, ['active', false]);
	 * // => objects for ['fred']
	 *
	 * // The `_.property` iteratee shorthand.
	 * _.filter(users, 'active');
	 * // => objects for ['barney']
	 */
	function filter(collection, predicate) {
	  var func = isArray(collection) ? arrayFilter : baseFilter;
	  return func(collection, baseIteratee(predicate, 3));
	}

	module.exports = filter;


/***/ },
/* 446 */
/***/ function(module, exports) {

	/**
	 * A specialized version of `_.filter` for arrays without support for
	 * iteratee shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} predicate The function invoked per iteration.
	 * @returns {Array} Returns the new filtered array.
	 */
	function arrayFilter(array, predicate) {
	  var index = -1,
	      length = array ? array.length : 0,
	      resIndex = 0,
	      result = [];

	  while (++index < length) {
	    var value = array[index];
	    if (predicate(value, index, array)) {
	      result[resIndex++] = value;
	    }
	  }
	  return result;
	}

	module.exports = arrayFilter;


/***/ },
/* 447 */
/***/ function(module, exports, __webpack_require__) {

	var baseEach = __webpack_require__(21);

	/**
	 * The base implementation of `_.filter` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function} predicate The function invoked per iteration.
	 * @returns {Array} Returns the new filtered array.
	 */
	function baseFilter(collection, predicate) {
	  var result = [];
	  baseEach(collection, function(value, index, collection) {
	    if (predicate(value, index, collection)) {
	      result.push(value);
	    }
	  });
	  return result;
	}

	module.exports = baseFilter;


/***/ },
/* 448 */
/***/ function(module, exports, __webpack_require__) {

	var arrayFilter = __webpack_require__(446),
	    baseRest = __webpack_require__(151),
	    baseXor = __webpack_require__(449),
	    isArrayLikeObject = __webpack_require__(29),
	    last = __webpack_require__(444);

	/**
	 * This method is like `_.xor` except that it accepts `comparator` which is
	 * invoked to compare elements of `arrays`. The order of result values is
	 * determined by the order they occur in the arrays. The comparator is invoked
	 * with two arguments: (arrVal, othVal).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Array
	 * @param {...Array} [arrays] The arrays to inspect.
	 * @param {Function} [comparator] The comparator invoked per element.
	 * @returns {Array} Returns the new array of filtered values.
	 * @example
	 *
	 * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
	 * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
	 *
	 * _.xorWith(objects, others, _.isEqual);
	 * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
	 */
	var xorWith = baseRest(function(arrays) {
	  var comparator = last(arrays);
	  if (isArrayLikeObject(comparator)) {
	    comparator = undefined;
	  }
	  return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined, comparator);
	});

	module.exports = xorWith;


/***/ },
/* 449 */
/***/ function(module, exports, __webpack_require__) {

	var arrayPush = __webpack_require__(261),
	    baseDifference = __webpack_require__(440),
	    baseUniq = __webpack_require__(450);

	/**
	 * The base implementation of methods like `_.xor`, without support for
	 * iteratee shorthands, that accepts an array of arrays to inspect.
	 *
	 * @private
	 * @param {Array} arrays The arrays to inspect.
	 * @param {Function} [iteratee] The iteratee invoked per element.
	 * @param {Function} [comparator] The comparator invoked per element.
	 * @returns {Array} Returns the new array of values.
	 */
	function baseXor(arrays, iteratee, comparator) {
	  var index = -1,
	      length = arrays.length;

	  while (++index < length) {
	    var result = result
	      ? arrayPush(
	          baseDifference(result, arrays[index], iteratee, comparator),
	          baseDifference(arrays[index], result, iteratee, comparator)
	        )
	      : arrays[index];
	  }
	  return (result && result.length) ? baseUniq(result, iteratee, comparator) : [];
	}

	module.exports = baseXor;


/***/ },
/* 450 */
/***/ function(module, exports, __webpack_require__) {

	var SetCache = __webpack_require__(86),
	    arrayIncludes = __webpack_require__(187),
	    arrayIncludesWith = __webpack_require__(441),
	    cacheHas = __webpack_require__(90),
	    createSet = __webpack_require__(451),
	    setToArray = __webpack_require__(95);

	/** Used as the size to enable large array optimizations. */
	var LARGE_ARRAY_SIZE = 200;

	/**
	 * The base implementation of `_.uniqBy` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {Function} [iteratee] The iteratee invoked per element.
	 * @param {Function} [comparator] The comparator invoked per element.
	 * @returns {Array} Returns the new duplicate free array.
	 */
	function baseUniq(array, iteratee, comparator) {
	  var index = -1,
	      includes = arrayIncludes,
	      length = array.length,
	      isCommon = true,
	      result = [],
	      seen = result;

	  if (comparator) {
	    isCommon = false;
	    includes = arrayIncludesWith;
	  }
	  else if (length >= LARGE_ARRAY_SIZE) {
	    var set = iteratee ? null : createSet(array);
	    if (set) {
	      return setToArray(set);
	    }
	    isCommon = false;
	    includes = cacheHas;
	    seen = new SetCache;
	  }
	  else {
	    seen = iteratee ? [] : result;
	  }
	  outer:
	  while (++index < length) {
	    var value = array[index],
	        computed = iteratee ? iteratee(value) : value;

	    value = (comparator || value !== 0) ? value : 0;
	    if (isCommon && computed === computed) {
	      var seenIndex = seen.length;
	      while (seenIndex--) {
	        if (seen[seenIndex] === computed) {
	          continue outer;
	        }
	      }
	      if (iteratee) {
	        seen.push(computed);
	      }
	      result.push(value);
	    }
	    else if (!includes(seen, computed, comparator)) {
	      if (seen !== result) {
	        seen.push(computed);
	      }
	      result.push(value);
	    }
	  }
	  return result;
	}

	module.exports = baseUniq;


/***/ },
/* 451 */
/***/ function(module, exports, __webpack_require__) {

	var Set = __webpack_require__(100),
	    noop = __webpack_require__(175),
	    setToArray = __webpack_require__(95);

	/** Used as references for various `Number` constants. */
	var INFINITY = 1 / 0;

	/**
	 * Creates a set object of `values`.
	 *
	 * @private
	 * @param {Array} values The values to add to the set.
	 * @returns {Object} Returns the new set.
	 */
	var createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {
	  return new Set(values);
	};

	module.exports = createSet;


/***/ },
/* 452 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.DataStore = exports.DataStoreType = undefined;

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // eslint-disable-line no-unused-vars


	var _request = __webpack_require__(219);

	var _errors = __webpack_require__(11);

	var _client = __webpack_require__(10);

	var _networkstore = __webpack_require__(432);

	var _cachestore = __webpack_require__(431);

	var _syncstore = __webpack_require__(453);

	var _regeneratorRuntime = __webpack_require__(148);

	var _regeneratorRuntime2 = _interopRequireDefault(_regeneratorRuntime);

	var _url = __webpack_require__(206);

	var _url2 = _interopRequireDefault(_url);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { return step("next", value); }, function (err) { return step("throw", err); }); } } return step("next"); }); }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var appdataNamespace = process && process.env && process.env.KINVEY_DATASTORE_NAMESPACE || 'appdata' || 'appdata';

	/**
	 * @typedef   {Object}    DataStoreType
	 * @property  {string}    Cache           Cache datastore type
	 * @property  {string}    Network         Network datastore type
	 * @property  {string}    Sync            Sync datastore type
	 */
	var DataStoreType = {
	  Cache: 'Cache',
	  Network: 'Network',
	  Sync: 'Sync'
	};
	Object.freeze(DataStoreType);
	exports.DataStoreType = DataStoreType;

	/**
	 * The DataStore class is used to find, create, update, remove, count and group entities.
	 */

	var DataStore = function () {
	  function DataStore() {
	    _classCallCheck(this, DataStore);

	    throw new _errors.KinveyError('Not allowed to construct a DataStore instance.' + ' Please use the collection() function to retrieve an instance of a DataStore instance.');
	  }

	  /**
	   * Returns an instance of the Store class based on the type provided.
	   *
	   * @param  {string}       [collection]                  Name of the collection.
	   * @param  {StoreType}    [type=DataStoreType.Network]  Type of store to return.
	   * @return {DataStore}                                  DataStore instance.
	   */


	  _createClass(DataStore, null, [{
	    key: 'collection',
	    value: function collection(_collection) {
	      var type = arguments.length <= 1 || arguments[1] === undefined ? DataStoreType.Cache : arguments[1];
	      var options = arguments[2];

	      var store = void 0;

	      if (!_collection) {
	        throw new _errors.KinveyError('A collection is required.');
	      }

	      switch (type) {
	        case DataStoreType.Network:
	          store = new _networkstore.NetworkStore(_collection, options);
	          break;
	        case DataStoreType.Sync:
	          store = new _syncstore.SyncStore(_collection, options);
	          break;
	        case DataStoreType.Cache:
	        default:
	          store = new _cachestore.CacheStore(_collection, options);

	      }

	      return store;
	    }

	    /**
	     * @private
	     */

	  }, {
	    key: 'getInstance',
	    value: function getInstance(collection, type, options) {
	      return this.collection(collection, type, options);
	    }

	    /**
	     * Clear the cache. This will delete all data in the cache.
	     *
	     * @param  {Object} [options={}] Options
	     * @return {Promise<Object>} The result of clearing the cache.
	     */

	  }, {
	    key: 'clearCache',
	    value: function () {
	      var _ref = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee() {
	        var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	        var client, pathname, request, response;
	        return _regeneratorRuntime2.default.wrap(function _callee$(_context) {
	          while (1) {
	            switch (_context.prev = _context.next) {
	              case 0:
	                client = options.client || _client.Client.sharedInstance();
	                pathname = '/' + appdataNamespace + '/' + client.appKey;
	                request = new _request.CacheRequest({
	                  method: _request.RequestMethod.DELETE,
	                  url: _url2.default.format({
	                    protocol: client.protocol,
	                    host: client.host,
	                    pathname: pathname,
	                    query: options.query
	                  }),
	                  properties: options.properties,
	                  timeout: options.timeout
	                });
	                _context.next = 5;
	                return request.execute();

	              case 5:
	                response = _context.sent;
	                return _context.abrupt('return', response.data);

	              case 7:
	              case 'end':
	                return _context.stop();
	            }
	          }
	        }, _callee, this);
	      }));

	      function clearCache(_x2) {
	        return _ref.apply(this, arguments);
	      }

	      return clearCache;
	    }()
	  }]);

	  return DataStore;
	}();

	exports.DataStore = DataStore;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 453 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.SyncStore = undefined;

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _cachestore = __webpack_require__(431);

	var _request = __webpack_require__(219);

	var _errors = __webpack_require__(11);

	var _query = __webpack_require__(422);

	var _utils = __webpack_require__(13);

	var _regeneratorRuntime = __webpack_require__(148);

	var _regeneratorRuntime2 = _interopRequireDefault(_regeneratorRuntime);

	var _url = __webpack_require__(206);

	var _url2 = _interopRequireDefault(_url);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { return step("next", value); }, function (err) { return step("throw", err); }); } } return step("next"); }); }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // eslint-disable-line no-unused-vars


	/**
	 * The SyncStore class is used to find, create, update, remove, count and group entities. Entities are stored
	 * in a cache and synced with the backend.
	 */
	var SyncStore = exports.SyncStore = function (_CacheStore) {
	  _inherits(SyncStore, _CacheStore);

	  function SyncStore() {
	    _classCallCheck(this, SyncStore);

	    return _possibleConstructorReturn(this, (SyncStore.__proto__ || Object.getPrototypeOf(SyncStore)).apply(this, arguments));
	  }

	  _createClass(SyncStore, [{
	    key: 'find',


	    /**
	     * Find all entities in the data store. A query can be optionally provided to return
	     * a subset of all entities in a collection or omitted to return all entities in
	     * a collection. The number of entities returned adheres to the limits specified
	     * at http://devcenter.kinvey.com/rest/guides/datastore#queryrestrictions.
	     *
	     * @param   {Query}                 [query]                             Query used to filter entities.
	     * @param   {Object}                [options]                           Options
	     * @param   {Properties}            [options.properties]                Custom properties to send with
	     *                                                                      the request.
	     * @param   {Number}                [options.timeout]                   Timeout for the request.
	     * @param   {Boolean}               [options.useDeltaFetch]             Turn on or off the use of delta fetch.
	     * @return  {Observable}                                                Observable.
	     */
	    value: function find(query) {
	      var _this2 = this;

	      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	      var stream = _utils.KinveyObservable.create(function () {
	        var _ref = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee(observer) {
	          var entities, request, response;
	          return _regeneratorRuntime2.default.wrap(function _callee$(_context) {
	            while (1) {
	              switch (_context.prev = _context.next) {
	                case 0:
	                  _context.prev = 0;
	                  entities = [];

	                  // Check that the query is valid

	                  if (!(query && !(query instanceof _query.Query))) {
	                    _context.next = 4;
	                    break;
	                  }

	                  throw new _errors.KinveyError('Invalid query. It must be an instance of the Query class.');

	                case 4:

	                  // Fetch the cache entities
	                  request = new _request.CacheRequest({
	                    method: _request.RequestMethod.GET,
	                    url: _url2.default.format({
	                      protocol: _this2.client.protocol,
	                      host: _this2.client.host,
	                      pathname: _this2.pathname,
	                      query: options.query
	                    }),
	                    properties: options.properties,
	                    query: query,
	                    timeout: options.timeout
	                  });

	                  // Execute the request

	                  _context.next = 7;
	                  return request.execute();

	                case 7:
	                  response = _context.sent;

	                  entities = response.data;

	                  // Emit the cache entities
	                  observer.next(entities);
	                  _context.next = 15;
	                  break;

	                case 12:
	                  _context.prev = 12;
	                  _context.t0 = _context['catch'](0);

	                  observer.error(_context.t0);

	                case 15:
	                  return _context.abrupt('return', observer.complete());

	                case 16:
	                case 'end':
	                  return _context.stop();
	              }
	            }
	          }, _callee, _this2, [[0, 12]]);
	        }));

	        return function (_x2) {
	          return _ref.apply(this, arguments);
	        };
	      }());

	      return stream;
	    }

	    /**
	     * Find a single entity in the data store by id.
	     *
	     * @param   {string}                id                               Entity by id to find.
	     * @param   {Object}                [options]                        Options
	     * @param   {Properties}            [options.properties]             Custom properties to send with
	     *                                                                   the request.
	     * @param   {Number}                [options.timeout]                Timeout for the request.
	     * @param   {Boolean}               [options.useDeltaFetch]          Turn on or off the use of delta fetch.
	     * @return  {Observable}                                             Observable.
	     */

	  }, {
	    key: 'findById',
	    value: function findById(id) {
	      var _this3 = this;

	      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	      var stream = _utils.KinveyObservable.create(function () {
	        var _ref2 = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee2(observer) {
	          var request, response, entity;
	          return _regeneratorRuntime2.default.wrap(function _callee2$(_context2) {
	            while (1) {
	              switch (_context2.prev = _context2.next) {
	                case 0:
	                  _context2.prev = 0;

	                  // Fetch from the cache
	                  request = new _request.CacheRequest({
	                    method: _request.RequestMethod.GET,
	                    url: _url2.default.format({
	                      protocol: _this3.client.protocol,
	                      host: _this3.client.host,
	                      pathname: _this3.pathname + '/' + id,
	                      query: options.query
	                    }),
	                    properties: options.properties,
	                    timeout: options.timeout
	                  });
	                  _context2.next = 4;
	                  return request.execute();

	                case 4:
	                  response = _context2.sent;
	                  entity = response.data;

	                  // Emit the cache entity

	                  observer.next(entity);
	                  _context2.next = 12;
	                  break;

	                case 9:
	                  _context2.prev = 9;
	                  _context2.t0 = _context2['catch'](0);

	                  observer.error(_context2.t0);

	                case 12:
	                  return _context2.abrupt('return', observer.complete());

	                case 13:
	                case 'end':
	                  return _context2.stop();
	              }
	            }
	          }, _callee2, _this3, [[0, 9]]);
	        }));

	        return function (_x4) {
	          return _ref2.apply(this, arguments);
	        };
	      }());

	      return stream;
	    }

	    /**
	     * Count all entities in the data store. A query can be optionally provided to return
	     * a subset of all entities in a collection or omitted to return all entities in
	     * a collection. The number of entities returned adheres to the limits specified
	     * at http://devcenter.kinvey.com/rest/guides/datastore#queryrestrictions.
	     *
	     * @param   {Query}                 [query]                          Query used to filter entities.
	     * @param   {Object}                [options]                        Options
	     * @param   {Properties}            [options.properties]             Custom properties to send with
	     *                                                                   the request.
	     * @param   {Number}                [options.timeout]                Timeout for the request.
	     * @return  {Observable}                                             Observable.
	     */

	  }, {
	    key: 'count',
	    value: function count(query) {
	      var _this4 = this;

	      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	      var stream = _utils.KinveyObservable.create(function () {
	        var _ref3 = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee3(observer) {
	          var request, response, data;
	          return _regeneratorRuntime2.default.wrap(function _callee3$(_context3) {
	            while (1) {
	              switch (_context3.prev = _context3.next) {
	                case 0:
	                  _context3.prev = 0;

	                  if (!(query && !(query instanceof _query.Query))) {
	                    _context3.next = 3;
	                    break;
	                  }

	                  throw new _errors.KinveyError('Invalid query. It must be an instance of the Query class.');

	                case 3:

	                  // Fetch the entities in the cache
	                  request = new _request.CacheRequest({
	                    method: _request.RequestMethod.GET,
	                    url: _url2.default.format({
	                      protocol: _this4.client.protocol,
	                      host: _this4.client.host,
	                      pathname: _this4.pathname,
	                      query: options.query
	                    }),
	                    properties: options.properties,
	                    query: query,
	                    timeout: options.timeout
	                  });

	                  // Execute the request

	                  _context3.next = 6;
	                  return request.execute();

	                case 6:
	                  response = _context3.sent;
	                  data = response.data;

	                  // Emit the cache count

	                  observer.next(data ? data.length : 0);
	                  _context3.next = 14;
	                  break;

	                case 11:
	                  _context3.prev = 11;
	                  _context3.t0 = _context3['catch'](0);
	                  return _context3.abrupt('return', observer.error(_context3.t0));

	                case 14:
	                  return _context3.abrupt('return', observer.complete());

	                case 15:
	                case 'end':
	                  return _context3.stop();
	              }
	            }
	          }, _callee3, _this4, [[0, 11]]);
	        }));

	        return function (_x6) {
	          return _ref3.apply(this, arguments);
	        };
	      }());

	      return stream;
	    }
	  }, {
	    key: 'syncAutomatically',
	    get: function get() {
	      return false;
	    }
	  }]);

	  return SyncStore;
	}(_cachestore.CacheStore);

/***/ },
/* 454 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.FileStore = undefined;

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _request = __webpack_require__(219);

	var _errors = __webpack_require__(11);

	var _networkstore = __webpack_require__(432);

	var _utils = __webpack_require__(13);

	var _promise = __webpack_require__(286);

	var _promise2 = _interopRequireDefault(_promise);

	var _regeneratorRuntime = __webpack_require__(148);

	var _regeneratorRuntime2 = _interopRequireDefault(_regeneratorRuntime);

	var _url = __webpack_require__(206);

	var _url2 = _interopRequireDefault(_url);

	var _map = __webpack_require__(351);

	var _map2 = _interopRequireDefault(_map);

	var _assign = __webpack_require__(211);

	var _assign2 = _interopRequireDefault(_assign);

	var _isFunction = __webpack_require__(31);

	var _isFunction2 = _interopRequireDefault(_isFunction);

	var _isNumber = __webpack_require__(232);

	var _isNumber2 = _interopRequireDefault(_isNumber);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new _promise2.default(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return _promise2.default.resolve(value).then(function (value) { return step("next", value); }, function (err) { return step("throw", err); }); } } return step("next"); }); }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // eslint-disable-line no-unused-vars


	var idAttribute = process && process.env && process.env.KINVEY_ID_ATTRIBUTE || '_id' || '_id';
	var filesNamespace = process && process.env && process.env.KINVEY_FILES_NAMESPACE || 'blob' || 'blob';
	var MAX_BACKOFF = process && process.env && process.env.KINVEY_MAX_BACKOFF || '32000' || 32 * 1000;

	function randomInt(min, max) {
	  return Math.floor(Math.random() * (max - min)) + min;
	}

	// Calculate where we should start the file upload
	function getStartIndex(rangeHeader, max) {
	  var start = rangeHeader ? parseInt(rangeHeader.split('-')[1], 10) + 1 : 0;
	  return start >= max ? max - 1 : start;
	}

	/**
	 * The FileStore class is used to find, save, update, remove, count and group files.
	 */

	var FileStore = exports.FileStore = function (_NetworkStore) {
	  _inherits(FileStore, _NetworkStore);

	  function FileStore() {
	    _classCallCheck(this, FileStore);

	    return _possibleConstructorReturn(this, (FileStore.__proto__ || Object.getPrototypeOf(FileStore)).apply(this, arguments));
	  }

	  _createClass(FileStore, [{
	    key: 'find',


	    /**
	     * Finds all files. A query can be optionally provided to return
	     * a subset of all the files for your application or omitted to return all the files.
	     * The number of files returned will adhere to the limits specified
	     * at http://devcenter.kinvey.com/rest/guides/datastore#queryrestrictions. A
	     * promise will be returned that will be resolved with the files or rejected with
	     * an error.
	     *
	     * @param   {Query}                 [query]                                   Query used to filter result.
	     * @param   {Object}                [options]                                 Options
	     * @param   {Properties}            [options.properties]                      Custom properties to send with
	     *                                                                            the request.
	     * @param   {Number}                [options.timeout]                         Timeout for the request.
	     * @param   {Boolean}               [options.tls]                             Use Transport Layer Security
	     * @param   {Boolean}               [options.download]                        Download the files
	     * @return  {Promise}                                                         Promise
	     *
	     * @example
	     * var filesStore = new Kinvey.FilesStore();
	     * var query = new Kinvey.Query();
	     * query.equalTo('location', 'Boston');
	     * files.find(query, {
	     *   tls: true, // Use transport layer security
	     *   ttl: 60 * 60 * 24, // 1 day in seconds
	     *   download: true // download the files
	     * }).then(function(files) {
	     *   ...
	     * }).catch(function(err) {
	     *   ...
	     * });
	     */
	    value: function () {
	      var _ref = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee(query) {
	        var _this2 = this;

	        var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
	        var stream, files;
	        return _regeneratorRuntime2.default.wrap(function _callee$(_context) {
	          while (1) {
	            switch (_context.prev = _context.next) {
	              case 0:
	                options.query = options.query || {};
	                options.query.tls = options.tls === true;

	                if ((0, _isNumber2.default)(options.ttl)) {
	                  options.query.ttl_in_seconds = options.ttl;
	                }

	                stream = _get(FileStore.prototype.__proto__ || Object.getPrototypeOf(FileStore.prototype), 'find', this).call(this, query, options);
	                _context.next = 6;
	                return stream.toPromise();

	              case 6:
	                files = _context.sent;

	                if (!(options.download === true)) {
	                  _context.next = 9;
	                  break;
	                }

	                return _context.abrupt('return', _promise2.default.all((0, _map2.default)(files, function (file) {
	                  return _this2.downloadByUrl(file._downloadURL, options);
	                })));

	              case 9:
	                return _context.abrupt('return', files);

	              case 10:
	              case 'end':
	                return _context.stop();
	            }
	          }
	        }, _callee, this);
	      }));

	      function find(_x, _x2) {
	        return _ref.apply(this, arguments);
	      }

	      return find;
	    }()
	  }, {
	    key: 'findById',
	    value: function findById(id, options) {
	      return this.download(id, options);
	    }

	    /**
	     * Download a file.
	     *
	     * @param   {string}        name                                          Name
	     * @param   {Object}        [options]                                     Options
	     * @param   {Boolean}       [options.tls]                                 Use Transport Layer Security
	     * @param   {Number}        [options.ttl]                                 Time To Live (in seconds)
	     * @param   {Boolean}       [options.stream=false]                        Stream the file
	     * @return  {Promise<string>}                                             File content
	     *
	     * @example
	     * var files = new Kinvey.Files();
	     * files.download('Kinvey.png', {
	     *   tls: true, // Use transport layer security
	     *   ttl: 60 * 60 * 24, // 1 day in seconds
	     *   stream: true // stream the file
	     * }).then(function(file) {
	     *   ...
	     * }).catch(function(err) {
	     *   ...
	     * });
	    */

	  }, {
	    key: 'download',
	    value: function () {
	      var _ref2 = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee2(name) {
	        var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
	        var file;
	        return _regeneratorRuntime2.default.wrap(function _callee2$(_context2) {
	          while (1) {
	            switch (_context2.prev = _context2.next) {
	              case 0:
	                options.query = options.query || {};
	                options.query.tls = options.tls === true;

	                if ((0, _isNumber2.default)(options.ttl)) {
	                  options.query.ttl_in_seconds = options.ttl;
	                }

	                _context2.next = 5;
	                return _get(FileStore.prototype.__proto__ || Object.getPrototypeOf(FileStore.prototype), 'findById', this).call(this, name, options).toPromise();

	              case 5:
	                file = _context2.sent;

	                if (!(options.stream === true)) {
	                  _context2.next = 8;
	                  break;
	                }

	                return _context2.abrupt('return', file);

	              case 8:

	                options.mimeType = file.mimeType;
	                return _context2.abrupt('return', this.downloadByUrl(file._downloadURL, options));

	              case 10:
	              case 'end':
	                return _context2.stop();
	            }
	          }
	        }, _callee2, this);
	      }));

	      function download(_x4, _x5) {
	        return _ref2.apply(this, arguments);
	      }

	      return download;
	    }()

	    /**
	     * Download a file using a url.
	     *
	     * @param   {string}        url                                           File download url
	     * @param   {Object}        [options]                                     Options
	     * @return  {Promise<string>}                                             File content.
	    */

	  }, {
	    key: 'downloadByUrl',
	    value: function () {
	      var _ref3 = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee3(url) {
	        var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
	        var request, response;
	        return _regeneratorRuntime2.default.wrap(function _callee3$(_context3) {
	          while (1) {
	            switch (_context3.prev = _context3.next) {
	              case 0:
	                request = new _request.NetworkRequest({
	                  method: _request.RequestMethod.GET,
	                  url: url,
	                  timeout: options.timeout
	                });
	                _context3.next = 3;
	                return request.execute();

	              case 3:
	                response = _context3.sent;
	                return _context3.abrupt('return', response.data);

	              case 5:
	              case 'end':
	                return _context3.stop();
	            }
	          }
	        }, _callee3, this);
	      }));

	      function downloadByUrl(_x7, _x8) {
	        return _ref3.apply(this, arguments);
	      }

	      return downloadByUrl;
	    }()

	    /**
	     * Stream a file. A promise will be returned that will be resolved with the file or rejected with
	     * an error.
	     *
	     * @param   {string}        name                                          File name
	     * @param   {Object}        [options]                                     Options
	     * @param   {Boolean}       [options.tls]                                 Use Transport Layer Security
	     * @param   {Number}        [options.ttl]                                 Time To Live (in seconds)
	     * @param   {DataPolicy}    [options.dataPolicy=DataPolicy.NetworkFirst]    Data policy
	     * @param   {AuthType}      [options.authType=AuthType.Default]           Auth type
	     * @return  {Promise}                                                     Promise
	     *
	     * @example
	     * var files = new Kinvey.Files();
	     * files.stream('BostonTeaParty.png', {
	     *   tls: true, // Use transport layer security
	     *   ttl: 60 * 60 * 24, // 1 day in seconds
	     * }).then(function(file) {
	     *   ...
	     * }).catch(function(err) {
	     *   ...
	     * });
	     */

	  }, {
	    key: 'stream',
	    value: function stream(name) {
	      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	      options.stream = true;
	      return this.download(name, options);
	    }

	    /**
	     * Upload a file.
	     *
	     * @param {Blob|string} file  File content
	     * @param {Object} [metadata={}] File metadata
	     * @param {Object} [options={}] Options
	     * @return {Promise<File>} A file entity.
	     */

	  }, {
	    key: 'upload',
	    value: function () {
	      var _ref4 = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee4(file) {
	        var metadata = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
	        var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];
	        var request, response, data, uploadUrl, headers, statusCheckRequest, statusCheckResponse;
	        return _regeneratorRuntime2.default.wrap(function _callee4$(_context4) {
	          while (1) {
	            switch (_context4.prev = _context4.next) {
	              case 0:
	                // Set defaults for metadata
	                metadata = (0, _assign2.default)({
	                  filename: file._filename || file.name,
	                  public: false,
	                  size: file.size || file.length,
	                  mimeType: file.mimeType || file.type || 'application/octet-stream'
	                }, metadata);
	                metadata._filename = metadata.filename;
	                delete metadata.filename;
	                metadata._public = metadata.public;
	                delete metadata.public;

	                // Create the file on Kinvey
	                request = new _request.KinveyRequest({
	                  method: _request.RequestMethod.POST,
	                  authType: _request.AuthType.Default,
	                  url: _url2.default.format({
	                    protocol: this.client.protocol,
	                    host: this.client.host,
	                    pathname: this.pathname
	                  }),
	                  properties: options.properties,
	                  timeout: options.timeout,
	                  body: metadata,
	                  client: this.client
	                });

	                request.headers.set('X-Kinvey-Content-Type', metadata.mimeType);

	                // If the file metadata contains an _id then
	                // update the file
	                if (metadata[idAttribute]) {
	                  request.method = _request.RequestMethod.PUT;
	                  request.url = _url2.default.format({
	                    protocol: this.client.protocol,
	                    host: this.client.host,
	                    pathname: this.pathname + '/' + metadata._id,
	                    query: options.query
	                  });
	                }

	                // Execute the request
	                _context4.next = 10;
	                return request.execute();

	              case 10:
	                response = _context4.sent;
	                data = response.data;
	                uploadUrl = data._uploadURL;
	                headers = new _request.Headers(data._requiredHeaders);

	                headers.set('content-type', metadata.mimeType);

	                // Delete fields from the response
	                delete data._expiresAt;
	                delete data._requiredHeaders;
	                delete data._uploadURL;

	                // Execute the status check request
	                statusCheckRequest = new _request.NetworkRequest({
	                  method: _request.RequestMethod.PUT,
	                  url: uploadUrl,
	                  timeout: options.timeout
	                });

	                statusCheckRequest.headers.addAll(headers.toPlainObject());
	                statusCheckRequest.headers.set('Content-Length', '0');
	                statusCheckRequest.headers.set('Content-Range', 'bytes */' + metadata.size);
	                _context4.next = 24;
	                return statusCheckRequest.execute(true);

	              case 24:
	                statusCheckResponse = _context4.sent;


	                _utils.Log.debug('File upload status check response', statusCheckResponse);

	                // Upload the file

	                if (!(statusCheckResponse.isSuccess() === false)) {
	                  _context4.next = 34;
	                  break;
	                }

	                if (!(statusCheckResponse.statusCode === _request.StatusCode.ResumeIncomplete)) {
	                  _context4.next = 33;
	                  break;
	                }

	                options.start = getStartIndex(statusCheckResponse.headers.get('range'), metadata.size);
	                _context4.next = 31;
	                return this.uploadToGCS(uploadUrl, headers, file, metadata, options);

	              case 31:
	                _context4.next = 34;
	                break;

	              case 33:
	                throw statusCheckResponse.error;

	              case 34:

	                data._data = file;
	                return _context4.abrupt('return', data);

	              case 36:
	              case 'end':
	                return _context4.stop();
	            }
	          }
	        }, _callee4, this);
	      }));

	      function upload(_x11, _x12, _x13) {
	        return _ref4.apply(this, arguments);
	      }

	      return upload;
	    }()

	    /**
	     * @private
	     */

	  }, {
	    key: 'uploadToGCS',
	    value: function () {
	      var _ref5 = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee5(uploadUrl, headers, file, metadata) {
	        var _this3 = this;

	        var options = arguments.length <= 4 || arguments[4] === undefined ? {} : arguments[4];

	        var fileSlice, fileSliceSize, request, response, _ret;

	        return _regeneratorRuntime2.default.wrap(function _callee5$(_context5) {
	          while (1) {
	            switch (_context5.prev = _context5.next) {
	              case 0:
	                // Set default options
	                options = (0, _assign2.default)({
	                  count: 0,
	                  start: 0,
	                  maxBackoff: MAX_BACKOFF
	                }, options);

	                _utils.Log.debug('Start file upload');
	                _utils.Log.debug('File upload upload url', uploadUrl);
	                _utils.Log.debug('File upload headers', headers.toPlainObject());
	                _utils.Log.debug('File upload file', file);
	                _utils.Log.debug('File upload metadata', metadata);
	                _utils.Log.debug('File upload options', options);

	                // Get slice of file to upload
	                fileSlice = (0, _isFunction2.default)(file.slice) ? file.slice(options.start) : file;
	                fileSliceSize = fileSlice.size || fileSlice.length;

	                // Execute the file upload request

	                request = new _request.NetworkRequest({
	                  method: _request.RequestMethod.PUT,
	                  url: uploadUrl,
	                  body: fileSlice,
	                  timeout: options.timeout
	                });

	                request.headers.addAll(headers.toPlainObject());
	                request.headers.set('content-length', fileSliceSize);
	                request.headers.set('content-range', 'bytes ' + options.start + '-' + (metadata.size - 1) + '/' + metadata.size);
	                _context5.next = 15;
	                return request.execute(true);

	              case 15:
	                response = _context5.sent;


	                _utils.Log.debug('File upload response', response);

	                // If the request was not successful uploading the file
	                // then check if we should try uploading the remaining
	                // portion of the file

	                if (!(response.isSuccess() === false)) {
	                  _context5.next = 29;
	                  break;
	                }

	                if (!(response.statusCode === _request.StatusCode.ResumeIncomplete)) {
	                  _context5.next = 24;
	                  break;
	                }

	                _utils.Log.debug('File upload was incomplete. Trying to upload the remaining protion of the file.');

	                options.start = getStartIndex(response.headers.get('range'), metadata.size);
	                return _context5.abrupt('return', this.uploadToGCS(uploadUrl, headers, file, metadata, options));

	              case 24:
	                if (!(response.statusCode >= 500 && response.statusCode < 600)) {
	                  _context5.next = 28;
	                  break;
	                }

	                _ret = function () {
	                  _utils.Log.debug('File upload error.', response.statusCode);

	                  // Calculate the exponential backoff
	                  var backoff = Math.pow(2, options.count) + randomInt(1000, 1);

	                  // Throw the error if we have excedded the max backoff
	                  if (backoff >= options.maxBackoff) {
	                    throw response.error;
	                  }

	                  _utils.Log.debug('File upload will try again in ' + backoff + ' seconds.');

	                  // Upload the remaining protion of the file after the backoff time has passed
	                  return {
	                    v: new _promise2.default(function (resolve) {
	                      setTimeout(function () {
	                        options.count += 1;
	                        resolve(_this3.uploadToGCS(uploadUrl, headers, file, metadata, options));
	                      }, backoff);
	                    })
	                  };
	                }();

	                if (!((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object")) {
	                  _context5.next = 28;
	                  break;
	                }

	                return _context5.abrupt('return', _ret.v);

	              case 28:
	                throw response.error;

	              case 29:
	                return _context5.abrupt('return', response);

	              case 30:
	              case 'end':
	                return _context5.stop();
	            }
	          }
	        }, _callee5, this);
	      }));

	      function uploadToGCS(_x16, _x17, _x18, _x19, _x20) {
	        return _ref5.apply(this, arguments);
	      }

	      return uploadToGCS;
	    }()

	    /**
	     * @private
	     */

	  }, {
	    key: 'create',
	    value: function create(file, metadata, options) {
	      return this.upload(file, metadata, options);
	    }

	    /**
	     * @private
	     */

	  }, {
	    key: 'update',
	    value: function update(file, metadata, options) {
	      return this.upload(file, metadata, options);
	    }

	    /**
	     * @private
	     */

	  }, {
	    key: 'remove',
	    value: function remove() {
	      throw new _errors.KinveyError('Please use removeById() to remove files one by one.');
	    }
	  }, {
	    key: 'pathname',

	    /**
	     * @private
	     * The pathname for the store.
	     *
	     * @return  {string}  Pathname
	     */
	    get: function get() {
	      return '/' + filesNamespace + '/' + this.client.appKey;
	    }
	  }]);

	  return FileStore;
	}(_networkstore.NetworkStore);
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 455 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.UserStore = undefined;

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _request = __webpack_require__(219);

	var _errors = __webpack_require__(11);

	var _networkstore = __webpack_require__(432);

	var _regeneratorRuntime = __webpack_require__(148);

	var _regeneratorRuntime2 = _interopRequireDefault(_regeneratorRuntime);

	var _url = __webpack_require__(206);

	var _url2 = _interopRequireDefault(_url);

	var _isArray = __webpack_require__(35);

	var _isArray2 = _interopRequireDefault(_isArray);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { return step("next", value); }, function (err) { return step("throw", err); }); } } return step("next"); }); }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // eslint-disable-line no-unused-vars


	var usersNamespace = process && process.env && process.env.KINVEY_USERS_NAMESPACE || 'user' || 'user';
	var rpcNamespace = process && process.env && process.env.KINVEY_RPC_NAMESPACE || 'rpc' || 'rpc';
	var idAttribute = process && process.env && process.env.KINVEY_ID_ATTRIBUTE || '_id' || '_id';

	/**
	 * The UserStore class is used to find, save, update, remove, count and group users.
	 */

	var UserStore = exports.UserStore = function (_NetworkStore) {
	  _inherits(UserStore, _NetworkStore);

	  function UserStore(options) {
	    _classCallCheck(this, UserStore);

	    return _possibleConstructorReturn(this, (UserStore.__proto__ || Object.getPrototypeOf(UserStore)).call(this, null, options));
	  }

	  /**
	   * The pathname for the store.
	   *
	   * @return  {string}   Pathname
	   */


	  _createClass(UserStore, [{
	    key: 'create',


	    /**
	     * @private
	     * @throws {KinveyError} Method is unsupported. Instead use User.signup() to create a user.
	     */
	    value: function () {
	      var _ref = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee() {
	        return _regeneratorRuntime2.default.wrap(function _callee$(_context) {
	          while (1) {
	            switch (_context.prev = _context.next) {
	              case 0:
	                throw new _errors.KinveyError('Please use `User.signup()` to create a user.');

	              case 1:
	              case 'end':
	                return _context.stop();
	            }
	          }
	        }, _callee, this);
	      }));

	      function create() {
	        return _ref.apply(this, arguments);
	      }

	      return create;
	    }()

	    /**
	     * Update a user.
	     *
	     * @deprecated Use the `update` function for a user instance.
	     *
	     * @param {Object} data Data for user to update.
	     * @param {Object} [options={}] Options
	     * @return {Promise<Object>} The updated user data.
	     */

	  }, {
	    key: 'update',
	    value: function () {
	      var _ref2 = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee2(data) {
	        var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
	        return _regeneratorRuntime2.default.wrap(function _callee2$(_context2) {
	          while (1) {
	            switch (_context2.prev = _context2.next) {
	              case 0:
	                if (data) {
	                  _context2.next = 2;
	                  break;
	                }

	                throw new _errors.KinveyError('No user was provided to be updated.');

	              case 2:
	                if (!(0, _isArray2.default)(data)) {
	                  _context2.next = 4;
	                  break;
	                }

	                throw new _errors.KinveyError('Only one user can be updated at one time.', data);

	              case 4:
	                if (data[idAttribute]) {
	                  _context2.next = 6;
	                  break;
	                }

	                throw new _errors.KinveyError('User must have an _id.');

	              case 6:
	                return _context2.abrupt('return', _get(UserStore.prototype.__proto__ || Object.getPrototypeOf(UserStore.prototype), 'update', this).call(this, data, options));

	              case 7:
	              case 'end':
	                return _context2.stop();
	            }
	          }
	        }, _callee2, this);
	      }));

	      function update(_x, _x2) {
	        return _ref2.apply(this, arguments);
	      }

	      return update;
	    }()

	    /**
	     * Check if a username already exists.
	     *
	     * @deprecated Use the `exists` function on the `User` class.
	     *
	     * @param {string} username Username
	     * @param {Object} [options={}] Options
	     * @return {boolean} True if the username already exists otherwise false.
	     */

	  }, {
	    key: 'exists',
	    value: function () {
	      var _ref3 = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee3(username) {
	        var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
	        var request, response, data;
	        return _regeneratorRuntime2.default.wrap(function _callee3$(_context3) {
	          while (1) {
	            switch (_context3.prev = _context3.next) {
	              case 0:
	                request = new _request.KinveyRequest({
	                  method: _request.RequestMethod.POST,
	                  authType: _request.AuthType.App,
	                  url: _url2.default.format({
	                    protocol: this.client.protocol,
	                    host: this.client.host,
	                    pathname: '/' + rpcNamespace + '/' + this.client.appKey + '/check-username-exists'
	                  }),
	                  properties: options.properties,
	                  data: { username: username },
	                  timeout: options.timeout,
	                  client: this.client
	                });
	                _context3.next = 3;
	                return request.execute();

	              case 3:
	                response = _context3.sent;
	                data = response.data || {};
	                return _context3.abrupt('return', data.usernameExists === true);

	              case 6:
	              case 'end':
	                return _context3.stop();
	            }
	          }
	        }, _callee3, this);
	      }));

	      function exists(_x4, _x5) {
	        return _ref3.apply(this, arguments);
	      }

	      return exists;
	    }()

	    /**
	     * Restore a user that has been suspended.
	     *
	     * @deprecated Use the `restore` function on the `User` class.
	     *
	     * @param {string} id Id of the user to restore.
	     * @param {Object} [options={}] Options
	     * @return {Promise<Object>} The response.
	     */

	  }, {
	    key: 'restore',
	    value: function () {
	      var _ref4 = _asyncToGenerator(_regeneratorRuntime2.default.mark(function _callee4(id) {
	        var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
	        var request, response;
	        return _regeneratorRuntime2.default.wrap(function _callee4$(_context4) {
	          while (1) {
	            switch (_context4.prev = _context4.next) {
	              case 0:
	                request = new _request.KinveyRequest({
	                  method: _request.RequestMethod.POST,
	                  authType: _request.AuthType.Master,
	                  url: _url2.default.format({
	                    protocol: this.client.protocol,
	                    host: this.client.host,
	                    pathname: this.pathname + '/' + id
	                  }),
	                  properties: options.properties,
	                  timeout: options.timeout,
	                  client: this.client
	                });
	                _context4.next = 3;
	                return request.execute();

	              case 3:
	                response = _context4.sent;
	                return _context4.abrupt('return', response.data);

	              case 5:
	              case 'end':
	                return _context4.stop();
	            }
	          }
	        }, _callee4, this);
	      }));

	      function restore(_x7, _x8) {
	        return _ref4.apply(this, arguments);
	      }

	      return restore;
	    }()
	  }, {
	    key: 'pathname',
	    get: function get() {
	      return '/' + usersNamespace + '/' + this.client.appKey;
	    }
	  }]);

	  return UserStore;
	}(_networkstore.NetworkStore);
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 456 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _Expectation = __webpack_require__(457);

	var _Expectation2 = _interopRequireDefault(_Expectation);

	var _SpyUtils = __webpack_require__(464);

	var _assert = __webpack_require__(462);

	var _assert2 = _interopRequireDefault(_assert);

	var _extend = __webpack_require__(482);

	var _extend2 = _interopRequireDefault(_extend);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function expect(actual) {
	  return new _Expectation2.default(actual);
	}

	expect.createSpy = _SpyUtils.createSpy;
	expect.spyOn = _SpyUtils.spyOn;
	expect.isSpy = _SpyUtils.isSpy;
	expect.restoreSpies = _SpyUtils.restoreSpies;
	expect.assert = _assert2.default;
	expect.extend = _extend2.default;

	module.exports = expect;

/***/ },
/* 457 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(console) {'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _has = __webpack_require__(458);

	var _has2 = _interopRequireDefault(_has);

	var _tmatch = __webpack_require__(461);

	var _tmatch2 = _interopRequireDefault(_tmatch);

	var _assert = __webpack_require__(462);

	var _assert2 = _interopRequireDefault(_assert);

	var _SpyUtils = __webpack_require__(464);

	var _TestUtils = __webpack_require__(469);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * An Expectation is a wrapper around an assertion that allows it to be written
	 * in a more natural style, without the need to remember the order of arguments.
	 * This helps prevent you from making mistakes when writing tests.
	 */

	var Expectation = function () {
	  function Expectation(actual) {
	    _classCallCheck(this, Expectation);

	    this.actual = actual;

	    if ((0, _TestUtils.isFunction)(actual)) {
	      this.context = null;
	      this.args = [];
	    }
	  }

	  _createClass(Expectation, [{
	    key: 'toExist',
	    value: function toExist(message) {
	      (0, _assert2.default)(this.actual, message || 'Expected %s to exist', this.actual);

	      return this;
	    }
	  }, {
	    key: 'toNotExist',
	    value: function toNotExist(message) {
	      (0, _assert2.default)(!this.actual, message || 'Expected %s to not exist', this.actual);

	      return this;
	    }
	  }, {
	    key: 'toBe',
	    value: function toBe(value, message) {
	      (0, _assert2.default)(this.actual === value, message || 'Expected %s to be %s', this.actual, value);

	      return this;
	    }
	  }, {
	    key: 'toNotBe',
	    value: function toNotBe(value, message) {
	      (0, _assert2.default)(this.actual !== value, message || 'Expected %s to not be %s', this.actual, value);

	      return this;
	    }
	  }, {
	    key: 'toEqual',
	    value: function toEqual(value, message) {
	      try {
	        (0, _assert2.default)((0, _TestUtils.isEqual)(this.actual, value), message || 'Expected %s to equal %s', this.actual, value);
	      } catch (error) {
	        // These attributes are consumed by Mocha to produce a diff output.
	        error.actual = this.actual;
	        error.expected = value;
	        error.showDiff = true;
	        throw error;
	      }

	      return this;
	    }
	  }, {
	    key: 'toNotEqual',
	    value: function toNotEqual(value, message) {
	      (0, _assert2.default)(!(0, _TestUtils.isEqual)(this.actual, value), message || 'Expected %s to not equal %s', this.actual, value);

	      return this;
	    }
	  }, {
	    key: 'toThrow',
	    value: function toThrow(value, message) {
	      (0, _assert2.default)((0, _TestUtils.isFunction)(this.actual), 'The "actual" argument in expect(actual).toThrow() must be a function, %s was given', this.actual);

	      (0, _assert2.default)((0, _TestUtils.functionThrows)(this.actual, this.context, this.args, value), message || 'Expected %s to throw %s', this.actual, value || 'an error');

	      return this;
	    }
	  }, {
	    key: 'toNotThrow',
	    value: function toNotThrow(value, message) {
	      (0, _assert2.default)((0, _TestUtils.isFunction)(this.actual), 'The "actual" argument in expect(actual).toNotThrow() must be a function, %s was given', this.actual);

	      (0, _assert2.default)(!(0, _TestUtils.functionThrows)(this.actual, this.context, this.args, value), message || 'Expected %s to not throw %s', this.actual, value || 'an error');

	      return this;
	    }
	  }, {
	    key: 'toBeA',
	    value: function toBeA(value, message) {
	      (0, _assert2.default)((0, _TestUtils.isFunction)(value) || typeof value === 'string', 'The "value" argument in toBeA(value) must be a function or a string');

	      (0, _assert2.default)((0, _TestUtils.isA)(this.actual, value), message || 'Expected %s to be a %s', this.actual, value);

	      return this;
	    }
	  }, {
	    key: 'toNotBeA',
	    value: function toNotBeA(value, message) {
	      (0, _assert2.default)((0, _TestUtils.isFunction)(value) || typeof value === 'string', 'The "value" argument in toNotBeA(value) must be a function or a string');

	      (0, _assert2.default)(!(0, _TestUtils.isA)(this.actual, value), message || 'Expected %s to not be a %s', this.actual, value);

	      return this;
	    }
	  }, {
	    key: 'toMatch',
	    value: function toMatch(pattern, message) {
	      (0, _assert2.default)((0, _tmatch2.default)(this.actual, pattern), message || 'Expected %s to match %s', this.actual, pattern);

	      return this;
	    }
	  }, {
	    key: 'toNotMatch',
	    value: function toNotMatch(pattern, message) {
	      (0, _assert2.default)(!(0, _tmatch2.default)(this.actual, pattern), message || 'Expected %s to not match %s', this.actual, pattern);

	      return this;
	    }
	  }, {
	    key: 'toBeLessThan',
	    value: function toBeLessThan(value, message) {
	      (0, _assert2.default)(typeof this.actual === 'number', 'The "actual" argument in expect(actual).toBeLessThan() must be a number');

	      (0, _assert2.default)(typeof value === 'number', 'The "value" argument in toBeLessThan(value) must be a number');

	      (0, _assert2.default)(this.actual < value, message || 'Expected %s to be less than %s', this.actual, value);

	      return this;
	    }
	  }, {
	    key: 'toBeLessThanOrEqualTo',
	    value: function toBeLessThanOrEqualTo(value, message) {
	      (0, _assert2.default)(typeof this.actual === 'number', 'The "actual" argument in expect(actual).toBeLessThanOrEqualTo() must be a number');

	      (0, _assert2.default)(typeof value === 'number', 'The "value" argument in toBeLessThanOrEqualTo(value) must be a number');

	      (0, _assert2.default)(this.actual <= value, message || 'Expected %s to be less than or equal to %s', this.actual, value);

	      return this;
	    }
	  }, {
	    key: 'toBeGreaterThan',
	    value: function toBeGreaterThan(value, message) {
	      (0, _assert2.default)(typeof this.actual === 'number', 'The "actual" argument in expect(actual).toBeGreaterThan() must be a number');

	      (0, _assert2.default)(typeof value === 'number', 'The "value" argument in toBeGreaterThan(value) must be a number');

	      (0, _assert2.default)(this.actual > value, message || 'Expected %s to be greater than %s', this.actual, value);

	      return this;
	    }
	  }, {
	    key: 'toBeGreaterThanOrEqualTo',
	    value: function toBeGreaterThanOrEqualTo(value, message) {
	      (0, _assert2.default)(typeof this.actual === 'number', 'The "actual" argument in expect(actual).toBeGreaterThanOrEqualTo() must be a number');

	      (0, _assert2.default)(typeof value === 'number', 'The "value" argument in toBeGreaterThanOrEqualTo(value) must be a number');

	      (0, _assert2.default)(this.actual >= value, message || 'Expected %s to be greater than or equal to %s', this.actual, value);

	      return this;
	    }
	  }, {
	    key: 'toInclude',
	    value: function toInclude(value, compareValues, message) {
	      if (typeof compareValues === 'string') {
	        message = compareValues;
	        compareValues = null;
	      }

	      if (compareValues == null) compareValues = _TestUtils.isEqual;

	      var contains = false;

	      if ((0, _TestUtils.isArray)(this.actual)) {
	        contains = (0, _TestUtils.arrayContains)(this.actual, value, compareValues);
	      } else if ((0, _TestUtils.isObject)(this.actual)) {
	        contains = (0, _TestUtils.objectContains)(this.actual, value, compareValues);
	      } else if (typeof this.actual === 'string') {
	        contains = (0, _TestUtils.stringContains)(this.actual, value);
	      } else {
	        (0, _assert2.default)(false, 'The "actual" argument in expect(actual).toInclude() must be an array, object, or a string');
	      }

	      (0, _assert2.default)(contains, message || 'Expected %s to include %s', this.actual, value);

	      return this;
	    }
	  }, {
	    key: 'toExclude',
	    value: function toExclude(value, compareValues, message) {
	      if (typeof compareValues === 'string') {
	        message = compareValues;
	        compareValues = null;
	      }

	      if (compareValues == null) compareValues = _TestUtils.isEqual;

	      var contains = false;

	      if ((0, _TestUtils.isArray)(this.actual)) {
	        contains = (0, _TestUtils.arrayContains)(this.actual, value, compareValues);
	      } else if ((0, _TestUtils.isObject)(this.actual)) {
	        contains = (0, _TestUtils.objectContains)(this.actual, value, compareValues);
	      } else if (typeof this.actual === 'string') {
	        contains = (0, _TestUtils.stringContains)(this.actual, value);
	      } else {
	        (0, _assert2.default)(false, 'The "actual" argument in expect(actual).toExclude() must be an array, object, or a string');
	      }

	      (0, _assert2.default)(!contains, message || 'Expected %s to exclude %s', this.actual, value);

	      return this;
	    }
	  }, {
	    key: 'toIncludeKeys',
	    value: function toIncludeKeys(keys, comparator, message) {
	      var _this = this;

	      if (typeof comparator === 'string') {
	        message = comparator;
	        comparator = null;
	      }

	      if (comparator == null) comparator = _has2.default;

	      (0, _assert2.default)(_typeof(this.actual) === 'object', 'The "actual" argument in expect(actual).toIncludeKeys() must be an object, not %s', this.actual);

	      (0, _assert2.default)((0, _TestUtils.isArray)(keys), 'The "keys" argument in expect(actual).toIncludeKeys(keys) must be an array, not %s', keys);

	      var contains = keys.every(function (key) {
	        return comparator(_this.actual, key);
	      });

	      (0, _assert2.default)(contains, message || 'Expected %s to include key(s) %s', this.actual, keys.join(', '));

	      return this;
	    }
	  }, {
	    key: 'toIncludeKey',
	    value: function toIncludeKey(key) {
	      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        args[_key - 1] = arguments[_key];
	      }

	      return this.toIncludeKeys.apply(this, [[key]].concat(args));
	    }
	  }, {
	    key: 'toExcludeKeys',
	    value: function toExcludeKeys(keys, comparator, message) {
	      var _this2 = this;

	      if (typeof comparator === 'string') {
	        message = comparator;
	        comparator = null;
	      }

	      if (comparator == null) comparator = _has2.default;

	      (0, _assert2.default)(_typeof(this.actual) === 'object', 'The "actual" argument in expect(actual).toExcludeKeys() must be an object, not %s', this.actual);

	      (0, _assert2.default)((0, _TestUtils.isArray)(keys), 'The "keys" argument in expect(actual).toIncludeKeys(keys) must be an array, not %s', keys);

	      var contains = keys.every(function (key) {
	        return comparator(_this2.actual, key);
	      });

	      (0, _assert2.default)(!contains, message || 'Expected %s to exclude key(s) %s', this.actual, keys.join(', '));

	      return this;
	    }
	  }, {
	    key: 'toExcludeKey',
	    value: function toExcludeKey(key) {
	      for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
	        args[_key2 - 1] = arguments[_key2];
	      }

	      return this.toExcludeKeys.apply(this, [[key]].concat(args));
	    }
	  }, {
	    key: 'toHaveBeenCalled',
	    value: function toHaveBeenCalled(message) {
	      var spy = this.actual;

	      (0, _assert2.default)((0, _SpyUtils.isSpy)(spy), 'The "actual" argument in expect(actual).toHaveBeenCalled() must be a spy');

	      (0, _assert2.default)(spy.calls.length > 0, message || 'spy was not called');

	      return this;
	    }
	  }, {
	    key: 'toHaveBeenCalledWith',
	    value: function toHaveBeenCalledWith() {
	      for (var _len3 = arguments.length, expectedArgs = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
	        expectedArgs[_key3] = arguments[_key3];
	      }

	      var spy = this.actual;

	      (0, _assert2.default)((0, _SpyUtils.isSpy)(spy), 'The "actual" argument in expect(actual).toHaveBeenCalledWith() must be a spy');

	      (0, _assert2.default)(spy.calls.some(function (call) {
	        return (0, _TestUtils.isEqual)(call.arguments, expectedArgs);
	      }), 'spy was never called with %s', expectedArgs);

	      return this;
	    }
	  }, {
	    key: 'toNotHaveBeenCalled',
	    value: function toNotHaveBeenCalled(message) {
	      var spy = this.actual;

	      (0, _assert2.default)((0, _SpyUtils.isSpy)(spy), 'The "actual" argument in expect(actual).toNotHaveBeenCalled() must be a spy');

	      (0, _assert2.default)(spy.calls.length === 0, message || 'spy was not supposed to be called');

	      return this;
	    }
	  }]);

	  return Expectation;
	}();

	var deprecate = function deprecate(fn, message) {
	  var alreadyWarned = false;

	  return function () {
	    if (!alreadyWarned) {
	      alreadyWarned = true;
	      console.warn(message);
	    }

	    for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
	      args[_key4] = arguments[_key4];
	    }

	    return fn.apply(this, args);
	  };
	};

	Expectation.prototype.withContext = deprecate(function (context) {
	  (0, _assert2.default)((0, _TestUtils.isFunction)(this.actual), 'The "actual" argument in expect(actual).withContext() must be a function');

	  this.context = context;

	  return this;
	}, '\nwithContext is deprecated; use a closure instead.\n\n  expect(fn).withContext(context).toThrow()\n\nbecomes\n\n  expect(() => fn.call(context)).toThrow()\n');

	Expectation.prototype.withArgs = deprecate(function () {
	  var _args;

	  (0, _assert2.default)((0, _TestUtils.isFunction)(this.actual), 'The "actual" argument in expect(actual).withArgs() must be a function');

	  if (arguments.length) this.args = (_args = this.args).concat.apply(_args, arguments);

	  return this;
	}, '\nwithArgs is deprecated; use a closure instead.\n\n  expect(fn).withArgs(a, b, c).toThrow()\n\nbecomes\n\n  expect(() => fn(a, b, c)).toThrow()\n');

	var aliases = {
	  toBeAn: 'toBeA',
	  toNotBeAn: 'toNotBeA',
	  toBeTruthy: 'toExist',
	  toBeFalsy: 'toNotExist',
	  toBeFewerThan: 'toBeLessThan',
	  toBeMoreThan: 'toBeGreaterThan',
	  toContain: 'toInclude',
	  toNotContain: 'toExclude',
	  toNotInclude: 'toExclude',
	  toContainKeys: 'toIncludeKeys',
	  toNotContainKeys: 'toExcludeKeys',
	  toNotIncludeKeys: 'toExcludeKeys',
	  toContainKey: 'toIncludeKey',
	  toNotContainKey: 'toExcludeKey',
	  toNotIncludeKey: 'toExcludeKey'
	};

	for (var alias in aliases) {
	  if (aliases.hasOwnProperty(alias)) Expectation.prototype[alias] = Expectation.prototype[aliases[alias]];
	}exports.default = Expectation;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 458 */
/***/ function(module, exports, __webpack_require__) {

	var bind = __webpack_require__(459);

	module.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);


/***/ },
/* 459 */
/***/ function(module, exports, __webpack_require__) {

	var implementation = __webpack_require__(460);

	module.exports = Function.prototype.bind || implementation;


/***/ },
/* 460 */
/***/ function(module, exports) {

	var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
	var slice = Array.prototype.slice;
	var toStr = Object.prototype.toString;
	var funcType = '[object Function]';

	module.exports = function bind(that) {
	    var target = this;
	    if (typeof target !== 'function' || toStr.call(target) !== funcType) {
	        throw new TypeError(ERROR_MESSAGE + target);
	    }
	    var args = slice.call(arguments, 1);

	    var bound;
	    var binder = function () {
	        if (this instanceof bound) {
	            var result = target.apply(
	                this,
	                args.concat(slice.call(arguments))
	            );
	            if (Object(result) === result) {
	                return result;
	            }
	            return this;
	        } else {
	            return target.apply(
	                that,
	                args.concat(slice.call(arguments))
	            );
	        }
	    };

	    var boundLength = Math.max(0, target.length - args.length);
	    var boundArgs = [];
	    for (var i = 0; i < boundLength; i++) {
	        boundArgs.push('$' + i);
	    }

	    bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);

	    if (target.prototype) {
	        var Empty = function Empty() {};
	        Empty.prototype = target.prototype;
	        bound.prototype = new Empty();
	        Empty.prototype = null;
	    }

	    return bound;
	};


/***/ },
/* 461 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, console, Buffer) {'use strict'

	function isArguments (obj) {
	  return Object.prototype.toString.call(obj) === '[object Arguments]'
	}

	module.exports = match

	function match (obj, pattern) {
	  return match_(obj, pattern, [], [])
	}

	/* istanbul ignore next */
	var log = (/\btmatch\b/.test(process.env.NODE_DEBUG || '')) ?
	  console.error : function () {}

	function match_ (obj, pattern, ca, cb) {
	  log('TMATCH', typeof obj, pattern)
	  if (obj == pattern) {
	    log('TMATCH same object or simple value, or problem')
	    // if one is object, and the other isn't, then this is bogus
	    if (obj === null || pattern === null) {
	      return true

	    } else if (typeof obj === 'object' && typeof pattern === 'object') {
	      return true

	    } else if (typeof obj === 'object' && typeof pattern !== 'object') {
	      return false

	    } else if (typeof obj !== 'object' && typeof pattern === 'object') {
	      return false

	    } else {
	      return true
	    }

	  } else if (obj === null || pattern === null) {
	    log('TMATCH null test, already failed ==')
	    return false

	  } else if (typeof obj === 'string' && pattern instanceof RegExp) {
	    log('TMATCH string~=regexp test')
	    return pattern.test(obj)

	  } else if (typeof obj === 'string' && typeof pattern === 'string' && pattern) {
	    log('TMATCH string~=string test')
	    return obj.indexOf(pattern) !== -1

	  } else if (obj instanceof Date && pattern instanceof Date) {
	    log('TMATCH date test')
	    return obj.getTime() === pattern.getTime()

	  } else if (obj instanceof Date && typeof pattern === 'string') {
	    log('TMATCH date~=string test')
	    return obj.getTime() === new Date(pattern).getTime()

	  } else if (isArguments(obj) || isArguments(pattern)) {
	    log('TMATCH arguments test')
	    var slice = Array.prototype.slice
	    return match_(slice.call(obj), slice.call(pattern), ca, cb)

	  } else if (pattern === Buffer) {
	    log('TMATCH Buffer ctor')
	    return Buffer.isBuffer(obj)

	  } else if (pattern === Function) {
	    log('TMATCH Function ctor')
	    return typeof obj === 'function'

	  } else if (pattern === Number) {
	    log('TMATCH Number ctor (finite, not NaN)')
	    return typeof obj === 'number' && obj === obj && isFinite(obj)

	  } else if (pattern !== pattern) {
	    log('TMATCH NaN')
	    return obj !== obj

	  } else if (pattern === String) {
	    log('TMATCH String ctor')
	    return typeof obj === 'string'

	  } else if (pattern === Boolean) {
	    log('TMATCH Boolean ctor')
	    return typeof obj === 'boolean'

	  } else if (pattern === Array) {
	    log('TMATCH Array ctor', pattern, Array.isArray(obj))
	    return Array.isArray(obj)

	  } else if (typeof pattern === 'function' && typeof obj === 'object') {
	    log('TMATCH object~=function')
	    return obj instanceof pattern

	  } else if (typeof obj !== 'object' || typeof pattern !== 'object') {
	    log('TMATCH obj is not object, pattern is not object, false')
	    return false

	  } else if (obj instanceof RegExp && pattern instanceof RegExp) {
	    log('TMATCH regexp~=regexp test')
	    return obj.source === pattern.source &&
	      obj.global === pattern.global &&
	      obj.multiline === pattern.multiline &&
	      obj.lastIndex === pattern.lastIndex &&
	      obj.ignoreCase === pattern.ignoreCase

	  } else if (Buffer.isBuffer(obj) && Buffer.isBuffer(pattern)) {
	    log('TMATCH buffer test')
	    if (obj.equals) {
	      return obj.equals(pattern)
	    } else {
	      if (obj.length !== pattern.length) return false

	      for (var j = 0; j < obj.length; j++) if (obj[j] != pattern[j]) return false

	      return true
	    }

	  } else {
	    // both are objects.  interesting case!
	    log('TMATCH object~=object test')
	    var kobj = Object.keys(obj)
	    var kpat = Object.keys(pattern)
	    log('  TMATCH patternkeys=%j objkeys=%j', kpat, kobj)

	    // don't bother with stack acrobatics if there's nothing there
	    if (kobj.length === 0 && kpat.length === 0) return true

	    // if we've seen this exact pattern and object already, then
	    // it means that pattern and obj have matching cyclicalness
	    // however, non-cyclical patterns can match cyclical objects
	    log('  TMATCH check seen objects...')
	    var cal = ca.length
	    while (cal--) if (ca[cal] === obj && cb[cal] === pattern) return true
	    ca.push(obj); cb.push(pattern)
	    log('  TMATCH not seen previously')

	    var key
	    for (var l = kpat.length - 1; l >= 0; l--) {
	      key = kpat[l]
	      log('  TMATCH test obj[%j]', key, obj[key], pattern[key])
	      if (!match_(obj[key], pattern[key], ca, cb)) return false
	    }

	    ca.pop()
	    cb.pop()

	    log('  TMATCH object pass')
	    return true
	  }

	  /* istanbul ignore next */
	  throw new Error('impossible to reach this point')
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4), __webpack_require__(2), __webpack_require__(364).Buffer))

/***/ },
/* 462 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _objectInspect = __webpack_require__(463);

	var _objectInspect2 = _interopRequireDefault(_objectInspect);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var formatString = function formatString(string, args) {
	  var index = 0;
	  return string.replace(/%s/g, function () {
	    return (0, _objectInspect2.default)(args[index++]);
	  });
	};

	var assert = function assert(condition, createMessage) {
	  for (var _len = arguments.length, extraArgs = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
	    extraArgs[_key - 2] = arguments[_key];
	  }

	  if (condition) return;

	  var message = typeof createMessage === 'string' ? formatString(createMessage, extraArgs) : createMessage(extraArgs);

	  throw new Error(message);
	};

	exports.default = assert;

/***/ },
/* 463 */
/***/ function(module, exports) {

	var hasMap = typeof Map === 'function' && Map.prototype;
	var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, 'size') : null;
	var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === 'function' ? mapSizeDescriptor.get : null;
	var mapForEach = hasMap && Map.prototype.forEach;
	var hasSet = typeof Set === 'function' && Set.prototype;
	var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, 'size') : null;
	var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === 'function' ? setSizeDescriptor.get : null;
	var setForEach = hasSet && Set.prototype.forEach;
	var booleanValueOf = Boolean.prototype.valueOf;

	module.exports = function inspect_ (obj, opts, depth, seen) {
	    if (!opts) opts = {};
	    
	    var maxDepth = opts.depth === undefined ? 5 : opts.depth;
	    if (depth === undefined) depth = 0;
	    if (depth >= maxDepth && maxDepth > 0 && obj && typeof obj === 'object') {
	        return '[Object]';
	    }
	    
	    if (seen === undefined) seen = [];
	    else if (indexOf(seen, obj) >= 0) {
	        return '[Circular]';
	    }
	    
	    function inspect (value, from) {
	        if (from) {
	            seen = seen.slice();
	            seen.push(from);
	        }
	        return inspect_(value, opts, depth + 1, seen);
	    }
	    
	    if (typeof obj === 'string') {
	        return inspectString(obj);
	    }
	    else if (typeof obj === 'function') {
	        var name = nameOf(obj);
	        return '[Function' + (name ? ': ' + name : '') + ']';
	    }
	    else if (obj === null) {
	        return 'null';
	    }
	    else if (isSymbol(obj)) {
	        var symString = Symbol.prototype.toString.call(obj);
	        return typeof obj === 'object' ? 'Object(' + symString + ')' : symString;
	    }
	    else if (isElement(obj)) {
	        var s = '<' + String(obj.nodeName).toLowerCase();
	        var attrs = obj.attributes || [];
	        for (var i = 0; i < attrs.length; i++) {
	            s += ' ' + attrs[i].name + '="' + quote(attrs[i].value) + '"';
	        }
	        s += '>';
	        if (obj.childNodes && obj.childNodes.length) s += '...';
	        s += '</' + String(obj.nodeName).toLowerCase() + '>';
	        return s;
	    }
	    else if (isArray(obj)) {
	        if (obj.length === 0) return '[]';
	        var xs = Array(obj.length);
	        for (var i = 0; i < obj.length; i++) {
	            xs[i] = has(obj, i) ? inspect(obj[i], obj) : '';
	        }
	        return '[ ' + xs.join(', ') + ' ]';
	    }
	    else if (isError(obj)) {
	        var parts = [];
	        for (var key in obj) {
	            if (!has(obj, key)) continue;
	            
	            if (/[^\w$]/.test(key)) {
	                parts.push(inspect(key) + ': ' + inspect(obj[key]));
	            }
	            else {
	                parts.push(key + ': ' + inspect(obj[key]));
	            }
	        }
	        if (parts.length === 0) return '[' + obj + ']';
	        return '{ [' + obj + '] ' + parts.join(', ') + ' }';
	    }
	    else if (typeof obj === 'object' && typeof obj.inspect === 'function') {
	        return obj.inspect();
	    }
	    else if (isMap(obj)) {
	        var parts = [];
	        mapForEach.call(obj, function (value, key) {
	            parts.push(inspect(key, obj) + ' => ' + inspect(value, obj));
	        });
	        return 'Map (' + mapSize.call(obj) + ') {' + parts.join(', ') + '}';
	    }
	    else if (isSet(obj)) {
	        var parts = [];
	        setForEach.call(obj, function (value ) {
	            parts.push(inspect(value, obj));
	        });
	        return 'Set (' + setSize.call(obj) + ') {' + parts.join(', ') + '}';
	    }
	    else if (typeof obj !== 'object') {
	        return String(obj);
	    }
	    else if (isNumber(obj)) {
	        return 'Object(' + Number(obj) + ')';
	    }
	    else if (isBoolean(obj)) {
	        return 'Object(' + booleanValueOf.call(obj) + ')';
	    }
	    else if (isString(obj)) {
	        return 'Object(' + inspect(String(obj)) + ')';
	    }
	    else if (!isDate(obj) && !isRegExp(obj)) {
	        var xs = [], keys = [];
	        for (var key in obj) {
	            if (has(obj, key)) keys.push(key);
	        }
	        keys.sort();
	        for (var i = 0; i < keys.length; i++) {
	            var key = keys[i];
	            if (/[^\w$]/.test(key)) {
	                xs.push(inspect(key) + ': ' + inspect(obj[key], obj));
	            }
	            else xs.push(key + ': ' + inspect(obj[key], obj));
	        }
	        if (xs.length === 0) return '{}';
	        return '{ ' + xs.join(', ') + ' }';
	    }
	    else return String(obj);
	};

	function quote (s) {
	    return String(s).replace(/"/g, '&quot;');
	}

	function isArray (obj) { return toStr(obj) === '[object Array]' }
	function isDate (obj) { return toStr(obj) === '[object Date]' }
	function isRegExp (obj) { return toStr(obj) === '[object RegExp]' }
	function isError (obj) { return toStr(obj) === '[object Error]' }
	function isSymbol (obj) { return toStr(obj) === '[object Symbol]' }
	function isString (obj) { return toStr(obj) === '[object String]' }
	function isNumber (obj) { return toStr(obj) === '[object Number]' }
	function isBoolean (obj) { return toStr(obj) === '[object Boolean]' }

	var hasOwn = Object.prototype.hasOwnProperty || function (key) { return key in this; };
	function has (obj, key) {
	    return hasOwn.call(obj, key);
	}

	function toStr (obj) {
	    return Object.prototype.toString.call(obj);
	}

	function nameOf (f) {
	    if (f.name) return f.name;
	    var m = f.toString().match(/^function\s*([\w$]+)/);
	    if (m) return m[1];
	}

	function indexOf (xs, x) {
	    if (xs.indexOf) return xs.indexOf(x);
	    for (var i = 0, l = xs.length; i < l; i++) {
	        if (xs[i] === x) return i;
	    }
	    return -1;
	}

	function isMap (x) {
	    if (!mapSize) {
	        return false;
	    }
	    try {
	        mapSize.call(x);
	        return true;
	    } catch (e) {}
	    return false;
	}

	function isSet (x) {
	    if (!setSize) {
	        return false;
	    }
	    try {
	        setSize.call(x);
	        return true;
	    } catch (e) {}
	    return false;
	}

	function isElement (x) {
	    if (!x || typeof x !== 'object') return false;
	    if (typeof HTMLElement !== 'undefined' && x instanceof HTMLElement) {
	        return true;
	    }
	    return typeof x.nodeName === 'string'
	        && typeof x.getAttribute === 'function'
	    ;
	}

	function inspectString (str) {
	    var s = str.replace(/(['\\])/g, '\\$1').replace(/[\x00-\x1f]/g, lowbyte);
	    return "'" + s + "'";
	    
	    function lowbyte (c) {
	        var n = c.charCodeAt(0);
	        var x = { 8: 'b', 9: 't', 10: 'n', 12: 'f', 13: 'r' }[n];
	        if (x) return '\\' + x;
	        return '\\x' + (n < 0x10 ? '0' : '') + n.toString(16);
	    }
	}


/***/ },
/* 464 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.spyOn = exports.createSpy = exports.restoreSpies = exports.isSpy = undefined;

	var _defineProperties = __webpack_require__(465);

	var _assert = __webpack_require__(462);

	var _assert2 = _interopRequireDefault(_assert);

	var _TestUtils = __webpack_require__(469);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } } /*eslint-disable prefer-rest-params, no-underscore-dangle*/


	var noop = function noop() {};

	var supportsConfigurableFnLength = _defineProperties.supportsDescriptors && Object.getOwnPropertyDescriptor(function () {}, 'length').configurable;

	var isSpy = exports.isSpy = function isSpy(object) {
	  return object && object.__isSpy === true;
	};

	var spies = [];

	var restoreSpies = exports.restoreSpies = function restoreSpies() {
	  for (var i = spies.length - 1; i >= 0; i--) {
	    spies[i].restore();
	  }spies = [];
	};

	var createSpy = exports.createSpy = function createSpy(fn) {
	  var restore = arguments.length <= 1 || arguments[1] === undefined ? noop : arguments[1];

	  if (fn == null) fn = noop;

	  (0, _assert2.default)((0, _TestUtils.isFunction)(fn), 'createSpy needs a function');

	  var targetFn = void 0,
	      thrownValue = void 0,
	      returnValue = void 0,
	      spy = void 0;

	  function spyLogic() {
	    spy.calls.push({
	      context: this,
	      arguments: Array.prototype.slice.call(arguments, 0)
	    });

	    if (targetFn) return targetFn.apply(this, arguments);

	    if (thrownValue) throw thrownValue;

	    return returnValue;
	  }

	  if (supportsConfigurableFnLength) {
	    spy = Object.defineProperty(spyLogic, 'length', { value: fn.length, writable: false, enumerable: false, configurable: true });
	  } else {
	    spy = new Function('spy', 'return function(' + // eslint-disable-line no-new-func
	    [].concat(_toConsumableArray(Array(fn.length))).map(function (_, i) {
	      return '_' + i;
	    }).join(',') + ') {\n      return spy.apply(this, arguments)\n    }')(spyLogic);
	  }

	  spy.calls = [];

	  spy.andCall = function (otherFn) {
	    targetFn = otherFn;
	    return spy;
	  };

	  spy.andCallThrough = function () {
	    return spy.andCall(fn);
	  };

	  spy.andThrow = function (value) {
	    thrownValue = value;
	    return spy;
	  };

	  spy.andReturn = function (value) {
	    returnValue = value;
	    return spy;
	  };

	  spy.getLastCall = function () {
	    return spy.calls[spy.calls.length - 1];
	  };

	  spy.reset = function () {
	    spy.calls = [];
	  };

	  spy.restore = spy.destroy = restore;

	  spy.__isSpy = true;

	  spies.push(spy);

	  return spy;
	};

	var spyOn = exports.spyOn = function spyOn(object, methodName) {
	  var original = object[methodName];

	  if (!isSpy(original)) {
	    (0, _assert2.default)((0, _TestUtils.isFunction)(original), 'Cannot spyOn the %s property; it is not a function', methodName);

	    object[methodName] = createSpy(original, function () {
	      object[methodName] = original;
	    });
	  }

	  return object[methodName];
	};

/***/ },
/* 465 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var keys = __webpack_require__(466);
	var foreach = __webpack_require__(468);
	var hasSymbols = typeof Symbol === 'function' && typeof Symbol() === 'symbol';

	var toStr = Object.prototype.toString;

	var isFunction = function (fn) {
		return typeof fn === 'function' && toStr.call(fn) === '[object Function]';
	};

	var arePropertyDescriptorsSupported = function () {
		var obj = {};
		try {
			Object.defineProperty(obj, 'x', { enumerable: false, value: obj });
	        /* eslint-disable no-unused-vars, no-restricted-syntax */
	        for (var _ in obj) { return false; }
	        /* eslint-enable no-unused-vars, no-restricted-syntax */
			return obj.x === obj;
		} catch (e) { /* this is IE 8. */
			return false;
		}
	};
	var supportsDescriptors = Object.defineProperty && arePropertyDescriptorsSupported();

	var defineProperty = function (object, name, value, predicate) {
		if (name in object && (!isFunction(predicate) || !predicate())) {
			return;
		}
		if (supportsDescriptors) {
			Object.defineProperty(object, name, {
				configurable: true,
				enumerable: false,
				value: value,
				writable: true
			});
		} else {
			object[name] = value;
		}
	};

	var defineProperties = function (object, map) {
		var predicates = arguments.length > 2 ? arguments[2] : {};
		var props = keys(map);
		if (hasSymbols) {
			props = props.concat(Object.getOwnPropertySymbols(map));
		}
		foreach(props, function (name) {
			defineProperty(object, name, map[name], predicates[name]);
		});
	};

	defineProperties.supportsDescriptors = !!supportsDescriptors;

	module.exports = defineProperties;


/***/ },
/* 466 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	// modified from https://github.com/es-shims/es5-shim
	var has = Object.prototype.hasOwnProperty;
	var toStr = Object.prototype.toString;
	var slice = Array.prototype.slice;
	var isArgs = __webpack_require__(467);
	var isEnumerable = Object.prototype.propertyIsEnumerable;
	var hasDontEnumBug = !isEnumerable.call({ toString: null }, 'toString');
	var hasProtoEnumBug = isEnumerable.call(function () {}, 'prototype');
	var dontEnums = [
		'toString',
		'toLocaleString',
		'valueOf',
		'hasOwnProperty',
		'isPrototypeOf',
		'propertyIsEnumerable',
		'constructor'
	];
	var equalsConstructorPrototype = function (o) {
		var ctor = o.constructor;
		return ctor && ctor.prototype === o;
	};
	var excludedKeys = {
		$console: true,
		$external: true,
		$frame: true,
		$frameElement: true,
		$frames: true,
		$innerHeight: true,
		$innerWidth: true,
		$outerHeight: true,
		$outerWidth: true,
		$pageXOffset: true,
		$pageYOffset: true,
		$parent: true,
		$scrollLeft: true,
		$scrollTop: true,
		$scrollX: true,
		$scrollY: true,
		$self: true,
		$webkitIndexedDB: true,
		$webkitStorageInfo: true,
		$window: true
	};
	var hasAutomationEqualityBug = (function () {
		/* global window */
		if (typeof window === 'undefined') { return false; }
		for (var k in window) {
			try {
				if (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && typeof window[k] === 'object') {
					try {
						equalsConstructorPrototype(window[k]);
					} catch (e) {
						return true;
					}
				}
			} catch (e) {
				return true;
			}
		}
		return false;
	}());
	var equalsConstructorPrototypeIfNotBuggy = function (o) {
		/* global window */
		if (typeof window === 'undefined' || !hasAutomationEqualityBug) {
			return equalsConstructorPrototype(o);
		}
		try {
			return equalsConstructorPrototype(o);
		} catch (e) {
			return false;
		}
	};

	var keysShim = function keys(object) {
		var isObject = object !== null && typeof object === 'object';
		var isFunction = toStr.call(object) === '[object Function]';
		var isArguments = isArgs(object);
		var isString = isObject && toStr.call(object) === '[object String]';
		var theKeys = [];

		if (!isObject && !isFunction && !isArguments) {
			throw new TypeError('Object.keys called on a non-object');
		}

		var skipProto = hasProtoEnumBug && isFunction;
		if (isString && object.length > 0 && !has.call(object, 0)) {
			for (var i = 0; i < object.length; ++i) {
				theKeys.push(String(i));
			}
		}

		if (isArguments && object.length > 0) {
			for (var j = 0; j < object.length; ++j) {
				theKeys.push(String(j));
			}
		} else {
			for (var name in object) {
				if (!(skipProto && name === 'prototype') && has.call(object, name)) {
					theKeys.push(String(name));
				}
			}
		}

		if (hasDontEnumBug) {
			var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);

			for (var k = 0; k < dontEnums.length; ++k) {
				if (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {
					theKeys.push(dontEnums[k]);
				}
			}
		}
		return theKeys;
	};

	keysShim.shim = function shimObjectKeys() {
		if (Object.keys) {
			var keysWorksWithArguments = (function () {
				// Safari 5.0 bug
				return (Object.keys(arguments) || '').length === 2;
			}(1, 2));
			if (!keysWorksWithArguments) {
				var originalKeys = Object.keys;
				Object.keys = function keys(object) {
					if (isArgs(object)) {
						return originalKeys(slice.call(object));
					} else {
						return originalKeys(object);
					}
				};
			}
		} else {
			Object.keys = keysShim;
		}
		return Object.keys || keysShim;
	};

	module.exports = keysShim;


/***/ },
/* 467 */
/***/ function(module, exports) {

	'use strict';

	var toStr = Object.prototype.toString;

	module.exports = function isArguments(value) {
		var str = toStr.call(value);
		var isArgs = str === '[object Arguments]';
		if (!isArgs) {
			isArgs = str !== '[object Array]' &&
				value !== null &&
				typeof value === 'object' &&
				typeof value.length === 'number' &&
				value.length >= 0 &&
				toStr.call(value.callee) === '[object Function]';
		}
		return isArgs;
	};


/***/ },
/* 468 */
/***/ function(module, exports) {

	
	var hasOwn = Object.prototype.hasOwnProperty;
	var toString = Object.prototype.toString;

	module.exports = function forEach (obj, fn, ctx) {
	    if (toString.call(fn) !== '[object Function]') {
	        throw new TypeError('iterator must be a function');
	    }
	    var l = obj.length;
	    if (l === +l) {
	        for (var i = 0; i < l; i++) {
	            fn.call(ctx, obj[i], i, obj);
	        }
	    } else {
	        for (var k in obj) {
	            if (hasOwn.call(obj, k)) {
	                fn.call(ctx, obj[k], k, obj);
	            }
	        }
	    }
	};



/***/ },
/* 469 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.stringContains = exports.objectContains = exports.arrayContains = exports.functionThrows = exports.isA = exports.isObject = exports.isArray = exports.isFunction = exports.isEqual = exports.whyNotEqual = undefined;

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var _isRegex = __webpack_require__(470);

	var _isRegex2 = _interopRequireDefault(_isRegex);

	var _why = __webpack_require__(471);

	var _why2 = _interopRequireDefault(_why);

	var _objectKeys = __webpack_require__(466);

	var _objectKeys2 = _interopRequireDefault(_objectKeys);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Returns the reason why the given arguments are not *conceptually*
	 * equal, if any; the empty string otherwise.
	 */
	var whyNotEqual = exports.whyNotEqual = function whyNotEqual(a, b) {
	  return a == b ? '' : (0, _why2.default)(a, b);
	};

	/**
	 * Returns true if the given arguments are *conceptually* equal.
	 */
	var isEqual = exports.isEqual = function isEqual(a, b) {
	  return whyNotEqual(a, b) === '';
	};

	/**
	 * Returns true if the given object is a function.
	 */
	var isFunction = exports.isFunction = function isFunction(object) {
	  return typeof object === 'function';
	};

	/**
	 * Returns true if the given object is an array.
	 */
	var isArray = exports.isArray = function isArray(object) {
	  return Array.isArray(object);
	};

	/**
	 * Returns true if the given object is an object.
	 */
	var isObject = exports.isObject = function isObject(object) {
	  return object && !isArray(object) && (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object';
	};

	/**
	 * Returns true if the given object is an instanceof value
	 * or its typeof is the given value.
	 */
	var isA = exports.isA = function isA(object, value) {
	  if (isFunction(value)) return object instanceof value;

	  if (value === 'array') return Array.isArray(object);

	  return (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === value;
	};

	/**
	 * Returns true if the given function throws the given value
	 * when invoked. The value may be:
	 *
	 * - undefined, to merely assert there was a throw
	 * - a constructor function, for comparing using instanceof
	 * - a regular expression, to compare with the error message
	 * - a string, to find in the error message
	 */
	var functionThrows = exports.functionThrows = function functionThrows(fn, context, args, value) {
	  try {
	    fn.apply(context, args);
	  } catch (error) {
	    if (value == null) return true;

	    if (isFunction(value) && error instanceof value) return true;

	    var message = error.message || error;

	    if (typeof message === 'string') {
	      if ((0, _isRegex2.default)(value) && value.test(error.message)) return true;

	      if (typeof value === 'string' && message.indexOf(value) !== -1) return true;
	    }
	  }

	  return false;
	};

	/**
	 * Returns true if the given array contains the value, false
	 * otherwise. The compareValues function must return false to
	 * indicate a non-match.
	 */
	var arrayContains = exports.arrayContains = function arrayContains(array, value, compareValues) {
	  return array.some(function (item) {
	    return compareValues(item, value) !== false;
	  });
	};

	var ownEnumerableKeys = function ownEnumerableKeys(object) {
	  if ((typeof Reflect === 'undefined' ? 'undefined' : _typeof(Reflect)) === 'object' && typeof Reflect.ownKeys === 'function') {
	    return Reflect.ownKeys(object).filter(function (key) {
	      return Object.getOwnPropertyDescriptor(object, key).enumerable;
	    });
	  }

	  if (typeof Object.getOwnPropertySymbols === 'function') {
	    return Object.getOwnPropertySymbols(object).filter(function (key) {
	      return Object.getOwnPropertyDescriptor(object, key).enumerable;
	    }).concat((0, _objectKeys2.default)(object));
	  }

	  return (0, _objectKeys2.default)(object);
	};

	/**
	 * Returns true if the given object contains the value, false
	 * otherwise. The compareValues function must return false to
	 * indicate a non-match.
	 */
	var objectContains = exports.objectContains = function objectContains(object, value, compareValues) {
	  return ownEnumerableKeys(value).every(function (k) {
	    if (isObject(object[k]) && isObject(value[k])) return objectContains(object[k], value[k], compareValues);

	    return compareValues(object[k], value[k]);
	  });
	};

	/**
	 * Returns true if the given string contains the value, false otherwise.
	 */
	var stringContains = exports.stringContains = function stringContains(string, value) {
	  return string.indexOf(value) !== -1;
	};

/***/ },
/* 470 */
/***/ function(module, exports) {

	'use strict';

	var regexExec = RegExp.prototype.exec;
	var tryRegexExec = function tryRegexExec(value) {
		try {
			regexExec.call(value);
			return true;
		} catch (e) {
			return false;
		}
	};
	var toStr = Object.prototype.toString;
	var regexClass = '[object RegExp]';
	var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';

	module.exports = function isRegex(value) {
		if (typeof value !== 'object') { return false; }
		return hasToStringTag ? tryRegexExec(value) : toStr.call(value) === regexClass;
	};


/***/ },
/* 471 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var ObjectPrototype = Object.prototype;
	var toStr = ObjectPrototype.toString;
	var booleanValue = Boolean.prototype.valueOf;
	var has = __webpack_require__(458);
	var isArrowFunction = __webpack_require__(472);
	var isBoolean = __webpack_require__(474);
	var isDate = __webpack_require__(475);
	var isGenerator = __webpack_require__(476);
	var isNumber = __webpack_require__(477);
	var isRegex = __webpack_require__(470);
	var isString = __webpack_require__(478);
	var isSymbol = __webpack_require__(479);
	var isCallable = __webpack_require__(473);

	var isProto = Object.prototype.isPrototypeOf;

	var foo = function foo() {};
	var functionsHaveNames = foo.name === 'foo';

	var symbolValue = typeof Symbol === 'function' ? Symbol.prototype.valueOf : null;
	var symbolIterator = __webpack_require__(480)();

	var collectionsForEach = __webpack_require__(481)();

	var getPrototypeOf = Object.getPrototypeOf;
	if (!getPrototypeOf) {
		/* eslint-disable no-proto */
		if (typeof 'test'.__proto__ === 'object') {
			getPrototypeOf = function (obj) {
				return obj.__proto__;
			};
		} else {
			getPrototypeOf = function (obj) {
				var constructor = obj.constructor,
					oldConstructor;
				if (has(obj, 'constructor')) {
					oldConstructor = constructor;
					if (!(delete obj.constructor)) { // reset constructor
						return null; // can't delete obj.constructor, return null
					}
					constructor = obj.constructor; // get real constructor
					obj.constructor = oldConstructor; // restore constructor
				}
				return constructor ? constructor.prototype : ObjectPrototype; // needed for IE
			};
		}
		/* eslint-enable no-proto */
	}

	var isArray = Array.isArray || function (value) {
		return toStr.call(value) === '[object Array]';
	};

	var normalizeFnWhitespace = function normalizeFnWhitespace(fnStr) {
		// this is needed in IE 9, at least, which has inconsistencies here.
		return fnStr.replace(/^function ?\(/, 'function (').replace('){', ') {');
	};

	var tryMapSetEntries = function tryMapSetEntries(collection) {
		var foundEntries = [];
		try {
			collectionsForEach.Map.call(collection, function (key, value) {
				foundEntries.push([key, value]);
			});
		} catch (notMap) {
			try {
				collectionsForEach.Set.call(collection, function (value) {
					foundEntries.push([value]);
				});
			} catch (notSet) {
				return false;
			}
		}
		return foundEntries;
	};

	module.exports = function whyNotEqual(value, other) {
		if (value === other) { return ''; }
		if (value == null || other == null) {
			return value === other ? '' : String(value) + ' !== ' + String(other);
		}

		var valToStr = toStr.call(value);
		var otherToStr = toStr.call(other);
		if (valToStr !== otherToStr) {
			return 'toStringTag is not the same: ' + valToStr + ' !== ' + otherToStr;
		}

		var valIsBool = isBoolean(value);
		var otherIsBool = isBoolean(other);
		if (valIsBool || otherIsBool) {
			if (!valIsBool) { return 'first argument is not a boolean; second argument is'; }
			if (!otherIsBool) { return 'second argument is not a boolean; first argument is'; }
			var valBoolVal = booleanValue.call(value);
			var otherBoolVal = booleanValue.call(other);
			if (valBoolVal === otherBoolVal) { return ''; }
			return 'primitive value of boolean arguments do not match: ' + valBoolVal + ' !== ' + otherBoolVal;
		}

		var valIsNumber = isNumber(value);
		var otherIsNumber = isNumber(value);
		if (valIsNumber || otherIsNumber) {
			if (!valIsNumber) { return 'first argument is not a number; second argument is'; }
			if (!otherIsNumber) { return 'second argument is not a number; first argument is'; }
			var valNum = Number(value);
			var otherNum = Number(other);
			if (valNum === otherNum) { return ''; }
			var valIsNaN = isNaN(value);
			var otherIsNaN = isNaN(other);
			if (valIsNaN && !otherIsNaN) {
				return 'first argument is NaN; second is not';
			} else if (!valIsNaN && otherIsNaN) {
				return 'second argument is NaN; first is not';
			} else if (valIsNaN && otherIsNaN) {
				return '';
			}
			return 'numbers are different: ' + value + ' !== ' + other;
		}

		var valIsString = isString(value);
		var otherIsString = isString(other);
		if (valIsString || otherIsString) {
			if (!valIsString) { return 'second argument is string; first is not'; }
			if (!otherIsString) { return 'first argument is string; second is not'; }
			var stringVal = String(value);
			var otherVal = String(other);
			if (stringVal === otherVal) { return ''; }
			return 'string values are different: "' + stringVal + '" !== "' + otherVal + '"';
		}

		var valIsDate = isDate(value);
		var otherIsDate = isDate(other);
		if (valIsDate || otherIsDate) {
			if (!valIsDate) { return 'second argument is Date, first is not'; }
			if (!otherIsDate) { return 'first argument is Date, second is not'; }
			var valTime = +value;
			var otherTime = +other;
			if (valTime === otherTime) { return ''; }
			return 'Dates have different time values: ' + valTime + ' !== ' + otherTime;
		}

		var valIsRegex = isRegex(value);
		var otherIsRegex = isRegex(other);
		if (valIsRegex || otherIsRegex) {
			if (!valIsRegex) { return 'second argument is RegExp, first is not'; }
			if (!otherIsRegex) { return 'first argument is RegExp, second is not'; }
			var regexStringVal = String(value);
			var regexStringOther = String(other);
			if (regexStringVal === regexStringOther) { return ''; }
			return 'regular expressions differ: ' + regexStringVal + ' !== ' + regexStringOther;
		}

		var valIsArray = isArray(value);
		var otherIsArray = isArray(other);
		if (valIsArray || otherIsArray) {
			if (!valIsArray) { return 'second argument is an Array, first is not'; }
			if (!otherIsArray) { return 'first argument is an Array, second is not'; }
			if (value.length !== other.length) {
				return 'arrays have different length: ' + value.length + ' !== ' + other.length;
			}
			if (String(value) !== String(other)) { return 'stringified Arrays differ'; }

			var index = value.length - 1;
			var equal = '';
			var valHasIndex, otherHasIndex;
			while (equal === '' && index >= 0) {
				valHasIndex = has(value, index);
				otherHasIndex = has(other, index);
				if (!valHasIndex && otherHasIndex) { return 'second argument has index ' + index + '; first does not'; }
				if (valHasIndex && !otherHasIndex) { return 'first argument has index ' + index + '; second does not'; }
				equal = whyNotEqual(value[index], other[index]);
				index -= 1;
			}
			return equal;
		}

		var valueIsSym = isSymbol(value);
		var otherIsSym = isSymbol(other);
		if (valueIsSym !== otherIsSym) {
			if (valueIsSym) { return 'first argument is Symbol; second is not'; }
			return 'second argument is Symbol; first is not';
		}
		if (valueIsSym && otherIsSym) {
			return symbolValue.call(value) === symbolValue.call(other) ? '' : 'first Symbol value !== second Symbol value';
		}

		var valueIsGen = isGenerator(value);
		var otherIsGen = isGenerator(other);
		if (valueIsGen !== otherIsGen) {
			if (valueIsGen) { return 'first argument is a Generator; second is not'; }
			return 'second argument is a Generator; first is not';
		}

		var valueIsArrow = isArrowFunction(value);
		var otherIsArrow = isArrowFunction(other);
		if (valueIsArrow !== otherIsArrow) {
			if (valueIsArrow) { return 'first argument is an Arrow function; second is not'; }
			return 'second argument is an Arrow function; first is not';
		}

		if (isCallable(value) || isCallable(other)) {
			if (functionsHaveNames && whyNotEqual(value.name, other.name) !== '') {
				return 'Function names differ: "' + value.name + '" !== "' + other.name + '"';
			}
			if (whyNotEqual(value.length, other.length) !== '') {
				return 'Function lengths differ: ' + value.length + ' !== ' + other.length;
			}

			var valueStr = normalizeFnWhitespace(String(value));
			var otherStr = normalizeFnWhitespace(String(other));
			if (whyNotEqual(valueStr, otherStr) === '') { return ''; }

			if (!valueIsGen && !valueIsArrow) {
				return whyNotEqual(valueStr.replace(/\)\s*\{/, '){'), otherStr.replace(/\)\s*\{/, '){')) === '' ? '' : 'Function string representations differ';
			}
			return whyNotEqual(valueStr, otherStr) === '' ? '' : 'Function string representations differ';
		}

		if (typeof value === 'object' || typeof other === 'object') {
			if (typeof value !== typeof other) { return 'arguments have a different typeof: ' + typeof value + ' !== ' + typeof other; }
			if (isProto.call(value, other)) { return 'first argument is the [[Prototype]] of the second'; }
			if (isProto.call(other, value)) { return 'second argument is the [[Prototype]] of the first'; }
			if (getPrototypeOf(value) !== getPrototypeOf(other)) { return 'arguments have a different [[Prototype]]'; }

			if (symbolIterator) {
				var valueIteratorFn = value[symbolIterator];
				var valueIsIterable = isCallable(valueIteratorFn);
				var otherIteratorFn = other[symbolIterator];
				var otherIsIterable = isCallable(otherIteratorFn);
				if (valueIsIterable !== otherIsIterable) {
					if (valueIsIterable) { return 'first argument is iterable; second is not'; }
					return 'second argument is iterable; first is not';
				}
				if (valueIsIterable && otherIsIterable) {
					var valueIterator = valueIteratorFn.call(value);
					var otherIterator = otherIteratorFn.call(other);
					var valueNext, otherNext, nextWhy;
					do {
						valueNext = valueIterator.next();
						otherNext = otherIterator.next();
						if (!valueNext.done && !otherNext.done) {
							nextWhy = whyNotEqual(valueNext, otherNext);
							if (nextWhy !== '') {
								return 'iteration results are not equal: ' + nextWhy;
							}
						}
					} while (!valueNext.done && !otherNext.done);
					if (valueNext.done && !otherNext.done) { return 'first argument finished iterating before second'; }
					if (!valueNext.done && otherNext.done) { return 'second argument finished iterating before first'; }
					return '';
				}
			} else if (collectionsForEach.Map || collectionsForEach.Set) {
				var valueEntries = tryMapSetEntries(value);
				var otherEntries = tryMapSetEntries(other);
				var valueEntriesIsArray = isArray(valueEntries);
				var otherEntriesIsArray = isArray(otherEntries);
				if (valueEntriesIsArray && !otherEntriesIsArray) { return 'first argument has Collection entries, second does not'; }
				if (!valueEntriesIsArray && otherEntriesIsArray) { return 'second argument has Collection entries, first does not'; }
				if (valueEntriesIsArray && otherEntriesIsArray) {
					var entriesWhy = whyNotEqual(valueEntries, otherEntries);
					return entriesWhy === '' ? '' : 'Collection entries differ: ' + entriesWhy;
				}
			}

			var key, valueKeyIsRecursive, otherKeyIsRecursive, keyWhy;
			for (key in value) {
				if (has(value, key)) {
					if (!has(other, key)) { return 'first argument has key "' + key + '"; second does not'; }
					valueKeyIsRecursive = !!value[key] && value[key][key] === value;
					otherKeyIsRecursive = !!other[key] && other[key][key] === other;
					if (valueKeyIsRecursive !== otherKeyIsRecursive) {
						if (valueKeyIsRecursive) { return 'first argument has a circular reference at key "' + key + '"; second does not'; }
						return 'second argument has a circular reference at key "' + key + '"; first does not';
					}
					if (!valueKeyIsRecursive && !otherKeyIsRecursive) {
						keyWhy = whyNotEqual(value[key], other[key]);
						if (keyWhy !== '') {
							return 'value at key "' + key + '" differs: ' + keyWhy;
						}
					}
				}
			}
			for (key in other) {
				if (has(other, key) && !has(value, key)) {
					return 'second argument has key "' + key + '"; first does not';
				}
			}
			return '';
		}

		return false;
	};


/***/ },
/* 472 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var isCallable = __webpack_require__(473);
	var fnToStr = Function.prototype.toString;
	var isNonArrowFnRegex = /^\s*function/;
	var isArrowFnWithParensRegex = /^\([^\)]*\) *=>/;
	var isArrowFnWithoutParensRegex = /^[^=]*=>/;

	module.exports = function isArrowFunction(fn) {
		if (!isCallable(fn)) { return false; }
		var fnStr = fnToStr.call(fn);
		return fnStr.length > 0 &&
			!isNonArrowFnRegex.test(fnStr) &&
			(isArrowFnWithParensRegex.test(fnStr) || isArrowFnWithoutParensRegex.test(fnStr));
	};


/***/ },
/* 473 */
/***/ function(module, exports) {

	'use strict';

	var fnToStr = Function.prototype.toString;

	var constructorRegex = /^\s*class /;
	var isES6ClassFn = function isES6ClassFn(value) {
		try {
			var fnStr = fnToStr.call(value);
			var singleStripped = fnStr.replace(/\/\/.*\n/g, '');
			var multiStripped = singleStripped.replace(/\/\*[.\s\S]*\*\//g, '');
			var spaceStripped = multiStripped.replace(/\n/mg, ' ').replace(/ {2}/g, ' ');
			return constructorRegex.test(spaceStripped);
		} catch (e) {
			return false; // not a function
		}
	};

	var tryFunctionObject = function tryFunctionObject(value) {
		try {
			if (isES6ClassFn(value)) { return false; }
			fnToStr.call(value);
			return true;
		} catch (e) {
			return false;
		}
	};
	var toStr = Object.prototype.toString;
	var fnClass = '[object Function]';
	var genClass = '[object GeneratorFunction]';
	var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';

	module.exports = function isCallable(value) {
		if (!value) { return false; }
		if (typeof value !== 'function' && typeof value !== 'object') { return false; }
		if (hasToStringTag) { return tryFunctionObject(value); }
		if (isES6ClassFn(value)) { return false; }
		var strClass = toStr.call(value);
		return strClass === fnClass || strClass === genClass;
	};


/***/ },
/* 474 */
/***/ function(module, exports) {

	'use strict';

	var boolToStr = Boolean.prototype.toString;

	var tryBooleanObject = function tryBooleanObject(value) {
		try {
			boolToStr.call(value);
			return true;
		} catch (e) {
			return false;
		}
	};
	var toStr = Object.prototype.toString;
	var boolClass = '[object Boolean]';
	var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';

	module.exports = function isBoolean(value) {
		if (typeof value === 'boolean') { return true; }
		if (typeof value !== 'object') { return false; }
		return hasToStringTag ? tryBooleanObject(value) : toStr.call(value) === boolClass;
	};


/***/ },
/* 475 */
/***/ function(module, exports) {

	'use strict';

	var getDay = Date.prototype.getDay;
	var tryDateObject = function tryDateObject(value) {
		try {
			getDay.call(value);
			return true;
		} catch (e) {
			return false;
		}
	};

	var toStr = Object.prototype.toString;
	var dateClass = '[object Date]';
	var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';

	module.exports = function isDateObject(value) {
		if (typeof value !== 'object' || value === null) { return false; }
		return hasToStringTag ? tryDateObject(value) : toStr.call(value) === dateClass;
	};


/***/ },
/* 476 */
/***/ function(module, exports) {

	'use strict';

	var toStr = Object.prototype.toString;
	var fnToStr = Function.prototype.toString;
	var isFnRegex = /^\s*function\*/;

	module.exports = function isGeneratorFunction(fn) {
		if (typeof fn !== 'function') { return false; }
		var fnStr = toStr.call(fn);
		return (fnStr === '[object Function]' || fnStr === '[object GeneratorFunction]') && isFnRegex.test(fnToStr.call(fn));
	};



/***/ },
/* 477 */
/***/ function(module, exports) {

	'use strict';

	var numToStr = Number.prototype.toString;
	var tryNumberObject = function tryNumberObject(value) {
		try {
			numToStr.call(value);
			return true;
		} catch (e) {
			return false;
		}
	};
	var toStr = Object.prototype.toString;
	var numClass = '[object Number]';
	var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';

	module.exports = function isNumberObject(value) {
		if (typeof value === 'number') { return true; }
		if (typeof value !== 'object') { return false; }
		return hasToStringTag ? tryNumberObject(value) : toStr.call(value) === numClass;
	};


/***/ },
/* 478 */
/***/ function(module, exports) {

	'use strict';

	var strValue = String.prototype.valueOf;
	var tryStringObject = function tryStringObject(value) {
		try {
			strValue.call(value);
			return true;
		} catch (e) {
			return false;
		}
	};
	var toStr = Object.prototype.toString;
	var strClass = '[object String]';
	var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';

	module.exports = function isString(value) {
		if (typeof value === 'string') { return true; }
		if (typeof value !== 'object') { return false; }
		return hasToStringTag ? tryStringObject(value) : toStr.call(value) === strClass;
	};


/***/ },
/* 479 */
/***/ function(module, exports) {

	'use strict';

	var toStr = Object.prototype.toString;
	var hasSymbols = typeof Symbol === 'function' && typeof Symbol() === 'symbol';

	if (hasSymbols) {
		var symToStr = Symbol.prototype.toString;
		var symStringRegex = /^Symbol\(.*\)$/;
		var isSymbolObject = function isSymbolObject(value) {
			if (typeof value.valueOf() !== 'symbol') { return false; }
			return symStringRegex.test(symToStr.call(value));
		};
		module.exports = function isSymbol(value) {
			if (typeof value === 'symbol') { return true; }
			if (toStr.call(value) !== '[object Symbol]') { return false; }
			try {
				return isSymbolObject(value);
			} catch (e) {
				return false;
			}
		};
	} else {
		module.exports = function isSymbol(value) {
			// this environment does not support Symbols.
			return false;
		};
	}


/***/ },
/* 480 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var isSymbol = __webpack_require__(479);

	module.exports = function getSymbolIterator() {
		var symbolIterator = typeof Symbol === 'function' && isSymbol(Symbol.iterator) ? Symbol.iterator : null;

		if (typeof Object.getOwnPropertyNames === 'function' && typeof Map === 'function' && typeof Map.prototype.entries === 'function') {
			Object.getOwnPropertyNames(Map.prototype).forEach(function (name) {
				if (name !== 'entries' && name !== 'size' && Map.prototype[name] === Map.prototype.entries) {
					symbolIterator = name;
				}
			});
		}

		return symbolIterator;
	};


/***/ },
/* 481 */
/***/ function(module, exports) {

	'use strict';

	module.exports = function () {
		var mapForEach = (function () {
			if (typeof Map !== 'function') { return null; }
			try {
				Map.prototype.forEach.call({}, function () {});
			} catch (e) {
				return Map.prototype.forEach;
			}
			return null;
		}());

		var setForEach = (function () {
			if (typeof Set !== 'function') { return null; }
			try {
				Set.prototype.forEach.call({}, function () {});
			} catch (e) {
				return Set.prototype.forEach;
			}
			return null;
		}());

		return { Map: mapForEach, Set: setForEach };
	};


/***/ },
/* 482 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _Expectation = __webpack_require__(457);

	var _Expectation2 = _interopRequireDefault(_Expectation);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var Extensions = [];

	function extend(extension) {
	  if (Extensions.indexOf(extension) === -1) {
	    Extensions.push(extension);

	    for (var p in extension) {
	      if (extension.hasOwnProperty(p)) _Expectation2.default.prototype[p] = extension[p];
	    }
	  }
	}

	exports.default = extend;

/***/ }
/******/ ]);